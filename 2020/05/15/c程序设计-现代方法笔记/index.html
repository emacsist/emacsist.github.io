<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>&lt;C程序设计 现代方法&gt;笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="C 的优缺点 底层语言 小型语言 包容性语言 优点 高效 可移植 功能强大 灵" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.57.0" />


<link rel="canonical" href="https://emacsist.github.io/2020/05/15/c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="&lt;C程序设计 现代方法&gt;笔记" />
<meta property="og:description" content="C 的优缺点 底层语言 小型语言 包容性语言 优点 高效 可移植 功能强大 灵" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2020/05/15/c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2020-05-15T14:38:31+08:00" />
<meta property="article:modified_time" content="2020-05-15T14:38:31+08:00" />
<meta itemprop="name" content="&lt;C程序设计 现代方法&gt;笔记">
<meta itemprop="description" content="C 的优缺点 底层语言 小型语言 包容性语言 优点 高效 可移植 功能强大 灵">


<meta itemprop="datePublished" content="2020-05-15T14:38:31&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-15T14:38:31&#43;08:00" />
<meta itemprop="wordCount" content="26992">



<meta itemprop="keywords" content="c,book," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="&lt;C程序设计 现代方法&gt;笔记"/>
<meta name="twitter:description" content="C 的优缺点 底层语言 小型语言 包容性语言 优点 高效 可移植 功能强大 灵"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">&lt;C程序设计 现代方法&gt;笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-05-15 </span>
        
        <span class="more-meta"> 26992 words </span>
        <span class="more-meta"> 54 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#c-的优缺点">C 的优缺点</a>
<ul>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#高效使用-c">高效使用 C</a></li>
</ul></li>
<li><a href="#基本概念">基本概念</a>
<ul>
<li><a href="#编译和链接">编译和链接</a></li>
<li><a href="#注释">注释</a></li>
<li><a href="#声明">声明</a></li>
<li><a href="#指令">指令</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#语句">语句</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#赋值">赋值</a></li>
<li><a href="#初始化">初始化</a></li>
<li><a href="#表达式">表达式</a></li>
<li><a href="#记号-token">记号 token</a></li>
<li><a href="#定义常量-宏定义">定义常量/宏定义</a></li>
<li><a href="#标识符">标识符</a></li>
<li><a href="#程序退出">程序退出</a></li>
<li><a href="#关键字-keyword">关键字 keyword</a></li>
</ul></li>
<li><a href="#常用的编译选项">常用的编译选项</a></li>
<li><a href="#格式化输入输出">格式化输入输出</a>
<ul>
<li><a href="#printf-函数">printf 函数</a>
<ul>
<li><a href="#格式串">格式串</a></li>
<li><a href="#转义序列">转义序列</a></li>
</ul></li>
<li><a href="#scanf-函数">scanf 函数</a>
<ul>
<li><a href="#格式串-1">格式串</a></li>
</ul></li>
<li><a href="#杂项">杂项</a>
<ul>
<li><a href="#i"><code>%i</code></a></li>
<li><a href="#显示">显示 <code>%</code></a></li>
</ul></li>
</ul></li>
<li><a href="#表达式-1">表达式</a>
<ul>
<li><a href="#算术运算符">算术运算符</a>
<ul>
<li><a href="#结合性">结合性</a></li>
</ul></li>
<li><a href="#赋值运算符">赋值运算符</a>
<ul>
<li><a href="#左值-lvalue">左值 lvalue</a></li>
<li><a href="#右值">右值</a></li>
</ul></li>
<li><a href="#自增自减">自增自减</a>
<ul>
<li><a href="#前缀">前缀</a></li>
<li><a href="#后缀">后缀</a></li>
</ul></li>
<li><a href="#表达式求值">表达式求值</a></li>
<li><a href="#表达式语句">表达式语句</a></li>
<li><a href="#注意">注意</a></li>
</ul></li>
<li><a href="#选择语句">选择语句</a>
<ul>
<li><a href="#逻辑表达式">逻辑表达式</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#switch">switch</a></li>
</ul></li>
<li><a href="#循环">循环</a>
<ul>
<li><a href="#逗号表达式">逗号表达式</a></li>
<li><a href="#退出循环">退出循环</a></li>
<li><a href="#空语句">空语句</a></li>
</ul></li>
<li><a href="#基本类型">基本类型</a>
<ul>
<li><a href="#整数">整数</a>
<ul>
<li><a href="#整数溢出">整数溢出</a></li>
<li><a href="#读写整数的格式说明">读写整数的格式说明</a></li>
</ul></li>
<li><a href="#浮点">浮点</a>
<ul>
<li><a href="#读写">读写</a>
<ul>
<li><a href="#读">读</a></li>
<li><a href="#写">写</a></li>
</ul></li>
</ul></li>
<li><a href="#字符">字符</a>
<ul>
<li><a href="#转义">转义</a></li>
<li><a href="#读写-1">读写</a></li>
</ul></li>
<li><a href="#类型转换">类型转换</a>
<ul>
<li><a href="#隐式转换">隐式转换</a></li>
<li><a href="#强制转换">强制转换</a></li>
</ul></li>
<li><a href="#类型定义">类型定义</a></li>
<li><a href="#sizeof">sizeof</a></li>
</ul></li>
<li><a href="#数组">数组</a>
<ul>
<li>
<ul>
<li><a href="#sizeof-1">sizeof</a></li>
</ul></li>
<li><a href="#多维数组">多维数组</a></li>
<li><a href="#常量数组">常量数组</a></li>
<li><a href="#变长数组-c99">变长数组(C99)</a></li>
</ul></li>
<li><a href="#函数-1">函数</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#声明-1">声明</a></li>
<li><a href="#实际参数">实际参数</a>
<ul>
<li><a href="#数组型参数">数组型参数</a></li>
<li><a href="#变长数组参数">变长数组参数</a></li>
<li><a href="#数组参数声明使用-static">数组参数声明使用 static</a></li>
</ul></li>
<li><a href="#复合字面量">复合字面量</a></li>
<li><a href="#程序终止">程序终止</a></li>
<li><a href="#递归">递归</a>
<ul>
<li><a href="#快速排序算法">快速排序算法</a></li>
</ul></li>
</ul></li>
<li><a href="#程序结构">程序结构</a>
<ul>
<li><a href="#局部变量">局部变量</a>
<ul>
<li><a href="#静态局部变量">静态局部变量</a></li>
</ul></li>
<li><a href="#外部变量-全局变量">外部变量(全局变量)</a></li>
<li><a href="#作用域">作用域</a></li>
<li><a href="#构建-c-程序">构建 C 程序</a></li>
</ul></li>
<li><a href="#指针">指针</a>
<ul>
<li><a href="#指针运算符">指针运算符</a></li>
<li><a href="#指针赋值">指针赋值</a></li>
<li><a href="#指针作为参数">指针作为参数</a>
<ul>
<li><a href="#const-保护">const 保护</a></li>
</ul></li>
<li><a href="#指针作为返回值">指针作为返回值</a></li>
<li><a href="#打印指针">打印指针</a></li>
</ul></li>
<li><a href="#指针和数组">指针和数组</a>
<ul>
<li><a href="#指针的算术运算">指针的算术运算</a></li>
<li><a href="#指针比较">指针比较</a></li>
<li><a href="#指向复合常量的指针-c99">指向复合常量的指针(C99)</a></li>
<li><a href="#指针用于数组处理">指针用于数组处理</a></li>
<li><a href="#用数组名作为指针">用数组名作为指针</a></li>
<li><a href="#用指针作为数组名">用指针作为数组名</a></li>
<li><a href="#处理多维数组的元素">处理多维数组的元素</a></li>
<li><a href="#处理多维数组的行">处理多维数组的行</a></li>
<li><a href="#处理多维数组的列">处理多维数组的列</a></li>
<li><a href="#用多维数组名作为指针">用多维数组名作为指针</a></li>
<li><a href="#指针和变长数组-c99">指针和变长数组(C99)</a></li>
</ul></li>
<li><a href="#字符串">字符串</a>
<ul>
<li><a href="#字符串字面量">字符串字面量</a>
<ul>
<li><a href="#延续字符串字面量">延续字符串字面量</a></li>
<li><a href="#如何存储字符串字面量">如何存储字符串字面量</a></li>
<li><a href="#字符串字面量的操作">字符串字面量的操作</a></li>
<li><a href="#字符串字面量与字符常量">字符串字面量与字符常量</a></li>
<li><a href="#字符串字面量可以有多长">字符串字面量可以有多长</a></li>
<li><a href="#为什么不把字符串字面量称为-字符串常量">为什么不把字符串字面量称为“字符串常量”</a></li>
</ul></li>
<li><a href="#字符串变量">字符串变量</a>
<ul>
<li><a href="#初始化字符串变量">初始化字符串变量</a></li>
</ul></li>
<li><a href="#字符数组与字符指针">字符数组与字符指针</a></li>
<li><a href="#字符串的读和写">字符串的读和写</a>
<ul>
<li><a href="#用-printf-函数和-puts-函数写字符串">用 <strong>printf</strong> 函数和 <strong>puts</strong> 函数写字符串</a></li>
<li><a href="#用-scanf-函数和-gets-函数读字符串">用 <strong>scanf</strong> 函数和 <strong>gets</strong> 函数读字符串</a></li>
</ul></li>
<li><a href="#使用-c-语言的字符串库">使用 C 语言的字符串库</a>
<ul>
<li><a href="#strcpy-函数"><strong>strcpy</strong>函数</a></li>
<li><a href="#strlen-函数"><strong>strlen</strong>函数</a></li>
<li><a href="#strcat-函数"><strong>strcat</strong>函数</a></li>
<li><a href="#strcmp-函数"><strong>strcmp</strong>函数</a></li>
</ul></li>
<li><a href="#字符串数组">字符串数组</a></li>
<li><a href="#命令行参数">命令行参数</a></li>
</ul></li>
<li><a href="#预处理器">预处理器</a>
<ul>
<li><a href="#工作原理">工作原理</a></li>
<li><a href="#预处理指令">预处理指令</a>
<ul>
<li><a href="#宏定义">宏定义</a>
<ul>
<li><a href="#简单的宏">简单的宏</a></li>
<li><a href="#带参数的宏">带参数的宏</a></li>
</ul></li>
<li><a href="#运算符"><code>#</code>运算符</a></li>
<li><a href="#宏的通用属性">宏的通用属性</a></li>
<li><a href="#宏定义中的圆括号">宏定义中的圆括号</a></li>
<li><a href="#创建较长的宏">创建较长的宏</a></li>
<li><a href="#预定义宏">预定义宏</a></li>
<li><a href="#空的宏参数-c99">空的宏参数(C99)</a></li>
<li><a href="#参数个数可变的宏-c99">参数个数可变的宏(C99)</a></li>
<li><a href="#func-标识符"><code>__func__</code>标识符</a></li>
</ul></li>
<li><a href="#条件编译">条件编译</a>
<ul>
<li><a href="#if-和-endif">if 和 endif</a>
<ul>
<li><a href="#defined-运算符"><strong>defined</strong>运算符</a></li>
</ul></li>
<li><a href="#ifdef-指令和-ifndef-指令"><code>#ifdef</code> 指令和 <code>#ifndef</code> 指令</a></li>
<li><a href="#elif-指令和-else-指令"><code>#elif</code>指令和<code>#else</code>指令</a></li>
</ul></li>
<li><a href="#其他指令">其他指令</a></li>
</ul></li>
<li><a href="#编写大型程序">编写大型程序</a>
<ul>
<li><a href="#源文件">源文件</a></li>
<li><a href="#头文件">头文件</a>
<ul>
<li><a href="#保护头文件">保护头文件</a></li>
<li><a href="#include-格式">include 格式</a></li>
</ul></li>
<li><a href="#构建">构建</a>
<ul>
<li><a href="#在程序外定义宏">在程序外定义宏</a></li>
</ul></li>
</ul></li>
<li><a href="#结构-联合和枚举">结构、联合和枚举</a>
<ul>
<li><a href="#结构变量">结构变量</a>
<ul>
<li><a href="#对结构的操作">对结构的操作</a></li>
<li><a href="#结构标记的声明">结构标记的声明</a></li>
<li><a href="#结构类型的定义">结构类型的定义</a></li>
<li><a href="#结构作为参数和返回值">结构作为参数和返回值</a></li>
<li><a href="#复合字面量-c99">复合字面量(c99)</a></li>
<li><a href="#嵌套的结构">嵌套的结构</a></li>
<li><a href="#结构数组">结构数组</a></li>
</ul></li>
<li><a href="#联合">联合</a>
<ul>
<li><a href="#用联合来构造混合的数据结构">用联合来构造混合的数据结构</a></li>
<li><a href="#为联合添加-标记字段">为联合添加“标记字段”</a></li>
</ul></li>
<li><a href="#枚举">枚举</a>
<ul>
<li><a href="#枚举标记和类型名">枚举标记和类型名</a></li>
<li><a href="#枚举作为整数">枚举作为整数</a></li>
<li><a href="#用枚举声明-标记字段">用枚举声明“标记字段”</a></li>
<li><a href="#例子">例子</a></li>
</ul></li>
</ul></li>
<li><a href="#指针的高级应用">指针的高级应用</a>
<ul>
<li><a href="#动态存储分配">动态存储分配</a>
<ul>
<li><a href="#内存分配函数">内存分配函数</a></li>
<li><a href="#空指针">空指针</a></li>
</ul></li>
<li><a href="#动态分配字符串">动态分配字符串</a>
<ul>
<li><a href="#calloc-函数">calloc 函数</a></li>
<li><a href="#realloc-函数">realloc 函数</a></li>
</ul></li>
<li><a href="#释放存储空间">释放存储空间</a>
<ul>
<li><a href="#悬空指针">悬空指针</a></li>
</ul></li>
<li><a href="#链表">链表</a>
<ul>
<li><a href="#运算符-1"><code>-&gt;</code>运算符</a></li>
<li><a href="#搜索链表">搜索链表</a></li>
<li><a href="#从链表中删除结点">从链表中删除结点</a></li>
</ul></li>
<li><a href="#指向指针的指针">指向指针的指针</a></li>
<li><a href="#指向函数的指针">指向函数的指针</a></li>
<li><a href="#qsort-函数"><strong>qsort</strong>函数</a></li>
<li><a href="#受限指针c99">受限指针C99</a></li>
<li><a href="#灵活数组成员">灵活数组成员</a></li>
<li><a href="#null-宏表示什么"><strong>NULL</strong>宏表示什么</a></li>
</ul></li>
<li><a href="#声明-2">声明</a>
<ul>
<li><a href="#复杂声明的理解">复杂声明的理解</a></li>
<li><a href="#函数的存储类型">函数的存储类型</a></li>
<li><a href="#初始化式">初始化式</a>
<ul>
<li><a href="#未初始化的变量">未初始化的变量</a></li>
</ul></li>
<li><a href="#内联函数">内联函数</a>
<ul>
<li><a href="#内联函数的限制">内联函数的限制</a></li>
</ul></li>
</ul></li>
<li><a href="#程序设计">程序设计</a>
<ul>
<li><a href="#模块">模块</a>
<ul>
<li><a href="#内聚性与耦合性">内聚性与耦合性</a></li>
<li><a href="#模块的类型">模块的类型</a></li>
</ul></li>
<li><a href="#信息隐藏">信息隐藏</a></li>
<li><a href="#抽象数据类型">抽象数据类型</a>
<ul>
<li><a href="#封装">封装</a></li>
</ul></li>
</ul></li>
<li><a href="#底层程序设计">底层程序设计</a>
<ul>
<li><a href="#位运算符">位运算符</a></li>
<li><a href="#用位运算符访问位">用位运算符访问位</a></li>
<li><a href="#用位运算符访问位域">用位运算符访问位域</a></li>
<li><a href="#结构中的位域">结构中的位域</a>
<ul>
<li><a href="#位域是如何存储的">位域是如何存储的</a></li>
</ul></li>
<li><a href="#将指针作为地址使用">将指针作为地址使用</a></li>
<li><a href="#volatile类型限定符">volatile类型限定符</a></li>
</ul></li>
<li><a href="#标准库">标准库</a>
<ul>
<li><a href="#对标准库中所用名字的限制">对标准库中所用名字的限制</a></li>
<li><a href="#使用宏隐藏的函数">使用宏隐藏的函数</a></li>
</ul></li>
<li><a href="#输入输出">输入输出</a>
<ul>
<li><a href="#流">流</a>
<ul>
<li><a href="#文件指针">文件指针</a></li>
<li><a href="#文本文件与二进制文件">文本文件与二进制文件</a></li>
</ul></li>
<li><a href="#文件操作">文件操作</a>
<ul>
<li><a href="#打开文件">打开文件</a>
<ul>
<li><a href="#模式">模式</a></li>
</ul></li>
<li><a href="#关闭文件">关闭文件</a></li>
<li><a href="#为打开的流附加文件">为打开的流附加文件</a></li>
<li><a href="#从命令行获取文件名">从命令行获取文件名</a></li>
<li><a href="#临时文件">临时文件</a></li>
<li><a href="#文件缓冲">文件缓冲</a></li>
<li><a href="#其他文件操作">其他文件操作</a></li>
</ul></li>
<li><a href="#格式化的输入-输出">格式化的输入/输出</a>
<ul>
<li><a href="#printf-函数-1"><code>...printf</code>  函数</a></li>
<li><a href="#scanf-函数-1"><code>...scanf</code> 函数</a></li>
<li><a href="#检测文件末尾和错误条件">检测文件末尾和错误条件</a></li>
</ul></li>
<li><a href="#字符的输入-输出">字符的输入/输出</a>
<ul>
<li><a href="#输出">输出</a></li>
<li><a href="#输入">输入</a></li>
</ul></li>
<li><a href="#行的输入-输出">行的输入/输出</a>
<ul>
<li><a href="#输出-1">输出</a></li>
<li><a href="#输入-1">输入</a></li>
</ul></li>
<li><a href="#块的输入-输出">块的输入/输出</a></li>
<li><a href="#文件定位">文件定位</a></li>
<li><a href="#字符串的输入-输出">字符串的输入/输出</a>
<ul>
<li><a href="#输出-2">输出</a></li>
<li><a href="#输入-2">输入</a></li>
</ul></li>
</ul></li>
<li><a href="#库对数值和字符数据的支持">库对数值和字符数据的支持</a></li>
<li><a href="#错误处理">错误处理</a>
<ul>
<li><a href="#诊断">诊断</a></li>
<li><a href="#错误">错误</a></li>
<li><a href="#信号处理">信号处理</a>
<ul>
<li><a href="#signal-函数">signal 函数</a></li>
<li><a href="#raise-函数">raise 函数</a></li>
</ul></li>
<li><a href="#非局部跳转">非局部跳转</a></li>
</ul></li>
<li><a href="#国际化特性">国际化特性</a>
<ul>
<li><a href="#本地化">本地化</a>
<ul>
<li><a href="#类别">类别</a></li>
<li><a href="#localeenv-函数">localeenv 函数</a></li>
</ul></li>
<li><a href="#多字节字符和宽字符">多字节字符和宽字符</a>
<ul>
<li><a href="#多字节字符">多字节字符</a></li>
<li><a href="#宽字符">宽字符</a></li>
<li><a href="#统一码和通用字符集">统一码和通用字符集</a></li>
<li><a href="#多字节-宽字符转换函数">多字节/宽字符转换函数</a></li>
<li><a href="#多字节-宽字符串转换函数">多字节/宽字符串转换函数</a></li>
</ul></li>
<li><a href="#拼写替换">拼写替换</a></li>
<li><a href="#通用字符名">通用字符名</a></li>
<li><a href="#扩展的多字节和宽字符实用工具">扩展的多字节和宽字符实用工具</a>
<ul>
<li><a href="#流倾向">流倾向</a></li>
</ul></li>
<li><a href="#宽字符分类和映射实用工具">宽字符分类和映射实用工具</a></li>
</ul></li>
<li><a href="#其他库函数">其他库函数</a>
<ul>
<li><a href="#可变参数">可变参数</a></li>
<li><a href="#通用的实用工具">通用的实用工具</a></li>
<li><a href="#日期和时间">日期和时间</a></li>
</ul></li>
<li><a href="#c99-对数学计算的新增支持">C99 对数学计算的新增支持</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="c-的优缺点">C 的优缺点</h1>

<ul>
<li>底层语言</li>
<li>小型语言</li>
<li>包容性语言</li>
</ul>

<h2 id="优点">优点</h2>

<ul>
<li>高效</li>
<li>可移植</li>
<li>功能强大</li>
<li>灵活</li>
<li>标准库</li>
<li>与 UNIX 系统的集成</li>
</ul>

<h2 id="缺点">缺点</h2>

<ul>
<li>容易隐藏错误</li>
<li>可能会难以理解</li>
<li>可能会难以修改</li>
</ul>

<h2 id="高效使用-c">高效使用 C</h2>

<ul>
<li>规避 C 的缺陷</li>
<li>使用软件工具使其更可靠。 如 <code>lint</code> , <code>splint</code></li>
<li>利用现有的代码库</li>
<li>切合实际的编码规范</li>
<li>避免投机取巧和极度复杂的代码</li>
<li>紧贴标准</li>
</ul>

<h1 id="基本概念">基本概念</h1>

<h2 id="编译和链接">编译和链接</h2>

<ul>
<li>预处理(<code>preprocessor</code>) ： 执行以 <code>#</code> 开头的命令（通常指为<code>指令</code>）</li>
<li>编译(<code>compiler</code>) : 翻译成机器指令（即目标代码）</li>
<li>链接(<code>link</code>) : 将目标代码和其他代码整合在一起产生可执行的程序</li>
</ul>

<h2 id="注释">注释</h2>

<p><code>/* ... */</code>  ： 这种不可以嵌套</p>

<p><code>C99</code> 提供了另一个 : <code>//</code>  ， 这种可以嵌套在 <code>/* ... */</code></p>

<blockquote>
<p>依据 C 标准， 编译器必须用一个空格字符来替换每条注释语句</p>
</blockquote>

<h2 id="声明">声明</h2>

<p>使用变量之前， 必须对其进行声明。指定类型和变量名</p>

<p><code>C99</code> : 声明可以不在语句之前</p>

<h2 id="指令">指令</h2>

<p>即以 <code>#</code> 开头的代码， 它由预处理器执行。</p>

<p>每条指定都要求独立成行</p>

<h2 id="函数">函数</h2>

<p>一系列组合在一起并且赋予了名字的语句</p>

<h2 id="语句">语句</h2>

<p>程序运行时执行的命令</p>

<h2 id="变量">变量</h2>

<p>即数据的存储单元</p>

<h2 id="赋值">赋值</h2>

<p>赋值的右侧可以是一个含有常量， 变量和运算符的公式</p>

<h2 id="初始化">初始化</h2>

<p>没有默认值并且尚未在程序中被赋值的变量是未初始化的</p>

<h2 id="表达式">表达式</h2>

<p>在任何需要数值的地方， 都可以用具有相同类型的表达式</p>

<blockquote>
<p>表达式至少会产生一个 返回值。 而语句则不会。</p>
</blockquote>

<h2 id="记号-token">记号 token</h2>

<p>即许多在不改变意思的基础上无法再分割的字符组。</p>

<ul>
<li>标识符</li>
<li>关键字</li>
<li>运算符</li>
<li>标点符号（逗号，分号，括号等）</li>
<li>字符串字面量</li>
</ul>

<h2 id="定义常量-宏定义">定义常量/宏定义</h2>

<pre><code class="language-c">#define PI 3.14

#define PIF (1.0f/3.14f)
</code></pre>

<p>宏包含运算符时， 必须用括号</p>

<h2 id="标识符">标识符</h2>

<p>变量， 函数， 宏和其他实体进行命名， 这些名字就是标识符 <code>identifier</code></p>

<p>可包含字母，数字和下划线。 但必须以字母或者下划线开头。</p>

<p><code>C 的标识符是区分大小写的</code></p>

<p>C 对标识符的最大长度没有限制。 但标准不同</p>

<ul>
<li>C89， 声称可任意长， 但只要求编译器记住前 31 个字符</li>
<li>C99 ， 只要求编译器记住前 63 个字符</li>
</ul>

<h2 id="程序退出">程序退出</h2>

<p>在 main 函数中 <code>return 0</code> 和 <code>exit(0) 是样的</code> .
如果没有 return ：</p>

<ul>
<li><p>C89 中，退出时返回给 OS 的值是未定义的</p></li>

<li><p>C99 中， 如果main 中声明为 int， 则会向OS 返回 0; 否则是未定义</p></li>
</ul>

<h2 id="关键字-keyword">关键字 keyword</h2>

<table>
<thead>
<tr>
<th>auto</th>
<th>enum</th>
<th>restrict (c99)</th>
<th>unsigned</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>break</code></td>
<td><code>enum</code></td>
<td><code>return</code></td>
<td><code>void</code></td>
</tr>

<tr>
<td><code>case</code></td>
<td><code>float</code></td>
<td><code>short</code></td>
<td><code>volatile</code></td>
</tr>

<tr>
<td><code>char</code></td>
<td><code>for</code></td>
<td><code>signed</code></td>
<td><code>while</code></td>
</tr>

<tr>
<td><code>const</code></td>
<td><code>goto</code></td>
<td><code>sizeof</code></td>
<td><code>_Bool</code> (c99)</td>
</tr>

<tr>
<td><code>continue</code></td>
<td><code>if</code></td>
<td><code>static</code></td>
<td><code>_Complex</code> (c99)</td>
</tr>

<tr>
<td><code>default</code></td>
<td><code>inline</code> (c99)</td>
<td><code>struct</code></td>
<td><code>_Imaginary</code> (c99)</td>
</tr>

<tr>
<td><code>do</code></td>
<td>int</td>
<td><code>switch</code></td>
<td></td>
</tr>

<tr>
<td><code>double</code></td>
<td><code>long</code></td>
<td><code>typedef</code></td>
<td></td>
</tr>

<tr>
<td><code>else</code></td>
<td><code>register</code></td>
<td><code>union</code></td>
<td></td>
</tr>
</tbody>
</table>

<p>C99 新增了 5 个 。 注意它们是区分大小写的</p>

<h1 id="常用的编译选项">常用的编译选项</h1>

<p><code>gcc –O –Wall –W –pedantic –ansi –std=c99 –o pun pun.c</code></p>

<p>在 Mac 上使用</p>

<pre><code class="language-bash">alias gcc-all='gcc-9 -Wall -O -Wextra -pedantic -std=c99 '
</code></pre>

<p>将<code>gcc-9</code> 替换为正确的 GNU GCC 版本</p>

<h1 id="格式化输入输出">格式化输入输出</h1>

<p><code>%</code> 后边的信息指定了把数值从内部形式（二进制）转换成打印形式（字符）</p>

<h2 id="printf-函数">printf 函数</h2>

<p>它必须服从格式串。例如 <code>%f %d</code> ， 表示从后面的参数中， 获取第一个float 类型和第一个整型。 <code>即使它们的位置没对应！</code></p>

<p>例如</p>

<pre><code class="language-c">int i = 10;
float f = 43.22f;

printf(&quot;%f %d\n&quot;, i, f);

//打印出的是 
//43.220001 10
</code></pre>

<h3 id="格式串">格式串</h3>

<p><code>%m.pX</code> 或 <code>%mX</code> 或 <code>%-m.pX</code> 或 <code>%-mX</code></p>

<ul>
<li><code>m</code> : 指定了要显示的最少字符数量。如果要显示的数值所需的字符少于 m， 则是右对齐. 而 <code>-m</code> 表示左对齐。</li>
<li><code>p</code> : precision， 精度。</li>
<li><code>X</code> : 常见的有

<ul>
<li><code>d</code> : 十进制整数</li>
<li><code>e</code> : 指数（科学记数法）。 如果 p 为 0， 则不显示小数点. 默认为 6.</li>
<li><code>f</code> : 浮点数， 没有指数。 p 与 e 同</li>
<li><code>g</code> : 指数或定点进制形式的浮点数, 自动根据数的大小来决定. p 表示小数点后的数字个数</li>
</ul></li>
</ul>

<h3 id="转义序列">转义序列</h3>

<ul>
<li><code>\t</code></li>
<li><code>\n</code></li>
<li><code>\b</code></li>
<li><code>\a</code></li>
<li><code>\&quot;</code></li>
</ul>

<h2 id="scanf-函数">scanf 函数</h2>

<pre><code class="language-c">int a;
scanf(&quot;%d\n&quot;, &amp;a)
</code></pre>

<p><code>scanf</code> 从输入的数据中定位适当类型的项, 并在必要时跳过空白字符(<code>空格</code>, <code>水平和垂直制表符</code>, <code>换页符</code>, <code>换行符</code>)</p>

<p>遇到不可能属于此项的字符时, 停止.</p>

<p>如果读入数据项成功, 则继续处理 ; 如果某一项不能成功读入, 则不再处理剩余部分,  立即返回.</p>

<blockquote>
<p>当 scanf 函数遇到一个不可能属于当前项的字符时, 它会把此字符<code>放回原处</code></p>
</blockquote>

<h3 id="格式串-1">格式串</h3>

<p>格式串中的普通字符. 如果为</p>

<ul>
<li>空白字符 : 格式串中的一个或多个空白字符, scanf 会从输入中重复读空白字符, 直到遇到一个非空白字符为止. 格式串中的空白字符, 可以匹配 <code>0 个或多个空白字符</code></li>
<li>其他字符 : scanf 会将它与下一个输入字符进行比较. 如果匹配, 则放弃输入字符而继续处理. 如果不匹配, 则会把不匹配的字符放回输入, 然后异常退出.</li>
</ul>

<h2 id="杂项">杂项</h2>

<h3 id="i"><code>%i</code></h3>

<p>在 printf 函数中, 与 <code>%d</code> 没区别</p>

<p>在 scanf 函数中, <code>%d</code> 只能与十进制整数匹配, 而 <code>%i</code> 可以匹配八进制(<code>0开头</code>), 十六进制(<code>0x</code> 开头), 十进制表示的整数</p>

<h3 id="显示">显示 <code>%</code></h3>

<p><code>printf(&quot;%%&quot;)</code></p>

<h1 id="表达式-1">表达式</h1>

<blockquote>
<p>C 语言的一特点就是它更多地强调表达式而不是语句</p>
</blockquote>

<h2 id="算术运算符">算术运算符</h2>

<ul>
<li><code>/</code> : 当两个操作数都是整数时, 运算符 <code>/</code> 会丢掉分数部分来截取结果</li>
<li><code>%</code> : 要求两个操作数都是整数. 否则编译不通过</li>
<li><code>/</code> 或 <code>%</code> 中, 0 作为右操作数会导致未定义的行为</li>
<li><code>/</code> 或 <code>%</code> 中用于负操作数时, 结果难以确定.

<ul>
<li>C89 中, 结果既可向上取整, 也可向下取整.</li>
<li>C99 中, 除法结果总是向零截取.</li>
</ul></li>
</ul>

<h3 id="结合性">结合性</h3>

<ul>
<li>左结合 : 二元运算符都是左结合</li>
<li>右结合 : 一元运算符</li>
</ul>

<h2 id="赋值运算符">赋值运算符</h2>

<blockquote>
<p>它不同于其他编程语言, 在 C 中, 赋值就像 + 那样是运算符. 即它会产生结果</p>

<p>所以, 它可以连写:  i = j = k = 0</p>
</blockquote>

<ul>
<li>简单赋值: <code>=</code></li>
<li>复合赋值: <code>+=</code>, <code>-=</code> 等等</li>
</ul>

<h3 id="左值-lvalue">左值 lvalue</h3>

<p>表示存储在计算机内存中的对象, 而不是常量或计算的结果.</p>

<p>赋值运算符要求左操作数是左值.</p>

<h3 id="右值">右值</h3>

<p>即是表达式.</p>

<p>可以为变量, 常量或更复杂的表达式</p>

<h2 id="自增自减">自增自减</h2>

<h3 id="前缀">前缀</h3>

<p><code>++i</code>  : 它的结果是 <code>i+1</code> , 副作用的效果是自增 i  . 即: 立即自增 i</p>

<p>它和赋值运算符一样, 也有副作用.</p>

<h3 id="后缀">后缀</h3>

<p><code>i++</code> : 它的结果是 <code>i</code> , 副作用是自增 i . 即: 先使用 i 的原始值, 稍后再自增 i .</p>

<h2 id="表达式求值">表达式求值</h2>

<p>注意, C 语言并没有定义子表达式的求值顺序. 除了</p>

<ul>
<li>含有 逻辑与 以及 逻辑或 运算符</li>
<li>条件运算符</li>
<li>逗号运算符</li>
</ul>

<blockquote>
<p>同时访问及修改变量的值是不可取的. 例如</p>

<p>a = 5</p>

<p>c = (b = a + 2) - (a = 1)</p>
</blockquote>

<h2 id="表达式语句">表达式语句</h2>

<p>任何表达式都可以用作语句.  即, 不论表达式是什么类型, 计算什么结果, 都可以在后面添加分号将其转换成语句.例如表达式 <code>++i</code> 转换成语句则为 <code>++i;</code></p>

<h2 id="注意">注意</h2>

<p>如果 v 有副作用, 则 <code>v += e</code> 不等价于 <code>v = v + e</code></p>

<p>因为 <code>v += e</code> 只会求一次 v 的值. 而 <code>v = v + e</code> 会求两次 v 的值.</p>

<p>自增或自减, 对于现代编译器而言不会使程序更小或更快, 继续使用这些运算符主要是由于它们的简洁和便利.</p>

<p>自增和自减也可以处理 float 变量</p>

<h1 id="选择语句">选择语句</h1>

<h2 id="逻辑表达式">逻辑表达式</h2>

<blockquote>
<p>在 C 语言中, 比较运算会产生整数: 0(假) 或 1(真)</p>

<p>并且 C 中, 非零值都解释为 真</p>
</blockquote>

<p>布尔逻辑会对操作数进行 <code>短路</code> 计算 : 即先计算 左操作数的值, 然后计算右操作数. 如果表达式的值可以仅由左操作数推导, 则不计算右操作数.</p>

<pre><code class="language-c">if (表达式) {
}

if (表达式) {
} else if (表达式) {
} else if (表达式) {
} else {
}

if (表达式) {
} else {
}
</code></pre>

<h2 id="布尔值">布尔值</h2>

<p>C89 中没定义布尔类型. 所以 C89 风格通常使用</p>

<pre><code class="language-c">#define TRUE 1
#define FALSE 0
</code></pre>

<p>来标识</p>

<p>C99 中提供了 <code>_Bool</code> 型, 它是无符号整型. 但和一般的整型不同, 它只能赋值 0 或 1. (因为 C89 标准指出, 以下划线后跟一个大写字母的名字是保留字, 程序员不应该使用)</p>

<p>C99 也提供了一个新的 header : <code>&lt;stdbool.h&gt;</code> , 这时就可以这样子用</p>

<pre><code class="language-c">bool flag;

flag = false;
flag = true;
</code></pre>

<h2 id="switch">switch</h2>

<p>它往往比 if 语句执行速度快且更易阅读.</p>

<blockquote>
<p>C 不允许有重复的分支标号. 但对顺序没要求, 特别是 default 分支不一定要放在最后.</p>
</blockquote>

<h1 id="循环">循环</h1>

<ul>
<li>while</li>
<li>do</li>
<li>for</li>
</ul>

<p>在 C99 中, for 语句的第一个表达式可以替换为一个声明. 即</p>

<pre><code class="language-c">for (int i = 0; i &lt; n; i++ {
}
</code></pre>

<h2 id="逗号表达式">逗号表达式</h2>

<p><code>ex1, ex2</code> : 这里要通过两步来实现.</p>

<ol>
<li>计算 ex1 并且扔掉计算出的值</li>
<li>计算 ex2 , 把这个值作为整个表达式的值</li>
</ol>

<blockquote>
<p>左操作数在右操作数之前求值</p>
</blockquote>

<h2 id="退出循环">退出循环</h2>

<ul>
<li>break 语句</li>
<li>continue 语句</li>
<li>goto 语句</li>
</ul>

<p>break, continue 和 return 语句本质上都是受限制的 goto 语句.</p>

<h2 id="空语句">空语句</h2>

<p>即 <code>;</code></p>

<h1 id="基本类型">基本类型</h1>

<h2 id="整数">整数</h2>

<p>有符号和无符号 . 各种组合</p>

<pre><code class="language-c">// 可缩写为 short 或 unsigned short
short int 
unsigned short int

int 
unsigned int

// 可缩写为 long 或 unsigned long
long int 
unsigned long int
</code></pre>

<p>取值范围, 可以可看 <code>&lt;limits.h&gt;</code> 定义的宏.</p>

<p>C99 添加了额外两个标准类型: <code>long long int</code> 和 <code>unsigned long long int</code></p>

<p>long long 类型要求至少是 64 位宽.</p>

<h3 id="整数溢出">整数溢出</h3>

<p>对于有符号, 行为是未定义的.</p>

<p>对于无符号, 结果定义为: <code>对 2^n 取模</code>. n 是用于存储结果的位数.</p>

<h3 id="读写整数的格式说明">读写整数的格式说明</h3>

<ul>
<li>无符号

<ul>
<li><code>u</code> : 十进制</li>
<li><code>o</code> : 八进制</li>
<li><code>x</code> : 十六进制</li>
</ul></li>
<li>短整数 : 在 <code>d</code> , <code>o</code>, <code>u</code> 或 <code>x</code> 前面加上字母 <code>h</code></li>
<li>长整数 : 在 <code>d</code>, <code>o</code>, <code>u</code>, <code>x</code> 前加上字母 <code>l</code></li>
<li>C99 中的 long long int 时 : 在 <code>d</code>, <code>o</code>, <code>u</code>, <code>x</code> 前加上字母 <code>ll</code></li>
</ul>

<h2 id="浮点">浮点</h2>

<ul>
<li>float</li>
<li>double</li>
<li>long double</li>
</ul>

<p>C99 添加了</p>

<ul>
<li><code>float _Complex</code></li>
<li><code>double _Complex</code></li>
<li><code>long double _Complex</code></li>
</ul>

<h3 id="读写">读写</h3>

<h4 id="读">读</h4>

<p>单精度 float</p>

<ul>
<li><code>%e</code></li>
<li><code>%f</code></li>
<li><code>%g</code></li>
</ul>

<p>双精度 double</p>

<ul>
<li><code>%le</code></li>
<li><code>%lf</code></li>
<li><code>%lg</code></li>
</ul>

<p>long long double</p>

<ul>
<li><code>%Le</code></li>
<li><code>%Lf</code></li>
<li><code>%Lg</code></li>
</ul>

<h4 id="写">写</h4>

<p>printf 中 <code>e</code>, <code>f</code>, <code>g</code> 可以输出 float 或 double</p>

<p>long long double, 则为 <code>%Le</code>, <code>%Lf</code>, <code>%Lg</code></p>

<h2 id="字符">字符</h2>

<p>用单引号括起来, 而不是双引号</p>

<blockquote>
<p>在 C 中, 把字符当作小整数进行处理.</p>

<p>字符常量, 事实上是 int 类型而不是 char 类型.</p>
</blockquote>

<p>C 标准并没有说明 cahr 是有符号还是无符号的. 如果要确实区分, 要明确写成</p>

<p><code>signed char</code> 或 <code>unsigned char</code></p>

<p>C99 的整数类型含义包含了字符类型, 枚举类型以为 <code>_Bool</code> 类型(无符号整数)</p>

<h3 id="转义">转义</h3>

<ul>
<li>字符转义序列</li>
<li>数字转义序列

<ul>
<li>八进制: <code>\033</code> 或 <code>\33</code> , 注意, 不一定要用 0 开头</li>
<li>十六进制: <code>\xFF</code> . <code>x</code> 必须小写. 十六进制的数字则不限大小写</li>
</ul></li>
</ul>

<h3 id="读写-1">读写</h3>

<ul>
<li>scanf 和 printf 函数. scanf 函数不会跳过空白字符, 并且它会遗留下它扫视过, 但未读取的字符(包括换行符)</li>
<li>getchar 和 putchar : 比 scanf 和 printf 更快. 并且通常是作为宏实现.

<ul>
<li>getchar 返回的是一个 int 类型而不是 char 类型. 它也不会跳过空白</li>
</ul></li>
</ul>

<h2 id="类型转换">类型转换</h2>

<h3 id="隐式转换">隐式转换</h3>

<ul>
<li>算术表达式或逻辑表达式的操作数类型不相同时</li>
<li>赋值运算符右侧表达式的类型和左侧变量的类型不匹配时 : 将右边的转换成左边的类型</li>
<li>函数调用中的实参类型与形参类型不匹配时</li>

<li><p>当 return 语句中表达式的类型和函数返回值的类型不匹配时</p>

<pre><code class="language-bash">float -&gt; double -&gt; long double


int -&gt; unsigned int -&gt; long int -&gt; unsigned long int
</code></pre></li>
</ul>

<p>C99 标准下, 转换等级从高到低为</p>

<ul>
<li><code>long long int</code>, <code>unsigned long long int</code></li>
<li><code>long int</code>, <code>unsigned long int</code></li>
<li><code>int</code>, <code>unsigned int</code></li>
<li><code>short int</code>, <code>unsigned short int</code></li>
<li><code>char</code>, <code>unsigned char</code>, <code>signed char</code></li>
<li><code>_Bool</code></li>
</ul>

<h3 id="强制转换">强制转换</h3>

<p><code>(类型名)表达式</code></p>

<blockquote>
<p>C 语言把 <code>(类型名)</code> 视为一元运算符. 它的优先级高于二元运算符. 所以 <code>(float)dividend / divisor</code> 解释为</p>

<p><code>((float) dividend) / divisor</code></p>
</blockquote>

<p>有时候需要使用强制转换来避免溢出. 例如</p>

<pre><code class="language-c">long i;
int j = 1000;
i = j * j ;
</code></pre>

<p>在某些机器上 , <code>j * j</code>  的结果太大, 无法表示成 <code>int</code> 从而导致溢出. 这时可用强制转换来避免</p>

<pre><code class="language-c">i = (long) j * j
// 注意不是 (long) (j * j )
</code></pre>

<p>但要注意的是 <code>i = (long)(j * j)</code> 是不对的, 因为溢出在强制类型转换之前就已经发生了.</p>

<h2 id="类型定义">类型定义</h2>

<pre><code class="language-c">#define BOOL int

//或

typedef int Bool
</code></pre>

<ul>
<li>易于理解</li>
<li>易于修改</li>
</ul>

<p>C 语言库自身使用 <code>typedef</code> 为那些可能依据 C 实现不同而不同的类型创建类型名, 这些类型名经常以 <code>_t</code> 结尾.</p>

<blockquote>
<p>类型定义比宏定义功能更强大. 特别是, 数组和指数类型不能定义为宏的.</p>

<p>其次, typedef 命名的对象具有和变量相同的作用域规则;</p>

<p>定义在函数体内的 typedef 名字在函数外是无法识别的</p>

<p>而宏的名字, 在预处理时会在任何出现的地方被替换</p>
</blockquote>

<h2 id="sizeof">sizeof</h2>

<p><code>sizeof (类型名)</code> , 它返回值是一个无符号整数, 代表存储类型名的值所需要的字节数. 它是一种特殊的运算符, 因为编译器本身通常就能确定 sizeof 表达式的值(<code>C89 中编译器总是可以确定. 但 C99 有一个例外, 编译器不能确定变长数组的大小, 因为它在运行期间是可变的</code>). <code>sizeof(char)</code> 的值始终为 1.</p>

<p>它可用于</p>

<ul>
<li>常量</li>
<li>变量</li>
<li>表达式</li>
</ul>

<blockquote>
<p>注意, 它是一元运算符</p>
</blockquote>

<p>C99 中在printf 中可以 <code>%zu</code> 转出其 sizeof 的结果</p>

<h1 id="数组">数组</h1>

<p>声明数组, 需要指明元素的类型和数量</p>

<pre><code class="language-c">int a[10];
</code></pre>

<p>数组的下标(索引), 始终是从 0 开始. 所以长度为 n 的数组, 索引是范围是 <code>0 ~ n-1</code></p>

<p>下标(索引)可以是任何整数的表达式</p>

<p>初始化</p>

<pre><code class="language-c">int a[10] = {1,2,3}

int a[10] = {0}
</code></pre>

<p>如果比数组短, 则其余赋值为 0.</p>

<p>指定初始化</p>

<pre><code class="language-c">// C99 特性. 没有特定的则为 0
int a[15] = {[2]=29, [9]=7}

// 如果不指定长度, 则根据指定的最大的下标来推导. 下面的数组大小为 31.
int a[] = {[2]=19, [30]=3}
</code></pre>

<h3 id="sizeof-1">sizeof</h3>

<p>它返回的是数组的大小. 即</p>

<pre><code class="language-c">int a[10];
sizeof(a) //一般为 40
</code></pre>

<h2 id="多维数组">多维数组</h2>

<pre><code class="language-c">int m[5][9];

//初始化
int a[2][3] = {{1,2,3}, {4,5,6}}

//或, 以下表示元素全初始化为 0
int a[2][3] = {0}
</code></pre>

<p>形式为 <code>m[i][j]</code></p>

<ul>
<li><code>i</code> : 数组 m 的第 i 行(从 0 开始)</li>
<li><code>j</code> : 数组 m 的第 i 行的第 j 列(从 0 开始)</li>
</ul>

<blockquote>
<p>C 语言是按行主序存储数组的.  即先存储完第 0 行, 然后第 1 行,等等.</p>
</blockquote>

<p>多维数组也可以指定初始化(C99 标准), 然后其余元素为 0.</p>

<h2 id="常量数组">常量数组</h2>

<p>使用 <code>const</code> 来修饰.</p>

<h2 id="变长数组-c99">变长数组(C99)</h2>

<pre><code class="language-c">int n;
scanf(&quot;%d&quot;, &amp;n);

int a[n];
</code></pre>

<blockquote>
<p>它们没有静态存储期限</p>

<p>以及没有初始化式</p>
</blockquote>

<p>注意, <code>C99 不允许 goto 语句绕过变长数组的声明.</code></p>

<h1 id="函数-1">函数</h1>

<h2 id="定义">定义</h2>

<pre><code class="language-c">返回类型 函数名(形式参数) {
  声明
  语句
}
</code></pre>

<h2 id="声明-1">声明</h2>

<p><code>返回类型 函数名 (形式参数);</code></p>

<p>编译器检查时, 如果没有&rdquo;看见&rdquo;函数的声明, 则会假设它的返回值类型为 <code>int</code> , 参数类型也是 <code>int</code> . 如果编译器在后面遇到函数的定义时, 如果不一致, 则会报错.(即隐式声明函数)</p>

<p>比如这样子</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int sum = add(1, 2);
    printf(&quot;%d\n&quot;, sum);
    return 0;
}

int add(int a, int b) {
    return a + b;
}
</code></pre>

<p>编译器可以通过并正确运行.</p>

<p>但如果函数为</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    double sum = add(1, 2);
    printf(&quot;%f\n&quot;, sum);
    return 0;
}

double add(double a, double b) {
    return a + b;
}
</code></pre>

<p>则会报错如下</p>

<pre><code class="language-bash">hello.c:6:18: warning: implicit declaration of function 'add' is invalid in C99 [-Wimplicit-function-declaration]
    double sum = add(1, 2);
                 ^
hello.c:11:8: error: conflicting types for 'add'
double add(double a, double b) {
       ^
hello.c:6:18: note: previous implicit declaration is here
    double sum = add(1, 2);
                 ^
1 warning and 1 error generated.
</code></pre>

<p>但如果先声明, 则可以正确运行:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

double add(double a, double b);

int main(void) {
    double sum = add(1, 2);
    printf(&quot;%f\n&quot;, sum);
    return 0;
}

double add(double a, double b) {
    return a + b;
}
</code></pre>

<p>不过, C99 标准的话, 则必须先声明或定义, 再调用, 否则报错.</p>

<h2 id="实际参数">实际参数</h2>

<p>C 语言中, 实际参数是 <code>值传递</code> 的.</p>

<p>参数转换</p>

<ul>
<li>编译器在调用前遇到原型。就像使用赋值一样，每个实际参数的值被隐式地转换成相应 形式参数的类型</li>
<li>编译器在调用前没有遇到原型。编译器执行默认的实际参数提升:(1)把float类型的 实际参数转换成double类型，(2)执行整值提升，即把char类型和short类型的实际参数转换成int类型</li>
</ul>

<p>实际参数不能是任意表达式, 而必须是赋值表达式. 在赋值表达式中, 不能用逗号作为运算符, 除非逗号是在圆括号中.</p>

<h3 id="数组型参数">数组型参数</h3>

<pre><code class="language-c">int sum_array(int a[], int n) {
}

int m[10];
int sum = sum_array(m, 10);
</code></pre>

<p>注意, 传递数组时, 在函数内的修改, 会体现在函数外部</p>

<h3 id="变长数组参数">变长数组参数</h3>

<pre><code class="language-c">int sum_array(int n, int a[n]) {
}
</code></pre>

<blockquote>
<p>注意, 参数的顺序很重要.</p>
</blockquote>

<h3 id="数组参数声明使用-static">数组参数声明使用 static</h3>

<pre><code class="language-c">int sum_array(int a[static 3], int n) {
}
</code></pre>

<p>这里的 static 只是一个提示, C 编译器可以据此生成更快的指令来访问数组.</p>

<p>如果数组是多维的, static 仅可用于第一维(例如, 二维数组的话, 则是行数)</p>

<h2 id="复合字面量">复合字面量</h2>

<p>通过指定其包含的元素而创建没有名字的数组. 例如</p>

<pre><code class="language-c">total = sum_array((int []){3,2,3,4}, 5);
</code></pre>

<p>它的长度是由元素个数决定.</p>

<p>函数内部创建的复合字面量可以包含任意的表达式, 不限于常量. 例如</p>

<pre><code class="language-c">total = sum_array((int []){2 * i, i + j, j * k}, 3);
</code></pre>

<p>默认情况下, 复全字面量为左值, 的以元素可变.</p>

<p>如果要求为只读, 则可以加上 <code>const</code> . 例如 <code>(const int []){5, 4}</code></p>

<h2 id="程序终止">程序终止</h2>

<p>以前C 程序常常省略main 的返回类型, 这是利用了返回类型默认为 int 的传统.</p>

<p>但在 C99 中, 省略函数的返回类型是不合法的.</p>

<ul>
<li><code>return</code></li>
<li><code>exit</code> 函数. 它是 <code>&lt;stdlib.h&gt;</code> header 文件中</li>
</ul>

<p>main 函数中的语句 <code>return 表达式;</code> 等同于 <code>exit(表达式);</code></p>

<p>它们的区别是, <code>exit</code> 函数, 不管哪个函数调用, 都会导致程序终止. 而 <code>return</code> 则只有当 main 函数调用时才会导致程序终止.</p>

<h2 id="递归">递归</h2>

<blockquote>
<p>为了防止 无限递归，所有递归函数都需要某些类型的终止条件</p>
</blockquote>

<pre><code class="language-c">int fact(int n) {
	if (n &lt;= 1) return 1;
	else
	return n * fact(n-1);
}
</code></pre>

<p>它的递归过程</p>

<pre><code class="language-bash">fact(3)发现3不是小于或等于1的，所以fact(3)调用 
	fact(2)，此函数发现2不是小于或等于1的，所以fact(2)调用
		fact(1)，此函数发现1是小于或等于1的，所以fact(1)返回1，从而导致 
	fact(2)返回2×1=2，从而导致
fact(3)返回3×2=6
</code></pre>

<h3 id="快速排序算法">快速排序算法</h3>

<ol>
<li>选择数组元素e(作为“分割元素”)，然后重新排列数组使得元素从1一直到i1都是小 于或等于e的，元素i包含e，而元素从i+1一直到n都是大于或等于e的。</li>
<li>通过递归地采用快速排序方法，对从1到i1的元素进行排序。</li>
<li>通过递归地采用快速排序方法，对从i+1到n的元素进行排序。</li>
</ol>

<h1 id="程序结构">程序结构</h1>

<h2 id="局部变量">局部变量</h2>

<ul>
<li>自动存储期限</li>
<li>块作用域</li>
</ul>

<blockquote>
<p>C99 不要求函数在一开始就进行变量声明.</p>
</blockquote>

<h3 id="静态局部变量">静态局部变量</h3>

<p>它具有静态存储期限. 拥有永久的存储单元, 在整个程序执行期间都会保留变量的值.</p>

<p>但它始终是块作用域, 所以对其他函数是不可见的.</p>

<h2 id="外部变量-全局变量">外部变量(全局变量)</h2>

<ul>
<li>静态存储期限</li>
<li>文件作用域</li>
</ul>

<h2 id="作用域">作用域</h2>

<p>当程序块内的声明命名一个标识符时，如果此标识符已经是 可见的(因为此标识符拥有文件作用域，或者因为它已在某个程序块内声明)，新的声明临时</p>

<p>“隐藏”了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义</p>

<h2 id="构建-c-程序">构建 C 程序</h2>

<pre><code class="language-c">#include指令;
#define指令;
类型定义;
外部变量的声明;
除main函数之外的函数的原型; 
main函数的定义;
其他函数的定义
</code></pre>

<h1 id="指针">指针</h1>

<blockquote>
<p>指针就是地址， 而指针变量就是存储地址的变量</p>
</blockquote>

<p>C语言要求每个指针变量只能指向一种特定类型(引用类型)的对象</p>

<h2 id="指针运算符">指针运算符</h2>

<ul>
<li><code>&amp;</code>(取 地址)运算符。如果x是变量，那么<code>&amp;x</code>就是x在内存中的地址。</li>
<li>为了获得对指针所指向对象的访 问，可以使用<code>*</code>(间接寻址)运算符。如果p是指针，那么<code>*p</code>表示p当前指向的对象</li>
</ul>

<h2 id="指针赋值">指针赋值</h2>

<pre><code class="language-c">int i, j, *p, *q;
p = &amp;i;
q = p;
</code></pre>

<h2 id="指针作为参数">指针作为参数</h2>

<p>向函数传递需要的指针却失败了可能会产生严重的后果</p>

<pre><code class="language-c">void decompose(double x, long *int_part, double *frac_part) {
}
</code></pre>

<h3 id="const-保护">const 保护</h3>

<pre><code class="language-c">void f(const int *p) {
}
</code></pre>

<p>表明函数不会改变指针参数所指向的对象</p>

<p>而</p>

<pre><code class="language-c">void f(int * const p) {
}
</code></pre>

<p>保护p本身</p>

<h2 id="指针作为返回值">指针作为返回值</h2>

<pre><code class="language-c">int *max(int *a, int *b) {
}
</code></pre>

<p>永远不要返回指向自动局部变量的指针</p>

<h2 id="打印指针">打印指针</h2>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int a = 100;
    int *p = &amp;a;
    printf(&quot;%p\n&quot;, p);
    return 0;
}
</code></pre>

<h1 id="指针和数组">指针和数组</h1>

<blockquote>
<p>用指针处理数组的主要原因是效率，但是这里的效率提升已经不再像当 初那么重要了，这主要归功于编译器的改进</p>
</blockquote>

<h2 id="指针的算术运算">指针的算术运算</h2>

<ul>
<li>指针加上整数 : 指针p加上整数j产生指向特定元素的指针，这个特定元素是p原先指向的元素后的j个位 置</li>
<li>指针减去整数 : 如果p指向数组元素a[i]，那么p - j指向a[i - j]</li>
<li>两个指针相减 : 当两个指针相减时，结果为指针之间的距离(用数组元素的个数来度量)。因此，如果p指 259 向a[i]且q指向a[j]，那么p-q就等于i-j</li>
</ul>

<h2 id="指针比较">指针比较</h2>

<p>可以用关系运算符(&lt;、&lt;=、&gt;和&gt;=)和判等运算符(==和!=)进行指针比较。只有在两个 指针指向同一数组时，用关系运算符进行的指针比较才有意义。比较的结果依赖于数组中两个 元素的相对位置</p>

<h2 id="指向复合常量的指针-c99">指向复合常量的指针(C99)</h2>

<pre><code class="language-c">int *p = (int []){3, 0, 3, 4, 1};
</code></pre>

<p>使用复合字面量可 以减少一些麻烦，我们不再需要先声明一个数组变量，然后用指针p指向数组的第一个元素</p>

<h2 id="指针用于数组处理">指针用于数组处理</h2>

<p>指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素</p>

<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>*p++或*(p++)</code></td>
<td>自增前表达式的值是<code>*p</code>，以后再自增p</td>
</tr>

<tr>
<td><code>(*p)++</code></td>
<td>自增前表达式的值是<code>*p</code>，以后再自增<code>*p</code></td>
</tr>

<tr>
<td><code>*++p或*(++p)</code></td>
<td>先自增p，自增后表达式的值是<code>*p</code></td>
</tr>

<tr>
<td><code>++*p或++(*p)</code></td>
<td>先自增<code>*p</code>，自增后表达式的值是<code>*p</code></td>
</tr>
</tbody>
</table>

<h2 id="用数组名作为指针">用数组名作为指针</h2>

<p>可以用数组的名字作为指向数组第一个元素的指针</p>

<h2 id="用指针作为数组名">用指针作为数组名</h2>

<p>可以把指针看作数组名进行取下标操作</p>

<h2 id="处理多维数组的元素">处理多维数组的元素</h2>

<p>如果使指针p指向二维数组中的第一个元素(即0行0 列的元素)，就可以通过重复自增p的方法访问数组中的每一个元素</p>

<h2 id="处理多维数组的行">处理多维数组的行</h2>

<pre><code class="language-c">p = &amp;a[i][0];
//简写为
p = a[i];
</code></pre>

<h2 id="处理多维数组的列">处理多维数组的列</h2>

<pre><code class="language-c">int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i;

for (p = &amp;a[0]; p &lt; &amp;a[NUM_ROWS]; p++)
	(*p)[i] = 0;
</code></pre>

<h2 id="用多维数组名作为指针">用多维数组名作为指针</h2>

<pre><code class="language-c">int a[NUM_ROWS][NUM_COLS];
</code></pre>

<p>这时, a不是指向<code>a[0][0]</code>的指针，而是指向<code>a[0]</code>的指针.</p>

<p>用作指针时， a的类型是<code>int (*)[NUM_COLS]</code>(指向长度为<code>NUM_COLS</code>的整型数组的指针)</p>

<h2 id="指针和变长数组-c99">指针和变长数组(C99)</h2>

<p>如果变长数组是多维的，指针的类型取决于除第一维外每一维的长度.</p>

<pre><code class="language-c">void f(int n) {
	int a[n], *p; 
  p = a;
	...
}

</code></pre>

<h1 id="字符串">字符串</h1>

<blockquote>
<p>空字符的整数值就是0</p>
</blockquote>

<h2 id="字符串字面量">字符串字面量</h2>

<p>用一对双引号括起来的字符序列</p>

<h3 id="延续字符串字面量">延续字符串字面量</h3>

<p>把第一行用字符<code>\</code>结尾，那么 C语言就允许在下一行延续字符串字面量.</p>

<blockquote>
<p>当两条或更多条字符串 字面量相邻时(仅用空白字符分割)，编译器会把它们合并成一条字符串</p>
</blockquote>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    printf(&quot;When you come to a fork in the road, take it. &quot; 
            &quot;--Yogi Berra&quot;);
    return 0;
}
</code></pre>

<h3 id="如何存储字符串字面量">如何存储字符串字面量</h3>

<p>从本质而言，C语言把字符串字面量作为字符数组来处理</p>

<p>当C语言编译器在程序中遇到长 度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。这块内存空间将用 来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符(空字符)。空字符是 一个所有位都为0的字节，因此用转义序列<code>\0</code>来表示</p>

<p>既然字符串字面量是作为数组来存储的，那么编译器会把它看作是<code>char *</code>类型的指针</p>

<h3 id="字符串字面量的操作">字符串字面量的操作</h3>

<p>对字符串字面量取下标</p>

<pre><code class="language-c">char ch;
ch = &quot;abc&quot;[1];
</code></pre>

<p><code>试图改变字符串字面量会导致未定义的行为</code></p>

<h3 id="字符串字面量与字符常量">字符串字面量与字符常量</h3>

<p>只包含一个字符的字符串字面量不同于字符常量。字符串字面量&rdquo;a&rdquo;是用指针来表示的， 这个指针指向存放字符&rdquo;a&rdquo;(后面紧跟空字符)的内存单元。字符常量&rsquo;a&rsquo;是用整数(字符集的 数值码)来表示的</p>

<h3 id="字符串字面量可以有多长">字符串字面量可以有多长</h3>

<p>按照C89标准，编译器必须最少支持<code>509</code>个字符长的字符串字面量。</p>

<p>C99把最小长度增加到了<code>4095</code>个字符</p>

<h3 id="为什么不把字符串字面量称为-字符串常量">为什么不把字符串字面量称为“字符串常量”</h3>

<p>因为它们并不一定是常量。由于字符串字面量是通过指针访问的，所以没有办法避免程序修改字符 串字面量中的字符,</p>

<h2 id="字符串变量">字符串变量</h2>

<p>当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度 多一个字符。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符 预留位置，可能会导致程序运行时出现不可预知的结果，因为C函数库中的函数假设 字符串都是以空字符结束的</p>

<h3 id="初始化字符串变量">初始化字符串变量</h3>

<pre><code class="language-c">char date1[8] = &quot;June 14&quot;;
</code></pre>

<p>字符串变量的声明中可以省略它的长度。这种情况下，编译器会自动计算长度</p>

<h2 id="字符数组与字符指针">字符数组与字符指针</h2>

<ul>
<li><p>在声明为数组时，就像任意数组元素一样，可以修改存储在数组中的字符.</p></li>

<li><p>在声明为指针时，date指向字符串字面量，而字符串字面量是不可以修改的.</p></li>

<li><p>在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序</p></li>
</ul>

<p>执行期间指向其他字符串</p>

<h2 id="字符串的读和写">字符串的读和写</h2>

<h3 id="用-printf-函数和-puts-函数写字符串">用 <strong>printf</strong> 函数和 <strong>puts</strong> 函数写字符串</h3>

<p>转换说明<code>%s</code>允许printf函数写字符串</p>

<blockquote>
<p>printf函数会逐个写字符串中的字符，直到遇到空字符才停止。(如果空字符丢失，printf函 数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。)</p>
</blockquote>

<p>如果只想显示字符串的一部分，可以使用转换说明<code>%.ps</code>，这里p是要显示的字符数量.</p>

<p>转换说明<code>%ms</code>会在大小为m的字段内显示字符串。 (对于超过m个字符的字符串，printf函数会显示出整个字符串，而不会截断。)如果字符串少 于m个字符，则会在字段内右对齐输出。如果要强制左对齐，可以在m前加一个减号。m值和p 值可以组合使用:转换说明<code>%m.ps</code>会使字符串的前p个字符在大小为m的字段内显示.</p>

<p>puts函数只有一个参数，即需要显示的字符串。在写完字符串后，puts函数总会添加一个额外</p>

<p>的换行符，从而前进到下一个输出行的开始处</p>

<h3 id="用-scanf-函数和-gets-函数读字符串">用 <strong>scanf</strong> 函数和 <strong>gets</strong> 函数读字符串</h3>

<p>scanf函数会跳过空白字符，然后读入字符并存储到str中，直到遇到空白字符为止。scanf函数始终会在字符串末尾存储一个空字符。用scanf函数读入字符串永远不会包含空白字符.</p>

<p>而 gets 函数则不太一样</p>

<ul>
<li><p>gets函数不会在开始读字符串之前跳过空白字符(scanf函数会跳过)</p></li>

<li><p>gets函数会持续读入直到找到换行符才停止(scanf函数会在任意空白字符处停止)。此</p></li>
</ul>

<p>外，gets函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符</p>

<blockquote>
<p>scanf函数和gets函数都无法检测数组何时被填满.</p>

<p>fgets函数相比则更安全</p>
</blockquote>

<h2 id="使用-c-语言的字符串库">使用 C 语言的字符串库</h2>

<pre><code class="language-c">#include &lt;string.h&gt;
</code></pre>

<h3 id="strcpy-函数"><strong>strcpy</strong>函数</h3>

<pre><code class="language-c">char *strcpy(char *s1, const char *s2);
</code></pre>

<p>也就是说，strcpy函数把s2中的字符复制到s1中直到遇到s2 中的第一个空字符为止(该空字符也需要复制). strcpy函数返回s1(即指向目标字符串的指 针)。这一过程不会改变s2指向的字符串，因此将其声明为const</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
   char str1[10], str2[10];
   strcpy(str2, &quot;abcd&quot;);
   printf(&quot;%s\n&quot;, str2);
    return 0;
}
</code></pre>

<p>尽管执行会慢一点，但是调用<code>strncpy</code>函数是一种更安全的复制字符串的方 法。<code>strncpy</code>类似于<code>strcpy</code>，但它还有第三个参数可以用于限制所复制的字符数.</p>

<p>更安全的用法:</p>

<pre><code class="language-c">strncpy(str1, str2, sizeof(str1) - 1); 
str1[sizeof(str1)-1] = '\0';
</code></pre>

<h3 id="strlen-函数"><strong>strlen</strong>函数</h3>

<p>strlen函数返回字符串s的长度:s中第一个空字符之前的字符个数(不包括空字符)</p>

<h3 id="strcat-函数"><strong>strcat</strong>函数</h3>

<pre><code class="language-c">char *strcat(char *s1, const char *s2);
</code></pre>

<p>strcat函数把字符串s2的内容追加到字符串s1的末尾，并且返回字符串s1(指向结果字符串的 指针)</p>

<blockquote>
<p>strncat函数比strcat更安全，但速度也慢一些</p>
</blockquote>

<h3 id="strcmp-函数"><strong>strcmp</strong>函数</h3>

<pre><code class="language-c">int strcmp(const char *s1, const char *s2)
</code></pre>

<p>strcmp函数比较字符串s1和字符串s2，然后根据s1是小于、等于或大于s2</p>

<p>strcmp函数利用字典顺序进行字符串比较</p>

<h2 id="字符串数组">字符串数组</h2>

<p>创建二维的字符数组，然后按照每行一个字符串的方式把字符串存储到数组中.</p>

<pre><code class="language-c">char planets[][8] = {&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
&quot;Uranus&quot;, &quot;Neptune&quot;, &quot;Pluto&quot;};
</code></pre>

<p><img src="/img/image-20200516234829449.png" alt="image-20200516234829449" /></p>

<p>但这容易导致空间浪费.  一种改进是使用参差不齐的数组(ragged array):</p>

<pre><code class="language-c">char *planets[] = {&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
&quot;Uranus&quot;, &quot;Neptune&quot;, &quot;Pluto&quot;};
</code></pre>

<p><img src="/img/image-20200516234842766.png" alt="image-20200516234842766" /></p>

<h2 id="命令行参数">命令行参数</h2>

<pre><code class="language-c">int main(int argc, char *argv[]) {
}
</code></pre>

<ul>
<li><code>argc</code>(“参数计数”)是命令行参数的数量(包括程序名本身)</li>
<li><code>argv</code>(“参数向量”)是指向命 令行参数的指针数组，这些命令行参数以字符串的形式存储</li>
</ul>

<p><code>argv[0]</code>指向程序名，而从<code>argv[1]</code> 到<code>argv[argc-1]</code>则指向余下的命令行参数</p>

<p>argv有一个附加元素，即<code>argv[argc]</code>，这个元素始终是一个空指针</p>

<h1 id="预处理器">预处理器</h1>

<h2 id="工作原理">工作原理</h2>

<p>预处理器的行为是由预处理指令(由<code>#</code>字符开头的一些命令)控制的</p>

<ul>
<li><code>#define</code> 指令定义了一个宏——用来代表其他东西的一个名字，例如常量或常用的表达式.预处理器会通过将宏的名字和它的定义存储在一起来响应<code>#define</code>指令。 C程序 当这个宏在后面的程序中使用到时，预处理器“扩展”宏，将宏替换为其定义值</li>
<li><code>#include</code>指令告诉预处理器打开一个特定的文件，将它的内容作为 正在编译的文件的一部分“包含”进来</li>
</ul>

<p>预处理器的输入是一个C 语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预 处理器的输出是另一个C程序:原程序编辑后的版本，不再包含指令.</p>

<blockquote>
<p>预处理器不仅仅是执行了指令，还做了一些其他的事情。特 别值得注意的是，它将每一处注释都替换为一个空格字符。有一些预处理器还会进一步删除不 必要的空白字符，包括每一行开始用于缩进的空格符和制表符</p>
</blockquote>

<p>要想查看预处理后的文件, 在 GCC 中可以使用 <code>-E</code> 选项. 例如</p>

<p>源文件<code>hello.c</code> 内容为</p>

<pre><code class="language-c">#define HELLO 10

int main(void) {
    printf(&quot;%d\n&quot;, HELLO);
    return 0;
}
</code></pre>

<p>通过 <code>gcc-9 -E hello.c</code> (注意 Mac 上gcc 默认的是 clang, 要想使用 GNU GCC , 则要指定名, 在我机器上是 <code>gcc-9</code></p>

<pre><code class="language-bash">$ gcc-all -E hello.c
# 1 &quot;hello.c&quot;
# 1 &quot;&lt;built-in&gt;&quot;
# 1 &quot;&lt;command-line&gt;&quot;
# 1 &quot;hello.c&quot;


int main(void) {
    printf(&quot;%d\n&quot;, 10);
    return 0;
}
</code></pre>

<h2 id="预处理指令">预处理指令</h2>

<ul>
<li>宏定义</li>
<li>文件包含</li>
<li>条件编译</li>
</ul>

<p>指令规则</p>

<ul>
<li>指令都以<strong>#</strong>开始</li>
<li>在指令的符号之间可以插入任意数量的空格或水平制表符</li>
<li>指令总是在第一个换行符处结束，除非明确地指明要延续. 如果想在下一行延续指令， 我们必须在当前行的末尾使用<code>\</code>字符</li>
<li>指令可以出现在程序中的任何地方</li>
<li>注释可以与指令放在同一行</li>
</ul>

<h3 id="宏定义">宏定义</h3>

<h4 id="简单的宏">简单的宏</h4>

<pre><code class="language-c">#define 标识符 替换列表
</code></pre>

<blockquote>
<p>宏定义中的替换列表为空是合法的</p>
</blockquote>

<h4 id="带参数的宏">带参数的宏</h4>

<pre><code class="language-c">#define 标识符(x1, x2,..., xn)	替换列表

//例如
#defineMAX(x,y) ((x)&gt;(y)?(x):(y))
</code></pre>

<blockquote>
<p>宏的名字和左括号之间必须没有空格</p>
</blockquote>

<p>使用带参数的宏替代真正的函数有两个优点</p>

<ol>
<li>程序可能会稍微快些。程序执行时调用函数通常会有些额外开销——存储上下文信息、</li>
</ol>

<p>复制参数的值等，而调用宏则没有这些运行开销。(注意，C99的内联函数为我们提供了一种不使用宏而避免这一开销的办法。)</p>

<ol>
<li>宏更“通用”。与函数的参数不同，宏的参数没有类型.</li>
</ol>

<p>缺点</p>

<ol>
<li>编译</li>
<li>后的代码通常会变大</li>
<li>宏参数没有类型检查</li>
<li>无法用一个指针来指向一个宏</li>
<li><code>宏可能会不止一次地计算它的参数</code> . 函数对它的参数只会计算一次，而宏可能会计算两 次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生不可预知的结果. <code>为了自我保护，最好避免使用带有副作用的参数</code></li>
</ol>

<h3 id="运算符"><code>#</code>运算符</h3>

<p>宏定义可以包含两个专用的运算符:<code>#</code>和<code>##</code>。编译器不会识别这两种运算符，它们会在预处 理时被执行</p>

<ul>
<li><code>#</code>运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中</li>
<li><code>##</code>运算符可以将两个记号(如标识符)“粘合”在一起，成为一个记号</li>
</ul>

<h3 id="宏的通用属性">宏的通用属性</h3>

<ul>
<li>宏的替换列表可以包含对其他宏的调用</li>
<li>预处理器只会替换完整的记号，而不会替换记号的片断</li>
<li>宏定义的作用范围通常到出现这个宏的文件末尾</li>
<li>宏不可以被定义两遍，除非新的定义与旧的定义是一样的</li>
<li>宏可以使用<code>#undef</code>指令“取消定义”</li>
</ul>

<h3 id="宏定义中的圆括号">宏定义中的圆括号</h3>

<ul>
<li>如果宏的替换列表中有运 算符，那么始终要将替换列表放在括号中</li>
<li>如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中</li>
</ul>

<h3 id="创建较长的宏">创建较长的宏</h3>

<pre><code class="language-c">#define ECHO(s) (gets(s), puts(s))
</code></pre>

<h3 id="预定义宏">预定义宏</h3>

<table>
<thead>
<tr>
<th>名</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>__LINE__</code></td>
<td>被编译的文件中的行号</td>
</tr>

<tr>
<td><code>__FILE__</code></td>
<td>被编译的文件名</td>
</tr>

<tr>
<td><code>__DATE__</code></td>
<td>编译的日期(格式&rdquo;mm dd yyyy&rdquo;)</td>
</tr>

<tr>
<td><code>__TIME__</code></td>
<td>编译的时间(格式&rdquo;hh:mm:ss&rdquo;)</td>
</tr>

<tr>
<td><code>__STDC__</code></td>
<td>如果编译器符合C标准(C89或C99)，那么值为1</td>
</tr>
</tbody>
</table>

<p>C99 中新增的预定义宏</p>

<table>
<thead>
<tr>
<th>名</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>__STDC_HOSTED__</code></td>
<td>如果是托管式实现，值为1;如果是独立式实现，值为0</td>
</tr>

<tr>
<td><code>__STDC_VERSION__</code></td>
<td>支持的C标准版本</td>
</tr>

<tr>
<td><code>__STDC_IEC_559__</code></td>
<td>如果支持IEC 60559浮点算术运算，则值为1</td>
</tr>

<tr>
<td><code>__STDC_IEC_559_COMPLEX__</code></td>
<td>如果支持IEC 60559复数算术运算，则值为1</td>
</tr>

<tr>
<td><code>__STDC_ISO_10646__</code></td>
<td>如果wchar_t的值与指定年月的ISO 10646标准相匹配，则值为yyyymmL</td>
</tr>
</tbody>
</table>

<ul>
<li>托管式实现(hosted implementation)能够接受任何符合C99标准的程序</li>
<li>独 立式实现(freestanding implementation)除了几个最基本的以外，不一定要能够编译使用复数 类型或标准头的程序</li>
</ul>

<h3 id="空的宏参数-c99">空的宏参数(C99)</h3>

<p>C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样多的逗 号(这样容易看出哪些参数被省略了)</p>

<h3 id="参数个数可变的宏-c99">参数个数可变的宏(C99)</h3>

<pre><code class="language-c">#define TEST(condition, ...) ((condition)? \ 
	printf(&quot;Passed test: %s\n&quot;, #condition): \ 
	printf(__VA_ARGS__))
</code></pre>

<p><code>__VA_ARGS__</code>是一个专用的标 识符，只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数</p>

<h3 id="func-标识符"><code>__func__</code>标识符</h3>

<p>每一个函数都可以访问<code>__func__</code>标识符，它的行为很像一个存储当前正在执行的函数的名 字的字符串变量。其作用相当于在函数体的一开始包含如下声明:</p>

<pre><code class="language-c">static const char __func__[] = &quot;function-name&quot;;
</code></pre>

<h2 id="条件编译">条件编译</h2>

<h3 id="if-和-endif">if 和 endif</h3>

<pre><code class="language-c">#define DEBUG 1

#if DEBUG
printf(&quot;Value of i: %d\n&quot;, i); printf(&quot;Value of j: %d\n&quot;, j); 
#endif
</code></pre>

<h4 id="defined-运算符"><strong>defined</strong>运算符</h4>

<p>当defined 应用于标识符时，如果标识符是一个定义过的宏则返回1，否则返回0</p>

<pre><code class="language-c">#if defined(DEBUG) 
...
#endif
</code></pre>

<h3 id="ifdef-指令和-ifndef-指令"><code>#ifdef</code> 指令和 <code>#ifndef</code> 指令</h3>

<pre><code class="language-c">#ifdef 标识符 
当标识符被定义为宏时需要包含的代码 
#endif
</code></pre>

<p><code>#ifdef 标识符</code> 等价于 <code>#if defined(标识符)</code></p>

<h3 id="elif-指令和-else-指令"><code>#elif</code>指令和<code>#else</code>指令</h3>

<pre><code class="language-c">#if 表达式1 
当表达式1非0时需要包含的代码
#elif 表达式2 
当表达式1为0但表达式2非0时需要包含的代码 
#else
其他情况下需要包含的代码
#endif
</code></pre>

<h2 id="其他指令">其他指令</h2>

<ul>
<li><code>#error 消息</code>  . 例如 <code>#error No operating system specified</code></li>
<li><code>#line n</code> : 改变程序行编号方式</li>
<li><code>#line n &quot;文件&quot;</code></li>
<li><code>#pragma 记号</code><br /></li>
<li><code>_Pragma (字符串字面量)</code> : C99. 遇到该表达式时，预处理器通过移除字符串两端的双引号并分别用字符&rdquo;和<code>\</code>代替转义序列<code>\&quot;</code>和<code>\\</code> 来实现对字符串字面量(C99标准中的术语)的“去字符串化”.  表达式的结果是一系列的记号， 这些记号被视为出现在pragma指令中.</li>
</ul>

<h1 id="编写大型程序">编写大型程序</h1>

<h2 id="源文件">源文件</h2>

<p>每个源文件包含程序的部分内容，主要是函数 和变量的定义。其中一个源文件必须包含一个名为main的函数，此函数作为程序的起始点</p>

<h2 id="头文件">头文件</h2>

<p><code>头文件的扩展名为.h</code></p>

<p>然后用 <code>#include</code> 指令包含进来</p>

<ul>
<li>共享宏定义和类型定义</li>
<li>共享变量声明. <code>extern int i</code> : extern告诉编译器，变量i是在程序中的其他位置定义的(很可能是在不同的源文件中)，因此 不需要为i分配空间</li>
<li>共享函数原型</li>
</ul>

<h3 id="保护头文件">保护头文件</h3>

<p>防多次处理</p>

<pre><code class="language-c">#ifndef BOOLEAN_H 
#define BOOLEAN_H
#define TRUE 1 
#define FALSE 0 
typedef int Bool;
#endif
</code></pre>

<h3 id="include-格式">include 格式</h3>

<p><code>#include &lt;文件名&gt;</code> :  搜寻系统头文件所在的目录(或多个目录)</p>

<p><code>#include &quot;文件名&quot;</code> : 先搜寻当前目录，然后搜寻系统头文件所在的目录(或多个目录)。 通常可以改变搜寻头文件的位置，这种改变经常利用诸如-I路径这样的命令行选项来实现.</p>

<p><code>#include 记号</code> :  预处理器会扫描这些记号，并替换遇到的宏。宏替换完成以 后，#include指令的格式一定与前面两种之一相匹配</p>

<h2 id="构建">构建</h2>

<pre><code class="language-bash">gcc –o justify justify.c line.c word.c
</code></pre>

<p>makefile</p>

<pre><code class="language-bash">justify: justify.o word.o line.o
	gcc -o justify justify.o word.o line.o
	
justify.o: justify.c word.h line.h 
	gcc -c justify.c
	
word.o: word.c word.h 
	gcc -c word.c
	
line.o: line.c line.h 
	gcc -c line.c
</code></pre>

<p>这里有4组代码行，每组称为一条规则。每条规则的第一行给出了目标文件，跟在后边的是它所 依赖的文件。第二行是待执行的命令</p>

<ul>
<li><p>makefile中的每个命令前面都必须有一个制表符，不是一串空格</p></li>

<li><p>makefile通常存储在一个名为Makefile(或makefile)的文件中。使用make实用程序时，</p></li>
</ul>

<p>它会自动在当前目录下搜索具有这些名字的文件</p>

<ul>
<li><p>用下面的命令调用make: <code>make 目标</code></p></li>

<li><p>如果在调用make时没有指定目标文件，将构建第一条规则中的目标文件</p></li>
</ul>

<h3 id="在程序外定义宏">在程序外定义宏</h3>

<p>大多数编译器(包括GCC)支持<code>-D</code>选项，此选项允许用命令行来指定宏的值: <code>gcc –DDEBUG=1 foo.c</code></p>

<h1 id="结构-联合和枚举">结构、联合和枚举</h1>

<h2 id="结构变量">结构变量</h2>

<pre><code class="language-c">struct {
	int number;
	char name[NAME_LEN+1]; 
  int on_hand;
} part1, part2;
</code></pre>

<blockquote>
<p>结构的成员在内存中是按照声明的顺序存储的. 成员之间没有间隙</p>
</blockquote>

<p>初始化</p>

<pre><code class="language-c">struct {
int number;
char name[NAME_LEN+1]; int on_hand;
} part1 = {528, &quot;Disk drive&quot;, 10}, 
part2 = {914, &quot;Printer cable&quot;, 5};
</code></pre>

<blockquote>
<p>C99 中, 初始化式中的成员数可以少于它所初始化的结构，就像数组那样，任何“剩余的” 成员都用0作为它的初始值。特别地，剩余的字符数组中的字节数为0，表示空字符串</p>
</blockquote>

<p>指定初始化(C99)</p>

<pre><code class="language-c">{.number = 528, .name = &quot;Disk drive&quot;, .on_hand = 10}
</code></pre>

<h3 id="对结构的操作">对结构的操作</h3>

<ul>
<li>访问结构内的成员，首先写出结构的名字，然后写一个句点，再写出成员的名字</li>
<li>结构的成员是左值. 所以它们可以出现在赋值运算的左侧，也可以作为自增或自 减表达式的操作数</li>

<li><p>结构赋值运算. 对结构进行复制时，嵌在结构内的数组也得到了复制.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
struct {
    int a;
    int b;
    int c[3];
} h1 = {10, 20, {1,2,3}}, h2;

printf(&quot;%p\n&quot;, h1.c);

h2 = h1;
printf(&quot;%p\n&quot;, h2.c);

return 0;
}
</code></pre></li>
</ul>

<blockquote>
<p>句点实际上就是一个C语言的运算符.</p>

<p>它 的运算优先级与后缀++和后缀&ndash;运算符一样，所以句点运算符的优先级几乎高于所有其他运算符</p>
</blockquote>

<h3 id="结构标记的声明">结构标记的声明</h3>

<pre><code class="language-c">struct part {
	int number;
	char name[NAME_LEN+1]; 
  int on_hand;
};
</code></pre>

<p>右花括号后的分号是必不可少的，它表示声明结束</p>

<blockquote>
<p>结构标记的声明可以和结构变量的声明合并在一起</p>
</blockquote>

<p>这样子要声明相应的变量的话, 可以用</p>

<pre><code class="language-c">struct part part1, part2;
</code></pre>

<h3 id="结构类型的定义">结构类型的定义</h3>

<pre><code class="language-c">typedef struct {
	int number;
	char name[NAME_LEN+1]; 
  int on_hand;
} Part;
</code></pre>

<p>这样子, 可以像内置类型那样使用Part.</p>

<pre><code class="language-c">Part part1, part2;
</code></pre>

<blockquote>
<p>结构用于链表时，强制使用声明结构标记</p>
</blockquote>

<h3 id="结构作为参数和返回值">结构作为参数和返回值</h3>

<p>给函数传递结构和从函数返回结构都要求生成结构中所有成员的副本。这样的结果是，这 些操作对程序强加了一定数量的系统开销，特别是结构很大的时候。为了避免这类系统开销， 有时用传递指向结构的指针来代替传递结构本身是很明智的做法</p>

<h3 id="复合字面量-c99">复合字面量(c99)</h3>

<pre><code class="language-c">(struct part) {528, &quot;Disk drive&quot;, 10}
</code></pre>

<p>一个复合 字面量可以包括指示符，就像指定初始化式一样:</p>

<pre><code class="language-c">print_part((struct part) {
  .on_hand = 10,
	.name = &quot;Disk drive&quot;,
	.number = 528});
</code></pre>

<h3 id="嵌套的结构">嵌套的结构</h3>

<pre><code class="language-c">struct person_name {
	char first[FIRST_NAME_LEN+1]; 
  char middle_initial;
	char last[LAST_NAME_LEN+1];
};

struct student {
	struct person_name name; 
  int id, age;
	char sex;
} student1, student2;
</code></pre>

<h3 id="结构数组">结构数组</h3>

<pre><code class="language-c">struct part inventory[100];
</code></pre>

<p>由于结构数组(以及包含数组的结构)很常见，因此C99的指定初始化式允许每一项 具有多个指示符.</p>

<p>假定我们想初始化inventory数组使其只包含一个零件，零件编号为528，现</p>

<p>货数量为10，名字暂时为空:</p>

<pre><code class="language-c">struct part inventory[100] = {
  [0].number = 528, 
  [0].on_hand = 10, 
  [0].name[0] = '\0'
};
</code></pre>

<h2 id="联合">联合</h2>

<p>像结构一样，联合(union)也是由一个或多个成员构成的，而且这些成员可能具有不同的 类型。但是，<code>编译器只为联合中最大的成员分配足够的内存空间</code>。联合的成员在这个空间内彼 此覆盖</p>

<p>联合的性质和结构的性质几乎一样，所以可以用声明结构标记和类型的方法来声明联合的 标记和类型。像结构一样，联合可以使用运算符=进行复制，也可以传递给函数，还可以由函数 返回</p>

<p>指定初始化式:</p>

<pre><code class="language-c">union { 
  int i;
	double d;
} u = {.d = 10.0};
</code></pre>

<blockquote>
<p>把值存储在联合的一个成员中，然后通 过另一个名字来访问该数据通常不太可取，因为给联合的一个成员赋值会导致其他成员的值不 确定。然而，C标准提到了一种特殊情况:联合的两个或多个成员是结构，而这些结构最初的 一个或多个成员是相匹配的。(这些成员的顺序应该相同，类型也要兼容，但名字可以不一样。) 如果当前某个结构有效，则其他结构中的匹配成员也有效</p>
</blockquote>

<h3 id="用联合来构造混合的数据结构">用联合来构造混合的数据结构</h3>

<pre><code class="language-c">typedef union { 
  int i;
	double d; 
} Number;

Number number_array[1000];

number_array[0].i = 5; 
number_array[1].d = 8.395;
</code></pre>

<h3 id="为联合添加-标记字段">为联合添加“标记字段”</h3>

<pre><code class="language-c">#define INT_KIND 0
#define DOUBLE_KIND 1

typedef struct {
  int kind;
  union{
		int i;
		double d; 
  } u;
} Number;
</code></pre>

<h2 id="枚举">枚举</h2>

<pre><code class="language-c">enum {CLUBS, DIAMONDS, HEARTS, SPADES} s1, s2;
</code></pre>

<h3 id="枚举标记和类型名">枚举标记和类型名</h3>

<p>标记</p>

<pre><code class="language-c">enum suit {CLUBS, DIAMONDS, HEARTS, SPADES};

//然后声明

enum suit s1, s2;
</code></pre>

<p>定义类型名</p>

<pre><code class="language-c">typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
Suit s1, s2;
</code></pre>

<h3 id="枚举作为整数">枚举作为整数</h3>

<p>在系统内部，C语言会把枚举变量和常量作为整数来处理。默认情况下，编译器会把整数 0, 1, 2,等等赋给特定枚举中的常量.</p>

<p>我们可以为枚举常量自由选择不同的值:</p>

<pre><code class="language-c">enum suit {CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4};
</code></pre>

<ul>
<li>枚举常量的值可以是任意整数，列出也可以不用按照特定的顺序.</li>
<li>两个或多个枚举常量具有相同的值甚至也是合法的</li>
<li>当没有为枚举常量指定值时，它的值比前一个常量的值大1</li>
</ul>

<p>枚举的值只不过是一些稀疏分布的整数，所以C语言允许把它们与普通整数进行混合</p>

<h3 id="用枚举声明-标记字段">用枚举声明“标记字段”</h3>

<pre><code class="language-c">typedef struct {
	enum {INT_KIND, DOUBLE_KIND} kind; 
  union {
		int i;
		double d; 
  } u;
} Number;
</code></pre>

<h3 id="例子">例子</h3>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

enum {INT_KIND, DOUBLE_KIND} kind;

int main(void) {
    kind = INT_KIND;
    printf(&quot;%d\n&quot;, kind);
    return 0;
}
</code></pre>

<h1 id="指针的高级应用">指针的高级应用</h1>

<h2 id="动态存储分配">动态存储分配</h2>

<h3 id="内存分配函数">内存分配函数</h3>

<p>在头文件 <code>&lt;stdlib.h&gt;</code> 中</p>

<ul>
<li><code>malloc</code>函数——分配内存块，但是不对内存块进行初始化。</li>

<li><p><code>calloc</code>函数——分配内存块，并且对内存块进行清零。</p></li>

<li><p><code>realloc</code>函数——调整先前分配的内存块大小</p></li>
</ul>

<blockquote>
<p>因为malloc函数不需要对分配的内存块进 行清零，所以它比calloc函数更高效</p>
</blockquote>

<p>这些函数会返 回<code>void *</code>类型的值。<code>void *</code>类型的值是“通用”指针，本质上它只是内存地址.</p>

<h3 id="空指针">空指针</h3>

<p>当调用内存分配函数时，总存在这样的可能性:找不到满足我们需要的足够大的内存块。 如果真的发生了这类问题，函数会返回空指针(null pointer)</p>

<p>空指针用名为<code>NULL</code>的宏来表示</p>

<pre><code class="language-c">p = malloc(10000); 
if (p == NULL) {
	/* allocation failed; take appropriate action */ 
}
</code></pre>

<p>名为 NULL 的宏在 6 个头文件都有定义</p>

<ul>
<li><code>&lt;locale.h&gt;</code></li>
<li><code>&lt;stddef.h&gt;</code></li>
<li><code>&lt;stdio.h&gt;</code></li>
<li><code>&lt;stdlib.h&gt;</code></li>
<li><code>&lt;string.h&gt;</code></li>
<li><code>&lt;time.h&gt;</code></li>
</ul>

<blockquote>
<p>C99的<code>&lt;wchar.h&gt;</code>也定义了NULL</p>
</blockquote>

<p>在C语言中，指针测试真假的方法和数的测试一样。所有非空指针都为真，而只有空指针为假. 所以可以如下这样子写</p>

<pre><code class="language-c">if (p == NULL) ...
// 可写为
if (!p) ...
  
if (p != NULL) ...
// 可写为
if (p) ...
</code></pre>

<h2 id="动态分配字符串">动态分配字符串</h2>

<pre><code class="language-c">// 这种分配内存是未初始化的
void *malloc(size_t size);
</code></pre>

<blockquote>
<p>通常情 况下，可以把<code>void*</code>类型值赋给任何指针类型的变量，反之亦然</p>
</blockquote>

<p>一旦使用 malloc 函数成功成功, 则指针可以当作数组名来使用.</p>

<h3 id="calloc-函数">calloc 函数</h3>

<pre><code class="language-c">//第一个参数是 N 个元素, 第二个参数是每个元素的大小
void *calloc(size_t nmemb, size_t size);
</code></pre>

<p>这个函数会将内存清 0</p>

<pre><code class="language-c">struct point { int x, y; } *p;
p = calloc(1, sizeof(struct point));
</code></pre>

<h3 id="realloc-函数">realloc 函数</h3>

<pre><code class="language-c">void *realloc(void *ptr, size_t size);
</code></pre>

<p>当调用<code>realloc</code>函数时，ptr必须指向先前通过<code>malloc</code>、<code>calloc</code>或<code>realloc</code>的调用获得的内存 块。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺寸.</p>

<p>规则</p>

<ul>
<li>当扩展内存块时，realloc 函数不会对添加进内存块的字节进行初始化</li>
<li>如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块
中的数据不会发生改变.</li>
<li>如果realloc函数被调用时以空指针作为第一个实际参数，那么它的行为就将像malloc
函数一样</li>
<li>如果realloc函数被调用时以0作为第二个实际参数，那么它会释放掉内存块</li>
</ul>

<blockquote>
<p>一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为 realloc函数可能会使内存块移动到了其他地方</p>
</blockquote>

<h2 id="释放存储空间">释放存储空间</h2>

<p>对程序而言，不可再访问到的内存块被称为是垃圾(garbage)。留有垃圾的程序存在内存 泄漏(memroy leak)现象</p>

<pre><code class="language-c">void free(void *ptr);
</code></pre>

<blockquote>
<p>free函数的实际参数必须是先前由内存分配函数返回的指针。(参数也可以是 空指针，此时free调用不起作用。)如果参数是指向其他对象(比如变量或数组元素) 的指针，可能会导致未定义的行为</p>
</blockquote>

<h3 id="悬空指针">悬空指针</h3>

<p>调用<code>free(p)</code>函数会释放p指向的内存块，但是不会改变p本身</p>

<p>悬空指针是很难发现的，因为几个指针可能指向相同的内存块。在释放内存块后，全部的 指针都悬空了</p>

<h2 id="链表">链表</h2>

<pre><code class="language-c">struct node {
	int value;   /* data stored in the node */
	struct node *next; /* pointer to the next node */
};

struct node *first = NULL;

// 创建新节点. 注意不是 new_node = malloc(sizeof(new_node)); , 这个是指针大小, 而不是数据大小
struct node *new_node;
new_node = malloc(sizeof(struct node));

//新节点赋值. 注意括号.
(*new_node).value = 10;

// 不过可以写成
new_node-&gt;value = 10;

</code></pre>

<blockquote>
<p>在结构有一个指向相同结构类型的指针成员时(就像node中那样)，要求使用结构标记.</p>
</blockquote>

<h3 id="运算符-1"><code>-&gt;</code>运算符</h3>

<p>运算符<code>-&gt;</code>是运算符<code>*</code>和运算符.的组合</p>

<h3 id="搜索链表">搜索链表</h3>

<pre><code class="language-c">for (p = first; p != NULL; p = p-&gt;next) {
}
</code></pre>

<h3 id="从链表中删除结点">从链表中删除结点</h3>

<pre><code class="language-c">struct node *delete_from_list(struct node *list, int n) {
    struct node *cur, *prev;
    for (cur = list, prev = NULL;
        cur != NULL &amp;&amp; cur-&gt;value != n; prev = cur, cur = cur-&gt;next)
        ;
    if (cur == NULL) 
        return list;

    if (prev == NULL) 
        list = list-&gt;next;
    else
        prev-&gt;next = cur-&gt;next;
    free (cur);
    return list; 
}
</code></pre>

<h2 id="指向指针的指针">指向指针的指针</h2>

<p>当函数的实际参数是指针变量时，有时候会希望函数能通过指针指向别处的方 式改变此变量。做这项工作就需要用到指向指针的指针</p>

<h2 id="指向函数的指针">指向函数的指针</h2>

<pre><code class="language-c">double integrate(double (*f)(double), double a, double b);

// 在函数体内调用
y = (*f)(x);


// 调用. 注意, sin 是没有 &amp; 的
result = integrate(sin, 0.0, PI / 2);
</code></pre>

<h2 id="qsort-函数"><strong>qsort</strong>函数</h2>

<pre><code class="language-c">void qsort(void *base, size_t nmemb, size_t size, int (*compar) (const void *, const void *));
</code></pre>

<p>base必须指向数组中的第一个元素。(如果只是对数组的一段区域进行排序，那么要使base指 向这段区域的第一个元素。)</p>

<p>在一般情况下，base就是数组的名字。nmemb是要排序元素的数量</p>

<p>(不一定是数组中元素的数量)。size是每个数组元素的大小，用字节来衡量。compar是指向比 较函数的指针。当调用函数qsort时，它会对数组进行升序排列，并且在任何需要比较数组元 素的时候调用比较函数</p>

<h2 id="受限指针c99">受限指针C99</h2>

<pre><code class="language-c">int * restrict p;
</code></pre>

<h2 id="灵活数组成员">灵活数组成员</h2>

<p>当结构的最后一个成员是数组时，其长度可以省略.</p>

<pre><code class="language-c">struct vstring {
	int len;
	char chars[]; /* flexible array member – C99 only */
};
</code></pre>

<p>灵活数组成员不同寻常之处在于，它在结构内并不占空间.</p>

<ul>
<li>灵活数组成员必须出现在结构的最后， 而且结构必须至少还有一个其他成员。</li>
<li>复制包含灵活数组成员的结构时，其他成员都会被复制 但不复制灵活数组本身</li>
</ul>

<p>具有灵活数组成员的结构是不完整类型(incomplete type)。不完整类型缺少用于确定所需内 存大小的信息.</p>

<p>特别是，不完整类型(包括含有灵活数组成员的结构)不能作为其他结构的成员和数组的元素， 但是数组可以包含指向具有灵活数组成员的结构的指针</p>

<h2 id="null-宏表示什么"><strong>NULL</strong>宏表示什么</h2>

<p>NULL实际表示0。当在要求指针的地方使用0时，C语言编译器会把它看成是空指针而不是整数0。提</p>

<p>供宏NULL只是为了避免混淆.</p>

<h1 id="声明-2">声明</h1>

<p>声明为编译器提供有关标识符含义的信息.</p>

<pre><code class="language-c">声明说明符 声明符;
//存储类型 [类型限定 类型说明] 或
//存储类型 [类型说明 类型限定]
</code></pre>

<ul>
<li>声明说明符(declaration specifier)描述声明的变量或函数的性质

<ul>
<li>存储类型. 4 种. 最多出现一种</li>
<li>auto</li>
<li>static</li>
<li>extern</li>
<li>register : register变量使用取地址运算符<code>&amp;</code>是非法的</li>
<li>类型限定符. 可零或多个</li>
<li>const (c89) : 只读变量.</li>
<li>volatile (c89)</li>
<li>restrict (c99)</li>
<li>类型说明符. 比如 short, int  , long 等</li>
<li>函数说明符: inline</li>
</ul></li>
<li>声明符

<ul>
<li><code>*</code> : 表示指针</li>
<li><code>[]</code> : 结尾表示数组</li>
<li><code>()</code> : 表示函数</li>
</ul></li>
</ul>

<h2 id="复杂声明的理解">复杂声明的理解</h2>

<ul>
<li>从内往外看(从标识符开始看)</li>
<li>作选择时, 始终使 <code>[]</code> 和 <code>()</code> 优先级高于 <code>*</code></li>
</ul>

<h2 id="函数的存储类型">函数的存储类型</h2>

<ul>
<li>extern : 允许其他文件调用此函数 (默认)</li>
<li>static : 只能在定义函数的文件内部调用此函数</li>
</ul>

<h2 id="初始化式">初始化式</h2>

<ul>
<li>具有静态存储期限的变量的初始化式必须是常量</li>
<li>如果变量具有自动存储期限，那么它的初始化式不需要是常量</li>
<li>包含在花括号中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量 或函数调用</li>
<li>自动类型的结构或联合的初始化式可以是另外一个结构或联合</li>
</ul>

<h3 id="未初始化的变量">未初始化的变量</h3>

<ul>
<li>具有自动存储期限的变量没有默认的初始值</li>
<li>具有静态存储期限的变量默认情况下的值为零. 用calloc分配的内存是简单的给字节的 位置零，而静态变量不同于此，它是基于类型的正确初始化，即整型变量初始化为0， 浮点变量初始化为0.0，而指针则初始化为空指针</li>
</ul>

<h2 id="内联函数">内联函数</h2>

<blockquote>
<p>调用函数和从函数返回所需的工作量称为“额外开销”，因为我们并没有要求函数执行这些工作</p>
</blockquote>

<p>在C89中，避免函数额外开销的唯一方式是使用带参数的宏.
C99提供了一种更好的解决方案:创建内联函数(inline function)。“内联”表明编 译器把函数的每一次调用都用函数的机器指令来代替。这种方法虽然会使被编译程序的大小增 加一些，但是可以避免函数调用的常见额外开销</p>

<p>不过，把函数声明为inline并不是强制编译器将代码内联编译，只是建议编译器应该使函 数调用尽可能地快，也许在函数调用时才执行内联展开</p>

<p>C99中的一般法则是，如果特定文件中某个函数的所有顶层声明中都有inline但没有 extern，则该函数定义在该文件中是内联的</p>

<h3 id="内联函数的限制">内联函数的限制</h3>

<ul>
<li>函数中不能定义可改变的static变量</li>
<li>函数中不能引用具有内部链接的变量</li>
</ul>

<p>GCC最后需要注意的是:仅当通过<code>-O</code>命令行选项请求进行优化时，才会对函数进行“内联”</p>

<h1 id="程序设计">程序设计</h1>

<h2 id="模块">模块</h2>

<p>它是一组服务的集合. 它被其他模块使用.
每个模块都有一个接口来描述所提供的服务.
模块的细节都包含在模块的实现中.</p>

<p>服务: 就是函数
接口: 就是头文件
实现: 就是函数定义的源文件</p>

<h3 id="内聚性与耦合性">内聚性与耦合性</h3>

<p>模块应该具有下面两个性质</p>

<ul>
<li>高内聚性</li>
<li>低耦合性</li>
</ul>

<h3 id="模块的类型">模块的类型</h3>

<ul>
<li>数据池 : 一些相关的变量或常量的集合. 这类模块通常只是一个头文件. 例如 <code>&lt;limits.h&gt;</code>, <code>&lt;float.h&gt;</code></li>
<li>库 : 是一个相关函数的集合. 例如 <code>&lt;string.h&gt;</code></li>
<li>抽象对象 : 对于隐藏的数据结构进行操作的函数的集合</li>
<li>抽象数据类型 ADT : 将具体数据实现方式隐藏起来的数据类型称为抽象数据类型</li>
</ul>

<h2 id="信息隐藏">信息隐藏</h2>

<ul>
<li>安全性</li>
<li>灵活性</li>
</ul>

<p>强制信息隐藏的主要工具是<code>static</code>存储类型。将具有文件作用域 的变量声明成<code>static</code>可以使其具有内部链接，从而避免它被其他文件(包括模块的客户)访问。
(将函数声明成<code>static</code>也是有用的——函数只能被同一文件中的其他函数直接调用。</p>

<h2 id="抽象数据类型">抽象数据类型</h2>

<h3 id="封装">封装</h3>

<p>C语言提供的唯一封装工具为不完整类型.
C标准对不完整类型的描述是:描述了对象但缺少定义对象大小所需的 信息</p>

<p>例如，声明 <code>struct t</code> . 不完整类型的使用是受限的</p>

<ul>
<li>因为编译器不知道不完整类型的大小，所以不能用它来 声明变量</li>
<li>但是完全可以定义一个指针类型引用不完整类型</li>
</ul>

<h1 id="底层程序设计">底层程序设计</h1>

<h2 id="位运算符">位运算符</h2>

<ul>
<li><code>&lt;&lt;</code> : 左移</li>
<li><code>&gt;&gt;</code> : 右移</li>
<li><code>~</code> : 按位取反</li>
<li><code>&amp;</code> : 按位与</li>
<li><code>^</code> : 按位异或. 与或类似, 但两个操作数的位都是1时结果为 0</li>
<li><code>|</code> : 按位或</li>
</ul>

<p>如果是无符号数或非负值，则需要在左端补0。如果是负值，其结果是由实现定义的:一些实现会在左端补0，其他一些实现会保留 符号位而补1</p>

<blockquote>
<p>为了可移植性，最好仅对无符号数进行移位运算</p>
</blockquote>

<h2 id="用位运算符访问位">用位运算符访问位</h2>

<ul>
<li>位的设置 : 用或运算. <code>i|=1&lt;&lt;j; /*setsbitj*/</code></li>
<li>位的清除 : 用与运算. <code>i &amp;= ~(1 &lt;&lt; j); /* clears bit j */</code></li>

<li><p>位的测试 : 用与运算. <code>if(i&amp;1&lt;&lt;j)... /*testsbitj*/</code></p>

<pre><code class="language-c">#define BLUE 1 
#define GREEN 2 
#define RED 4

i|=BLUE; /*setsBLUEbit */ 
i &amp;= ~BLUE; /* clears BLUE bit */ 
if (i &amp; BLUE)... /* tests BLUE bit */



i |= BLUE | GREEN; /* sets BLUE and GREEN bits */
i &amp;= ~(BLUE | GREEN);  /* clears BLUE and GREEN bits */
if (i &amp; (BLUE | GREEN)) ...  /* tests BLUE and GREEN bits */
</code></pre></li>
</ul>

<h2 id="用位运算符访问位域">用位运算符访问位域</h2>

<ul>
<li>修改位域 : <code>i = i &amp; ~0x0070 | 0x0050; /* stores 101 in bits 4-6 */</code></li>
<li>获取位域 : <code>j = i &amp; 0x0007; /* retrieves bits 0-2 */</code></li>
</ul>

<h2 id="结构中的位域">结构中的位域</h2>

<pre><code class="language-c">struct file_date { 
	unsigned int day: 5; 
	unsigned int month: 4; 
	unsigned int year: 7;
};
</code></pre>

<p>每个成员后面的数指定了它所占用位的长度</p>

<blockquote>
<p>可移植性技巧 将所有的位域声明为unsigned int或signed int
在C99中，位域也可以具有类型<code>_Bool</code>。C99编译器还允许额外的位域类型</p>
</blockquote>

<p>由于通常意义上讲位域没有地 址，C语言不允许将<code>&amp;</code>运算符用于位域.</p>

<h3 id="位域是如何存储的">位域是如何存储的</h3>

<p>当编译器处理结构的声明时，会将位域逐个放入存储单元，位域之间 没有间隙，直到剩下的空间不够用来放下一个位域了</p>

<p>C语言允许省略位域的名字。未命名的位域经常用来作为字段间的“填充”，以保证其他位 域存储在适当的位置</p>

<pre><code class="language-c">struct s { 
	unsigned int a: 4;
	unsigned int : 0;
	unsigned int b: 8;
};
</code></pre>

<p>长度为0的位域是给编译器的一个信号，告诉编译器将下一个位域在一个存储单元的起始位置对 齐。假设存储单元是8位长的，编译器会给成员a分配4位，接着跳过余下的4位到下一个存储单 元，然后给成员b分配8位。如果存储单元是16位，编译器会给a分配4位，接着跳过12位，然后 给成员b分配8位</p>

<h2 id="将指针作为地址使用">将指针作为地址使用</h2>

<p>地址所包含的位的个数与整数(或长整数)一致。构造一个指针来表示某个特定的地址是 十分方便的:只需要将整数强制转换成指针就行. 例如</p>

<pre><code class="language-c">BYTE *p;
p = (BYTE *) 0x1000; /* p contains address 0x1000 */
</code></pre>

<blockquote>
<p>x86处理器按小端方式存储数据</p>
</blockquote>

<h2 id="volatile类型限定符">volatile类型限定符</h2>

<p><code>volatile</code> 类型限定符使我们可以通知编译器，程序中的某些数据是“易变”的</p>

<p><code>volatile</code> 限定符会通知编译器每一次都必 须从内存中重新取</p>

<h1 id="标准库">标准库</h1>

<p>C89标准库总共划分成15个部分. C99新增了9个头，总共有24个.</p>

<ol>
<li><code>&lt;assert.h&gt;</code> : 仅包含assert宏，它允许我们在程序中插入自我检查。一旦任 何检查失败，程序会被终止</li>
<li><code>&lt;complex.h&gt;</code> C99. 定义了 <code>complex</code> 和 <code>I</code> 宏，这两个宏对于复数运算来说非常有用该头还提供了对复数进行数学运算的函数</li>
<li><code>&lt;ctype.h&gt;</code> : 提供用于字符分类及大小写转换的函数</li>
<li><code>&lt;errno.h&gt;</code> : errno是一个左值(lvalue)，可以在调用特定库函数后进行检测，来判断调用过程中是否有错误发生</li>
<li><code>&lt;fenv.h&gt;</code> C99. 提供了对浮点状态标志和控制模式的访问。例如，程序可以测试标志来判断浮点数运算过程中是否发生了溢出，或者设置控制模式来指定如何进行取整</li>
<li><code>&lt;float.h&gt;</code> : 提供了用于描述浮点类型特性的宏，包括值的范围及精度</li>
<li><code>&lt;iso646.h&gt;</code> C99. 定义了可代表特定运算符(包含字符<code>&amp;</code>、<code>|</code>、<code>~</code>、<code>!</code>和<code>^</code>的运算符)的宏。当编程环境的本地字符集没有这些字符时，这些宏非常有用</li>
<li><code>&lt;inttypes.h&gt;</code> C99.  定义了可用于 <code>&lt;stdint.h&gt;</code> 中声明的整数类型的输入/输出的格式化字符串的宏，还提供了处理最大宽度整数的函数</li>
<li><code>&lt;limits.h&gt;</code> : 提供了用于描述整数类型(包括字符类型)特性的宏，包括它们的最大值和最小值</li>
<li><code>&lt;locale.h&gt;</code> : 提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。这些与本地化相关的行为包括显示数的方式(如用作小数点的字符)、货币的格式(如货 币符号)、字符集以及日期和时间的表示形式</li>
<li><code>&lt;math.h&gt;</code> : 提供了常见的数学函数，包括三角函数、双曲函数、指数函数、对数函数、幂函数、邻近取整函数、绝对值运算函数以及取余函数</li>
<li><code>&lt;setjmp.h&gt;</code> : 提供了setjmp函数和longjmp函数。setjmp函数会“标记”程序中的一个位置，随后可以用longjmp返回被标记的位置。这些函数可以用来从一个函数跳转 到另一个(仍然活动中的)函数中，而绕过正常的函数返回机制。setjmp函数和longjmp函数 主要用来处理程序执行过程中出现的严重问题</li>
<li><code>&lt;signal.h&gt;</code> : 提供了用于处理异常情况(信号)的函数，包括中断和运行时错误。signal函数可以设置一个函数，使系统会在给定信号发生后自动调用该函数;raise函 数用来产生信号。</li>
<li><code>&lt;stdarg.h&gt;</code> : 提供了一些工具用于编写参数个数可变的函数，就像printf和scanf函数一样。</li>
<li><code>&lt;stdbool.h&gt;</code> C99. 定义了bool、true和false宏，同时还定义了一个可以用于测 试这些宏是否已被定义的宏。</li>
<li><code>&lt;stddef.h&gt;</code> : 提供了经常使用的类型和宏的定义</li>
<li><code>&lt;stdint.h&gt;</code> : C99. 声明了指定宽度的整数类型并定义了相关的宏(例如指定每种类型的最大和最小值的宏)。同时定义了用于构建具体类型的整数常量的带参数的宏</li>
<li><code>&lt;stdio.h&gt;</code> : 提供了大量的输入/输出函数，包括对顺序访问和随机访 问文件的操作</li>
<li><code>&lt;stdlib.h&gt;</code> : 包含了大量无法划归其他头的函数。包含在<code>&lt;stdlib.h&gt;</code>中的函数可以将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与 排序，以及在多字节字符与宽字符之间进行转换</li>
<li><code>&lt;string.h&gt;</code> : 提供了用于进行字符串操作(包括复制、拼接、比较及搜索)的函数以及对任意内存块进行操作的函数</li>
<li><code>&lt;tgmath.h&gt;</code> C99. 在C99中，<code>&lt;math.h&gt;</code>和<code>&lt;complex.h&gt;</code>头中的许多数学函数都有多个版本。<code>&lt;tgmath.h&gt;</code> 头中的泛型宏可以检测传递给它们的参数的类型，并替代为相应<code>&lt;math.h&gt;</code>或 <code>&lt;complex.h&gt;</code>中函数的调用</li>
<li><code>&lt;time.h&gt;</code> : 提供相应的函数来获取时间(和日期)，操纵时间，以及格式化时间的显示</li>
<li><code>&lt;wchar.h&gt;</code> : C99. 提供了宽字符输入/输出和宽字符串操作的函数。</li>
<li><code>&lt;wctype.h&gt;</code> : C99. 是<code>&lt;ctype.h&gt;</code>的宽字符版本，提供了对宽字符进行分类和修改的函数</li>
</ol>

<h2 id="对标准库中所用名字的限制">对标准库中所用名字的限制</h2>

<p>任何包含了标准头的文件都必须遵守两条规则</p>

<ul>
<li>该文件不能将头中定义过的宏的名 字用于其他目的</li>
<li>具有文件作用域的库名(尤其是typedef 名)也不可以在文件层次重定义</li>
</ul>

<p>其他的规则</p>

<ul>
<li>由一个下划线和一个大写字母开头或由两个下划线开头的标识符是为标准库保留的标识符。程序不允许为任何目的使用这种形式的标识符。</li>
<li>由一个下划线开头的标识符被保留用作具有文件作用域的标识符和标记</li>
<li>在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符。特别是所有标准库函数的名字都被保留</li>
</ul>

<h2 id="使用宏隐藏的函数">使用宏隐藏的函数</h2>

<p>C程序员经常会用带参数的宏来替代小的函数，这在标准库中同样很常见.</p>

<p>因此，对于 库的头，声明一个函数并同时定义一个有相同名字的宏的情况并不少见.</p>

<p>在大多数情况下，我们喜欢使用宏来替代实际的函数，因为这样可能会提高程序的运行速 度。然而在某些情况下，我们可能需要的是一个真实的函数，可能是为了尽量缩小可执行代码 的大小。</p>

<p>如果确实存在这种需求，我们可以使用<code>#undef</code>指令来删除宏定义</p>

<p>此外，我们也可以通过给名字加圆括号来禁用个别宏调用:</p>

<pre><code class="language-c">ch = (getchar)(); /* instead of ch = getchar(); */
</code></pre>

<h1 id="输入输出">输入输出</h1>

<p><code>&lt;stdio.h&gt;</code>中用于读或写数据的函数称 为字节输入/输出函数，
而<code>&lt;wchar.h&gt;</code>中的类似函数则称为宽字符输入/输出函数</p>

<h2 id="流">流</h2>

<p>在C语言中，术语流(stream)表示任意输入的源或任意输出的目的地.</p>

<p><code>&lt;stdio.h&gt;</code>中的许多函数可以处理各种形式的流，而不仅仅可以处理表示文件的流</p>

<h3 id="文件指针">文件指针</h3>

<p><code>FILE *</code></p>

<p><code>&lt;stdio.h&gt;</code> 提供了3个标准流</p>

<ul>
<li>stdin : 标准输入, 默认为键盘</li>
<li>stdout : 标准输出, 默认为屏幕</li>
<li>stderr : 标准错误, 默认为屏幕</li>
</ul>

<p>**重定向 **</p>

<ul>
<li>输入重定向: <code>demo &lt;in.dat</code></li>
<li>输出重定向: <code>demo &gt;out.dat</code></li>
</ul>

<p>字符<code>&lt;</code>和<code>&gt;</code>不需要与文件名相邻，重定向文件的顺序也是无关紧要的.</p>

<h3 id="文本文件与二进制文件">文本文件与二进制文件</h3>

<p>文本文件分为若干行.
文本文件可以包含一个特殊的“文件末尾”标记. 在Windows中，标记为 <code>\x1a</code> (Ctrl+Z)。Ctrl+Z不是必需的，但如果存在，它就标志着文件的结束，其后的所有字节都会被忽略. 大多数其他操作系统(包括UNIX)没有专门的文件末尾字符</p>

<p>二进制文件不分行，也没有行末标记和文件末尾标记，所有字节都是平等对待的.</p>

<h2 id="文件操作">文件操作</h2>

<h3 id="打开文件">打开文件</h3>

<pre><code class="language-c">FILE *fopen(const char * restrict filename, const char * restrict mode);
</code></pre>

<p><code>restrict</code> 是C99关键字，表明filename和mode所指向的字符串的内存单元不共享</p>

<blockquote>
<p>Windows会把/接受为目录分隔符</p>
</blockquote>

<p>当无法打开文件时，fopen函数会返回空指针。这可能是因为文件不存在，也可能是因为文件的位置不对，还可能是因为我们没有打开文件的权限</p>

<h4 id="模式">模式</h4>

<p>文本文件</p>

<ul>
<li><code>r</code> : 打开文件用于读</li>
<li><code>w</code> : 打开文件用于写(文件不需要存在)</li>
<li><code>a</code> : 打开文件用于追加(文件不需要存在)</li>
<li><code>r+</code> : 打开文件用于读和写，从文件头开始</li>
<li><code>w+</code> : 打开文件用于读和写(如果文件存在就截去)</li>
<li><code>a+</code> : 打开文件用于读和写(如果文件存在就追加)</li>
</ul>

<p>当使用fopen打开二进制文件时需要在模式字符串中包含字母b.</p>

<ul>
<li><code>rb</code> : 打开文件用于读</li>
<li><code>wb</code> : 打开文件用于写(文件不需要存在)</li>
<li><code>ab</code> : 打开文件用于追加(文件不需要存在)</li>
<li><code>r+b</code> : 打开文件用于读和写，从文件头开始</li>
<li><code>w+b</code> : 打开文件用于读和写(如果文件存在就截去)</li>
<li><code>a+b</code> : 打开文件用于读和写(如果文件存在就追加)</li>
</ul>

<h3 id="关闭文件">关闭文件</h3>

<pre><code class="language-c">int fclose(FILE *stream);
</code></pre>

<p>如果成功关闭了文件，fclose 函数会返回零;否则，它将会返回错误代码EOF(在<code>&lt;stdio.h&gt;</code>中定义的宏)</p>

<h3 id="为打开的流附加文件">为打开的流附加文件</h3>

<pre><code class="language-c">FILE *freopen(const char * restrict filename, const char * restrict mode, FILE * restrict stream);
</code></pre>

<p>freopen函数为已经打开的流附加上一个不同的文件。最常见的用法是把文件和一个标准 流(stdin、stdout或stderr)相关联
freopen函数的返回值通常是它的第三个参数(一个文件指针)</p>

<h3 id="从命令行获取文件名">从命令行获取文件名</h3>

<pre><code class="language-c">int main(int argc, char *argv[]) {

}
</code></pre>

<p><code>argv[0]</code>指向程序的名字</p>

<h3 id="临时文件">临时文件</h3>

<pre><code class="language-c">FILE *tmpfile(void); 
char *tmpnam(char *s);
</code></pre>

<p>tmpfile函数创建一个临时文件(用 <code>wb+</code> 模式打开)，该临时文件将一直存在，除非关闭 它或程序终止.</p>

<p>tmpnam函数为临时文件产生名字。如果它的实际参数是空指针，那么tmpnam函数会把文件 名存储到一个静态变量中，并且返回指向此变量的指针.</p>

<h3 id="文件缓冲">文件缓冲</h3>

<pre><code class="language-c">int fflush(FILE *stream);
void setbuf(FILE * restrict stream, char * restrict buf);
int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size);
</code></pre>

<p>通过调用fflush函数，程序可以按我们所希望的频率来清洗文件的缓冲区.</p>

<p><code>fflush(fp);</code> :  为和fp相关联的文件清洗了缓冲区</p>

<p><code>fflush(NULL);</code> :  清洗了全部输出流</p>

<p>如果调用成功，fflush函数会返回零;如果发生错误，则返回EOF</p>

<p><code>setvbuf</code>函数允许改变缓冲流的方法，并且允许控制缓冲区的大小和位置。函数的第三个 实际参数指明了期望的缓冲类型，该参数应为以下三个宏之一</p>

<ul>
<li><code>_IOFBF</code>(满缓冲)。当缓冲区为空时，从流读入数据;当缓冲区满时，向流写入数据</li>
<li><code>_IOLBF</code>(行缓冲)。每次从流读入一行数据或者向流写入一行数据</li>
<li><code>_IONBF</code>(无缓冲)。直接从流读入数据或者直接向流写入数据，而没有缓冲区</li>
</ul>

<p><code>setvbuf</code>函数的第二个参数(如果它不是空指针的话)是期望缓冲区的地址。缓冲区可以 有静态存储期限、自动存储期限，甚至可以是动态分配的.</p>

<blockquote>
<p>用空指针作为第二个参数来调用setvbuf也是合法的，这样做就要求setvbuf创建一个指定 大小的缓冲区。如果调用成功，setvbuf函数返回零。如果mode参数无效或者要求无法满足， 那么setvbuf函数会返回非零值</p>
</blockquote>

<p><code>setvbuf</code>函数 的最后一个参数是缓冲区内字节的数量。较大的缓冲区可以提供更好的性能，而较小的缓冲区 可以节省空间</p>

<p><code>setbuf</code>函数是一个较早期的函数，它设定了缓冲模式和缓冲区大小的默认值。如果buf是 空指针，那么<code>setbuf(stream, buf)</code>调用就等价于</p>

<pre><code class="language-c">(void) setvbuf(stream, NULL, _IONBF, 0);
</code></pre>

<p>否则的话，它就等价于</p>

<pre><code class="language-c">(void) setvbuf(stream, buf, _IOFBF, BUFSIZ);
</code></pre>

<h3 id="其他文件操作">其他文件操作</h3>

<pre><code class="language-c">int remove(const char *filename);
int rename(const char *old, const char *new);
</code></pre>

<p>如果调用成功，这两个函数 都返回零;否则，都返回非零值</p>

<h2 id="格式化的输入-输出">格式化的输入/输出</h2>

<h3 id="printf-函数-1"><code>...printf</code>  函数</h3>

<pre><code class="language-c">int fprintf(FILE * restrict stream, const char * restrict format, ...); 
int printf(const char * restrict format, ...);
</code></pre>

<p>返回值是写入的字符数，若出错则返回一个负值</p>

<p><code>fprintf</code>函数和<code>printf</code>函数唯一的不同就是<code>printf</code>函数始终向<code>stdout</code>(标准输出流)写入 内容，而<code>fprintf</code>函数则向它自己的第一个实际参数指定的流中写入内容</p>

<h3 id="scanf-函数-1"><code>...scanf</code> 函数</h3>

<pre><code class="language-c">int fscanf(FILE * restrict stream, const char * restrict format, ...); 
int scanf(const char * restrict format, ...);
</code></pre>

<p>返回读入并且赋值给对象的数据项的数量. 如果在读取任何数据项之前发生输入失败，那么 会返回EOF</p>

<h3 id="检测文件末尾和错误条件">检测文件末尾和错误条件</h3>

<pre><code class="language-c">int feof(FILE *stream); 
int ferror(FILE *stream);
</code></pre>

<p>如果为与fp相关的流设置了文件末尾指示器，那么<code>feof(fp)</code>函数调用就会返 回非零值</p>

<p>如果设置了错误指示器，那么<code>ferror(fp)</code>函数的调用也会返回非零值。</p>

<p>而其他情况 下，这两个函数都会返回零</p>

<h2 id="字符的输入-输出">字符的输入/输出</h2>

<h3 id="输出">输出</h3>

<pre><code class="language-c">int fputc(int c, FILE *stream); 
int putc(int c, FILE *stream); 
int putchar(int c);
</code></pre>

<p>putchar函数向标准输出流stdout写一个字符.</p>

<p>虽然putc函数和fputc函数做的工作相同，但是<code>putc</code>通常作为<code>宏</code>来实现(也有函数实现)， 而<code>fputc</code>函数则只作为<code>函数</code>实现。<code>putchar</code>本身通常也定义为<code>宏</code>.</p>

<blockquote>
<p>始终要把fgetc、getc或getchar函数的返回值存储在int型的变量中，而不是 char类型的变量中</p>
</blockquote>

<h3 id="输入">输入</h3>

<pre><code class="language-c">int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
</code></pre>

<ul>
<li><code>getchar</code> 函数从标准输入流stdin中读入一个字符</li>
<li><code>fgetc</code>函数和<code>getc</code>函数从任意流中读入一个字符</li>
</ul>

<p>getc和fgetc之间的关系类似于putc和fputc之间的关系。<code>getc</code>通常作为宏来实现(也有 函数实现)，而<code>fgetc</code>则只作为函数实现。<code>getchar</code>本身通常也定义为宏</p>

<p><code>ungetc</code> 函数。此函数把从流中读入的字符“放回”并清除 流的文件末尾指示器.</p>

<h2 id="行的输入-输出">行的输入/输出</h2>

<h3 id="输出-1">输出</h3>

<pre><code class="language-c">int fputs(const char * restrict s, FILE * restrict stream); 
int puts(const char *s);
</code></pre>

<ul>
<li><code>puts</code>函数总会添加一个换行符.</li>
<li><code>fputs</code>函数不会自己写入换行符，除非字符串中本身含有换行符</li>
</ul>

<p>当出现写错误时，上面这两种函数都会返回EOF。否则，它们都会返回一个非负的数</p>

<h3 id="输入-1">输入</h3>

<pre><code class="language-c">char *fgets(char * restrict s, int n, FILE * restrict stream); 
char *gets(char *s)
</code></pre>

<ul>
<li><code>gets</code>函数逐个读取字符，并且把它们存储在str所指向的数组中，直到它读到换行符时停止(丢 弃换行符</li>
<li><code>fgets</code>函数是gets函数的更通用版本，它可以从任意流中读取信息。fgets函数也比gets 函数更安全，因为它会限制将要存储的字符的数量. fgets函数逐个读入字符，直到遇到首个换行符时或者已经读入了 sizeof(str)-1个字符时结束操作. 如果fgets函数读入了换 行符，那么它会把换行符和其他字符一起存储.</li>
</ul>

<h2 id="块的输入-输出">块的输入/输出</h2>

<pre><code class="language-c">size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream); 

size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream);
</code></pre>

<p>可以用于文本流，但是它们主要还是用于二进制的流.</p>

<h2 id="文件定位">文件定位</h2>

<p>顺便提一句，文件定位函数最适合用于二进制流</p>

<pre><code class="language-c">int fgetpos(FILE * restrict stream, fpos_t * restrict pos); 
int fseek(FILE *stream, long int offset, int whence);
int fsetpos(FILE *stream, const fpos_t *pos);
long int ftell(FILE *stream);
void rewind(FILE *stream);
</code></pre>

<p>fseek函数改变与第一个参数(即文件指针)相关的文件位置.  第三个参数说明新位置是根据文件的起始处、当前位置还是文件末尾来计算.</p>

<ul>
<li><code>SEEK_SET</code> :  文件的起始处</li>
<li><code>SEEK_CUR</code> : 文件当前处</li>
<li><code>SEEK_END</code> : 文件末尾处</li>
</ul>

<p>第二个参数是个(可能为负的)字节计数.
通常情况下，fseek函数返回零。如果产生错误(例如，要求的位置不存在)，那么fseek 函数就会返回非零值。</p>

<p>ftell 函数以长整数返回当前文件位置.</p>

<p>rewind 函数会把文件位置设置在起始处.</p>

<p>为了用于非常大的文件，C语言提供了另外两个函数:<code>fgetpos函数</code>和<code>fsetpos函数</code>。 这两个函数可以用于处理大型文件，因为它们用<code>fpos_t</code>类型的值来表示文件位置</p>

<h2 id="字符串的输入-输出">字符串的输入/输出</h2>

<h3 id="输出-2">输出</h3>

<pre><code class="language-c">int sprintf(char * restrict s, const char * restrict format, ...);
int snprintf(char *restrict s, size_t n, const char * restrict format, ...);
</code></pre>

<p>sprintf函数类似于printf函数和fprintf函数，唯一的不同就是sprintf函数把输出写 入(第一个实参指向的)字符数组而不是流中。sprintf函数的第二个参数是格式串，这与printf 函数和fprintf函数所用的一样</p>

<p>snprintf函数与sprintf一样，但多了一个参数n。写入字符串的字符不会超过n1，结尾 的空字符不算;只要n不是零，都会有空字符。(我们也可以这样说:snprintf最多向字符串中 写入n个字符，最后一个是空字符。)</p>

<h3 id="输入-2">输入</h3>

<pre><code class="language-c">int sscanf(const char * restrict s, const char * restrict format, ... );
</code></pre>

<h1 id="库对数值和字符数据的支持">库对数值和字符数据的支持</h1>

<p>就近取整函数</p>

<p>ceil“向上舍入”到最近的整数</p>

<p>floor“向下舍入”到最近的整数</p>

<p>查看</p>

<ul>
<li><code>&lt;float.h&gt;</code></li>
<li><code>&lt;limits.h&gt;</code></li>
<li><code>&lt;math.h&gt;</code></li>
<li><code>&lt;ctype.h&gt;</code></li>
<li><code>&lt;string.h&gt;</code></li>
</ul>

<h1 id="错误处理">错误处理</h1>

<h2 id="诊断">诊断</h2>

<pre><code class="language-c">void assert(scalar expression);
</code></pre>

<p>如果参数的值不为0，<code>assert</code>什么也不做;如果参数的值为0，assert 会向stderr(标准错误流)写一条消息，并调用<code>abort</code>函数终止程序执行</p>

<blockquote>
<p>C89标准指出，assert的参数必须是int类型的。C99 放宽了要求，允许参数为任意标量类型</p>
</blockquote>

<p>禁止 assert, 只需要在包含<code>&lt;assert.h&gt;</code>之前定义宏<code>NDEBUG</code>即可:</p>

<pre><code class="language-c">#define NDEBUG 
#include &lt;assert.h&gt;
</code></pre>

<h2 id="错误">错误</h2>

<p><code>&lt;errno.h&gt;</code></p>

<p>标准库中的一些函数通过向<code>&lt;errno.h&gt;</code>中声明的<code>int</code>类型<code>errno</code>变量存储一个错误码(正整 数)来表示有错误发生</p>

<p><code>perror函数</code>(在<code>&lt;stdio.h&gt;</code>中声明) : <code>perror</code>函数会输出到<code>stderr</code>流而不是标准输出</p>

<p><code>strerror函数</code>属于<code>&lt;string.h&gt;</code>。当以错误码为参数调用<code>strerror</code>时，函数会返回一个指 针，它指向一个描述这个错误的字符串</p>

<h2 id="信号处理">信号处理</h2>

<p><code>&lt;signal.h&gt;</code> 提供了两个函数:<code>raise</code>和<code>signal</code></p>

<h3 id="signal-函数">signal 函数</h3>

<p>signal函数，它会安装 一个信号处理函数，以便将来给定的信号发生时使用. 每个信号处理函数都必须有一个int类型的参数，且返回类型为void</p>

<p>预定义的信号处理函数(都用宏表示)</p>

<ul>
<li><code>SIG_DFL</code> : 按“默认”方式处理信号</li>
<li><code>SIG_IGN</code> :  忽略该信号 <code>signal(SIGINT, SIG_IGN);</code></li>
</ul>

<p>如果一个signal调用失败(即不能对所指 定的信号安装处理函数)，就会返回<code>SIG_ERR</code>并在<code>errno</code>中存入一个正值</p>

<h3 id="raise-函数">raise 函数</h3>

<p>raise函数.</p>

<pre><code class="language-c">int raise(int sig);
</code></pre>

<p>返回0代表成功，非0则代表失败</p>

<h2 id="非局部跳转">非局部跳转</h2>

<pre><code class="language-c">int setjmp(jmp_buf env);

void longjmp(jmp_buf env, int val);
</code></pre>

<p>setjmp宏“标记”程序中 的一个位置;随后可以使用longjmp跳转到该位置。虽然这一强大的机制可以有多种潜在的用 途，但它主要被用于错误处理</p>

<p>总而言之，setjmp会在第一次调用时返回0;随后，longjmp将控制权重新转给最初的 setjmp宏调用，而setjmp在这次调用时会返回一个非零值.</p>

<h1 id="国际化特性">国际化特性</h1>

<h2 id="本地化">本地化</h2>

<p><code>&lt;locale.h&gt;</code></p>

<h3 id="类别">类别</h3>

<p>通过不同的宏来指定类别</p>

<ul>
<li><code>LC_COLLATE</code> : 影响两个字符串比较函数的行为</li>
<li><code>LC_CTYPE</code> : 影响<code>&lt;ctype.h&gt;</code>中的函数(<code>isdigit</code>和<code>isxdigit</code>除外)的行为</li>
<li><code>LC_MONETARY</code> : 影响由<code>localeconv</code>函数返回的货币格式信息</li>
<li><code>LC_NUMERIC</code> :  影响格式化输入/输出函数(如printf和scanf)使用的小数点字符以及 <code>&lt;stdlib.h&gt;</code> 中的数值转换函数</li>
<li><code>LC_TIME</code> : 影响strftime函数(在<code>&lt;time.h&gt;</code>中声明)的行为，该函数将时间转换成字符串</li>
<li><code>LC_ALL</code> : 所有类别</li>
</ul>

<p>设置: 第一个参数是以上类别之一</p>

<pre><code class="language-c">char *setlocale(int category, const char *locale);
</code></pre>

<blockquote>
<p>C标 准对第二个参数仅定义了两种可能值:&ldquo;C&rdquo;和&rdquo;&ldquo;。如果有其他地区，由具体的实现自行处理</p>
</blockquote>

<p>GNU的C库(称为 glibc)提供了&rdquo;POSIX&rdquo;地区，该地区与&rdquo; &ldquo;一样。glibc用于Linux，允许在需要的时候增加额 外的地区. 地区格式为</p>

<pre><code class="language-bash">语言[_地域][.码集][@修饰符]
</code></pre>

<ul>
<li>语言的可能值列在<code>ISO 639</code>标准中</li>
<li>地域”来自另一个标准 (<code>ISO 3166</code>)</li>
</ul>

<h3 id="localeenv-函数">localeenv 函数</h3>

<pre><code class="language-c">struct lconv *localeconv(void);
</code></pre>

<p>关于当前地区的很具体的信息.</p>

<blockquote>
<p>请记住C语言的库函数不能自动格式化货币量，需要由程序员使用lconv结构中的信息来完 成格式化</p>
</blockquote>

<h2 id="多字节字符和宽字符">多字节字符和宽字符</h2>

<h3 id="多字节字符">多字节字符</h3>

<p>在多字节字符编码中，用一个或多个字节表示一个扩展字符。根据字符的不同，字节的数 量可能发生变化。C语言要求任何扩展字符集必须包含特定的基本字符(即字母、数字、运算 符、标点符号和空白字符)。这些字符都必须是单字节的。其他字节可以解释为多字节字符的 开始</p>

<h3 id="宽字符">宽字符</h3>

<p>另外一种对扩展字符集进行编码的方法是使用宽字符(wide character)。宽字符是一种整数，其值代表字符。不同于长度可变的多字节字符，特定实现中所支持的所有宽字符有着相 同的字节数。宽字符串是指由宽字符组成的字符串，其末尾有一个空的宽字符(数值为零的 宽字符)</p>

<p>宽字符具有<code>wchar_t</code>类型(在<code>&lt;stddef.h&gt;</code>和其他一些头中声明)</p>

<h3 id="统一码和通用字符集">统一码和通用字符集</h3>

<p>统一码为每一个字符分配一个唯一的数(称为码点). 可以有多种方式使用字节来表示这些 码点。我将介绍两种简单的方法，其中一种使用宽字符，另一种使用多字节字符.</p>

<p><code>UCS-2</code>是一种宽字符编码方案，它把每一个统一码码点存储为两个字节.</p>

<p><code>UTF-8</code>，该方案使用多字节字符. UTF-8的一个有用的性质就是ASCII的字符在UTF-8中保持 不变:每个字符都是一个字节且使用同样的二进制编码. 它的性质有</p>

<ul>
<li>128个ASCII字符中的每一个字符都可以用一个字节表示。仅由ASCII字符组成的字符串在UTF-8中保持不变</li>
<li>对于UTF-8字符串中的任意字节，如果其最左边的位是0，那么它一定是ASCII字符，因为其他所有字节都以1开始</li>
<li>多字节字符的第一个字节指明了该字符的长度。如果字节开头1的个数为2，那么这个字符的长度为2个字节。如果字节开头1的个数为3或4，那么这个字符的长度分别为3个字节或4个字节</li>
<li>在多字节序列中，每隔一个字节就以10作为最左边的位</li>
</ul>

<h3 id="多字节-宽字符转换函数">多字节/宽字符转换函数</h3>

<p>来自<code>&lt;stdlib.h&gt;</code></p>

<pre><code class="language-c">int mblen(const char *s, size_t n);
int mbtowc(wchar_t * restrict pwc, const char * restrict s, size_t n);
int wctomb(char *s, wchar_t wc);
</code></pre>

<ul>
<li>mblen函数检测第一个参数是否指向形成有效多字节字符的字节序列</li>
<li>mbtowc函数把(第二个参数指向的)多字节字符转换为宽字符。第一个参数指向函数用于 存储结果的wchar_t类型变量，第三个参数限制了mbtowc函数将检测的字节的数量</li>
<li>wctomb函数把宽字符(第二个参数)转换为多字节字符，并把该多字节字符存储到第一个参数指向的数组中</li>
</ul>

<h3 id="多字节-宽字符串转换函数">多字节/宽字符串转换函数</h3>

<pre><code class="language-c">size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
size_t wcstombs(char * restrict s, const wchar_t * restrict pwcs, size_t n);
</code></pre>

<ul>
<li>mbstowcs函数把多字节字符序列转换为宽字符</li>
<li>wcstombs函数和mbstowcs函数正好相反:它把宽字符序列转换为多字节字符</li>
</ul>

<h2 id="拼写替换">拼写替换</h2>

<p><code>&lt;iso646.h&gt;</code>头相当简单。它只定义了11个宏，除此之外什么都没有.</p>

<table>
<thead>
<tr>
<th>宏</th>
<th>值</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>and</code></td>
<td><code>&amp;&amp;</code></td>
</tr>

<tr>
<td><code>and_eq</code></td>
<td><code>&amp;=</code></td>
</tr>

<tr>
<td><code>bitand</code></td>
<td><code>&amp;</code></td>
</tr>

<tr>
<td><code>bitor</code></td>
<td>`</td>
</tr>

<tr>
<td><code>compl</code></td>
<td><code>~</code></td>
</tr>

<tr>
<td><code>not</code></td>
<td><code>!</code></td>
</tr>

<tr>
<td><code>not_eq</code></td>
<td><code>!=</code></td>
</tr>

<tr>
<td><code>or</code></td>
<td>`</td>
</tr>

<tr>
<td><code>or_eq</code></td>
<td>`</td>
</tr>

<tr>
<td><code>xor</code></td>
<td><code>^</code></td>
</tr>

<tr>
<td><code>xor_eq</code></td>
<td><code>^=</code></td>
</tr>
</tbody>
</table>

<h2 id="通用字符名">通用字符名</h2>

<p>通用字符名类似于转义序列。但是，普通的转义序列只能出现于字符常量和字符串字面量 中，而通用字符名还可以用于标识符。这个特性允许程序员在为变量、函数等命名时使用他们 的本国语言</p>

<p>可以用两种方式书写通用字符名(<code>\udddd</code> 和 <code>\Udddddddd</code>)，每个d都是一个十六进制的数字。 在格式<code>\Udddddddd</code>中，8个d组成一个8位的十六进制数用于标识目标字符的UCS码点。格式 <code>\udddd</code>可以用于码点的十六进制值为FFFF或更小的字符，包括基本多语种平面上的所有字符.</p>

<p>UCS码点的值可以 在 www.unicode.org/charts/ 找到</p>

<h2 id="扩展的多字节和宽字符实用工具">扩展的多字节和宽字符实用工具</h2>

<p><code>&lt;wchar.h&gt;</code> 头提供了宽字符输入/输出和宽字符串处理的函数.</p>

<p>注意，<code>&lt;wchar.h&gt;</code>为宽字符提供了函数但没有为多字节字符提供函数。这是因为C的普通 库函数能够处理多字节字符，所以不需要专门的函数.</p>

<h3 id="流倾向">流倾向</h3>

<p>每个流要么是面向字节的(传统方式)，要么是面向宽字符的(把数据当成宽字符写入流 中). 第一次打开流时，它没有倾向。</p>

<p>使用字节输入/输出函数在流上执行操作会使流成为面向 字节的，使用宽字符输入/输出函数执行操作会使流成为面向宽字符的。流的倾向可以调用fwide 函数进行选择。流只要保持打开状态，就能保持其倾向。调用freopen函数重新打开流会删除其倾向.</p>

<h2 id="宽字符分类和映射实用工具">宽字符分类和映射实用工具</h2>

<p><code>&lt;wctype.h&gt;</code>头是<code>&lt;ctype.h&gt;</code>头的宽字符版本</p>

<h1 id="其他库函数">其他库函数</h1>

<h2 id="可变参数">可变参数</h2>

<p><code>&lt;stdarg.h&gt;</code></p>

<pre><code class="language-c">类型 va_arg(va_list ap, 类型);

void va_copy(va_list dest, va_list src); 
void va_end(va_list ap);
void va_start(va_list ap, parmN);
</code></pre>

<h2 id="通用的实用工具">通用的实用工具</h2>

<p><code>&lt;stdlib.h&gt;</code></p>

<ul>
<li>数值转换函数;</li>
<li>伪随机序列生成函数;</li>
<li>内存管理函数;</li>
<li>与外部环境的通信;</li>
<li>搜索和排序工具;</li>
<li>整数算术运算函数;</li>
<li>多字节/宽字符转换函数;</li>
<li>多字节/宽字符串转换函数</li>
</ul>

<h2 id="日期和时间">日期和时间</h2>

<p><code>&lt;time.h&gt;</code></p>

<p>它提供了三种存储类型</p>

<ul>
<li><code>clock_t</code>:按照“时钟嘀嗒”进行度量的时间值</li>
<li><code>time_t</code> :紧凑的时间和日期编码(日历时间)</li>
<li><code>struct tm</code>:把时间分解成秒、分、时等</li>
</ul>

<h1 id="c99-对数学计算的新增支持">C99 对数学计算的新增支持</h1>

<p><code>&lt;stdint.h&gt;</code> 中声明的类型可分为以下5组</p>

<ul>
<li>精确宽度整数类型. <code>intN_t</code></li>
<li>最小宽度整数类型. <code>int_leastN_t</code></li>
<li>最快的最小宽度整数类型. <code>int_fastN_t</code></li>
<li>可以保存对象指针的整数类型. <code>intptr_t</code></li>
<li>最大宽度整数类型. <code>intmax_t</code> , <code>uintmax_t</code></li>
</ul>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2020-05-15</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/c/">c</a>
          
          <a href="/tags/book/">book</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2020/05/22/jdk9%E5%8F%8A%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%9F%E4%B8%80gc%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JDK9及之后的统一GC日志格式</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2020/05/06/strace%E4%BD%BF%E7%94%A8/">
            <span class="next-text nav-default">Strace使用</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2020-05-15 14:38:31 \x2b0800 CST',
    title: '\x3cC程序设计 现代方法\x3e笔记',
    link: decodeURI(location.href),
    desc: 'C 的优缺点 底层语言 小型语言 包容性语言 优点 高效 可移植 功能强大 灵',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
