<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2019 Rust学习 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.67.1" />


<link rel="canonical" href="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="2019 Rust学习" />
<meta property="og:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2019-08-27T11:13:20+08:00" />
<meta property="article:modified_time" content="2019-08-27T11:13:20+08:00" />
<meta itemprop="name" content="2019 Rust学习">
<meta itemprop="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl">
<meta itemprop="datePublished" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="dateModified" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="wordCount" content="7181">



<meta itemprop="keywords" content="rust," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2019 Rust学习"/>
<meta name="twitter:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2019 Rust学习</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-08-27 </span>
        
        <span class="more-meta"> 7181 words </span>
        <span class="more-meta"> 15 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#rustup">rustup</a></li>
    <li><a href="#安装">安装</a></li>
    <li><a href="#本地文档">本地文档</a></li>
    <li><a href="#删除">删除</a></li>
    <li><a href="#自动补全">自动补全</a></li>
    <li><a href="#更新">更新</a></li>
    <li><a href="#安装其他版本">安装其他版本</a></li>
    <li><a href="#替换-crate-源">替换 crate 源</a></li>
    <li><a href="#cargo-常用命令">cargo 常用命令</a></li>
  </ul>

  <ul>
    <li><a href="#rules">rules</a></li>
    <li><a href="#stack-and-heap">stack and heap</a></li>
    <li><a href="#变量与数据交互">变量与数据交互</a>
      <ul>
        <li><a href="#move">move</a></li>
        <li><a href="#clone">clone</a></li>
        <li><a href="#stack-only">stack only</a></li>
        <li><a href="#copy-trait-的数据类型">copy trait 的数据类型</a></li>
      </ul>
    </li>
    <li><a href="#ownership-与-function">ownership 与 function</a></li>
    <li><a href="#references-and-borrowing">references and borrowing</a>
      <ul>
        <li><a href="#dangling-reference">dangling reference</a></li>
        <li><a href="#reference-rule">reference rule</a></li>
        <li><a href="#slice-type">slice type</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#定义">定义</a></li>
    <li><a href="#实例化">实例化</a></li>
    <li><a href="#tuple-struct">tuple struct</a></li>
    <li><a href="#unit-like-struct">unit like struct</a></li>
    <li><a href="#print">print</a></li>
    <li><a href="#method">method</a></li>
    <li><a href="#associated-function">associated function</a></li>
  </ul>

  <ul>
    <li><a href="#package-and-crates">package and crates</a></li>
    <li><a href="#module">module</a></li>
    <li><a href="#module-引用路径">module 引用路径</a></li>
    <li><a href="#struct-与-enum-的-pub">struct 与 enum 的 pub</a></li>
    <li><a href="#use-与-as">use 与 as</a></li>
    <li><a href="#将-lib-分离不同文件">将 lib 分离不同文件</a></li>
    <li><a href="#使用本地库">使用本地库</a></li>
  </ul>

  <ul>
    <li><a href="#vector">vector</a></li>
    <li><a href="#string">String</a></li>
    <li><a href="#hashmap">HashMap</a>
      <ul>
        <li><a href="#ownership-1">ownership</a></li>
        <li><a href="#更新-hashmap">更新 hashmap</a></li>
        <li><a href="#hash-function">hash function</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#不可恢复的错误-panic">不可恢复的错误 panic</a></li>
    <li><a href="#可恢复错误-result">可恢复错误 Result</a></li>
    <li><a href="#在-error-中快速-panic">在 Error 中快速 panic</a></li>
    <li><a href="#传播-error">传播 error</a></li>
  </ul>

  <ul>
    <li><a href="#泛型函数">泛型函数</a></li>
    <li><a href="#trait">trait</a>
      <ul>
        <li><a href="#trait-作为参数">trait 作为参数</a></li>
        <li><a href="#trait-作为返回值">trait 作为返回值</a></li>
      </ul>
    </li>
    <li><a href="#reference-lifetime">reference lifetime</a>
      <ul>
        <li><a href="#默认lifetime-rules">默认lifetime rules</a></li>
        <li><a href="#static-lifetime">static lifetime</a></li>
      </ul>
    </li>
    <li><a href="#它们组合在一起">它们组合在一起</a></li>
  </ul>

  <ul>
    <li><a href="#读取命令行参数">读取命令行参数</a></li>
  </ul>

  <ul>
    <li><a href="#捕获-environment">捕获 environment</a></li>
    <li><a href="#iterator">iterator</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#recursive-type">recursive type</a></li>
      </ul>
    </li>
    <li><a href="#drop-trait">Drop trait</a></li>
    <li><a href="#rct"><code>Rc&lt;T&gt;</code></a></li>
    <li><a href="#refcellt"><code>RefCell&lt;T&gt;</code></a></li>
    <li><a href="#概括">概括</a></li>
  </ul>

  <ul>
    <li><a href="#move-1">move</a></li>
    <li><a href="#线程之间消息传递">线程之间消息传递</a>
      <ul>
        <li><a href="#channel-与-ownership">channel 与 ownership</a></li>
      </ul>
    </li>
    <li><a href="#mutex">Mutex</a></li>
    <li><a href="#arct"><code>Arc&lt;T&gt;</code></a></li>
  </ul>

  <ul>
    <li><a href="#blocking-waiting-for-file-lock-on-package-cache">Blocking waiting for file lock on package cache</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="准备工作">准备工作</h1>
<h2 id="rustup">rustup</h2>
<p><a href="https://github.com/rust-lang/rustup.rs/blob/master/README.md">rustup github</a></p>
<blockquote>
<p>rustup 用于安装 Rust , 并可管理 rust 不同的版本(stable, beta, nightly) 并更新它们.</p>
</blockquote>
<p>rust 被安装在 <code>$HOME/.cargo/bin</code> 目录下.</p>
<p><code>cargo install</code> 安装的程序和插件, 同样也在上面的目录中.</p>
<h2 id="安装">安装</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl https://sh.rustup.rs -sSf | sh

在当前窗口加载环境配置
source $HOME/.cargo/env
</code></pre></div><h2 id="本地文档">本地文档</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">rustup doc
</code></pre></div><h2 id="删除">删除</h2>
<p><code>rustup self uninstall</code></p>
<h2 id="自动补全">自动补全</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># bash</span>
rustup completions bash &gt; <span style="color:#66d9ef">$(</span>brew --prefix<span style="color:#66d9ef">)</span>/etc/bash_completion.d/rustup.bash-completion
<span style="color:#75715e"># zsh</span>
rustup completions zsh &gt; ~/.zfunc/_rustup
在 ~/.zshrc 文件中, 在 compinit 之前添加以下语句
fpath<span style="color:#f92672">+=</span>~/.zfunc
</code></pre></div><h2 id="更新">更新</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">rustup update

rustup self update
</code></pre></div><h2 id="安装其他版本">安装其他版本</h2>
<blockquote>
<p>rustup 安装 rust 时, 默认是 stable 版本</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#75715e"># 安装 nightly 版本</span>
 rustup toolchain install nightly
 <span style="color:#75715e"># 运行 nightly 版本编译器</span>
 rustup run nightly rustc --version
 <span style="color:#75715e"># 切换默认版本为 nightly</span>
 rustup default nightly
</code></pre></div><h2 id="替换-crate-源">替换 crate 源</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">vim  $HOME/.cargo/config
添加以下内容

<span style="color:#f92672">[</span>source.crates-io<span style="color:#f92672">]</span>
registry <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://github.com/rust-lang/crates.io-index&#34;</span>
replace-with <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;ustc&#39;</span>
<span style="color:#f92672">[</span>source.ustc<span style="color:#f92672">]</span>
registry <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;git://mirrors.ustc.edu.cn/crates.io-index&#34;</span>
</code></pre></div><ul>
<li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates">https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates</a></li>
</ul>
<h2 id="cargo-常用命令">cargo 常用命令</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cargo new project-name
cargo run
cargo build  --release

<span style="color:#75715e"># 升级依赖. 成功后, 会更新 Cargo.lock 文件</span>
cargo update

<span style="color:#75715e"># 为你的项目及依赖生成文档</span>
cargo doc --open
</code></pre></div><blockquote>
<p>Cargo.lock 文件是你第一次执行  <code>cargo build</code> 后输出的文件.</p>
<p>你的项目在其他人里编译时, 如果 cargo 发现有 Cargo.lock 文件, 则以该文件里的一切配置及版本为准来编译项目. 这方便重现你的项目.</p>
</blockquote>
<h1 id="rust-概念">Rust 概念</h1>
<ul>
<li>
<p>默认情况下, 变量是不可变的. <code>immutable by default</code></p>
<ul>
<li>要想使变量可变, 则要用 <code>mut</code> 来修饰.</li>
</ul>
</li>
<li>
<p>默认情况下, 引用也是不可变的. <code>references are immutable by default</code></p>
<ul>
<li>要想使引用可变, 则要 <code>&amp;mut</code> 来修饰</li>
</ul>
</li>
<li>
<p><code>immutable</code> 表示一旦绑定 <code>bind</code> 就不可以再改变其值.</p>
</li>
<li>
<p><code>Result</code> 是枚举类型. <code>Ok</code> 或 <code>Err</code> .</p>
</li>
<li>
<p><code>cargo</code> 文件 <code>Cargo.toml</code> 的版本写法 <code>rand = &quot;0.3.14&quot;</code> 等同于 <code>rand = &quot;^0.3.14&quot;</code> 表示任意兼容 <code>0.3.14</code> 版本 API 的版本即可.</p>
</li>
<li>
<p><code>crate</code> 表示库</p>
</li>
<li>
<p><code>trait</code> 表示接口</p>
</li>
<li>
<p><code>shadow</code> : 通常用于同一个变量名, 从一种类型切换到另一种类型.</p>
<ul>
<li><code>let x = 5; let x = x + 1;</code></li>
</ul>
</li>
<li>
<p><code>shadow</code> 与 <code>mut</code> 的区别</p>
<ul>
<li>如果没有 <code>let</code> 然后重新声明同样名的变量会编译错误. 通过 <code>let</code> 我们可以方便地从一个变量转变为  <code>immuable</code></li>
<li><code>let</code> 可以重用原来的变量名, 但类型可以不同. 而 <code>mut</code> 不可以.</li>
</ul>
</li>
<li>
<p>指定变量类型 <code>let var_name: var_type</code></p>
</li>
<li>
<p><code>_</code> : 特殊变量, 表示所有.</p>
</li>
<li>
<p><code>const</code> 与 <code>immutable</code> 的区别</p>
<ul>
<li><code>const</code> 不允许用 <code>mut</code> 修饰. 它是一直都不可变的.</li>
<li><code>const</code> 中, 类型必须显式指定</li>
<li><code>const</code> 可以在任何地方声明</li>
<li><code>const</code> 只允许 <code>const</code> 表达式赋值, 而不是一个函数调用或其他在 runtime 时计算出来的值.</li>
</ul>
</li>
<li>
<p>数据类型</p>
<ul>
<li>
<p>scalar : 表示一个单独的值. 有 4 种.</p>
<ul>
<li>
<p>integer</p>
<table>
<thead>
<tr>
<th>length</th>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>8bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32bit</td>
<td>i32 (默认,即使是 64 位平台)</td>
<td>u32</td>
</tr>
<tr>
<td>64bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
<p>字面量</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>98_222</td>
</tr>
<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>
<tr>
<td>八进制</td>
<td>0o77</td>
</tr>
<tr>
<td>二进制</td>
<td>0b1111_000</td>
</tr>
<tr>
<td>字节(仅限 u8 类型)</td>
<td>b&rsquo;A&rsquo;</td>
</tr>
</tbody>
</table>
<p>溢出处理</p>
<p>Debug 模式: 会检测是否溢出. 然后产生 <code>panic</code> 退出.</p>
<p>Release 模式: 并不会检测溢出. 超出值范围的话, 会产生  <code>two's complement wrapping</code> .</p>
</li>
<li>
<p>foating-point number</p>
<table>
<thead>
<tr>
<th>bit</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td>32</td>
<td>f32</td>
</tr>
<tr>
<td>64</td>
<td>f64 (默认)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>bool</p>
<ul>
<li>只有两个值 <code>false</code>, <code>true</code></li>
<li>大小为 <code>1 byte</code></li>
</ul>
</li>
<li>
<p>character</p>
<ul>
<li>使用单引用. 双引用的话是 String 类型.</li>
<li>它是 14 bytes`  大小.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>compound : 这可以组成多个值为一个类型. 有两种</p>
<ul>
<li>tule
<ul>
<li>可以由多种类型组合为一种.</li>
<li>它是固定长度. 一旦声明, 则不能改变大小.</li>
<li>声明: <code>let tup =(32, 6.4, 1)</code> . `  要获取值
<ul>
<li><code>let (x, y, z) = tup;</code> : 这种称为解构 <code>destructuring</code></li>
<li>也可以通过下标直接访问 <code>tup.0</code>, <code>tup.1</code> . 第一个索引的下标为 0.</li>
</ul>
</li>
<li>元素不必是相同类型</li>
</ul>
</li>
<li>array
<ul>
<li>固定长度.</li>
<li>声明 <code>let a = [1,2,3,4,5];</code></li>
<li><code>let a : [i32; 5] = [1,2,3,4,5];</code></li>
<li><code>let a = [3; 5]</code> . 表示元素全是 3, 一共 5 个.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>函数</p>
<ul>
<li>风格 <code>fn hello_world()</code></li>
<li>参数 <code>fn hello_world(x:i32)</code> 参数中的类型是必填的</li>
<li>函数体. 包含许多 statement 以及结尾可选的 expression.
<ul>
<li><code>statement</code> :  执行一些动作, 但没有返回值.
<ul>
<li>比如函数声明</li>
<li><code>let</code></li>
</ul>
</li>
<li><code>expression</code> : 它会给出一个值.
<ul>
<li>调用函数</li>
<li>调用 macro</li>
<li><code>{}</code> 定义作用域: <code>let y = {let x = 3; x + 1}</code></li>
</ul>
</li>
<li>注意 <code>5+1</code> 是 expression. 但 <code>5+1;</code>  是 statement.</li>
<li><code>expression</code> 可以是 <code>statement</code> 的一部分.</li>
</ul>
</li>
<li>注意, Rust 是一门 <code>expression-based</code> 的语言. 这跟其他的有很大的不同.</li>
<li>返回值
<ul>
<li><code>fn hello_world() -&gt; i32 {}</code></li>
<li>函数体最后一个 expression 就是函数的返回值.</li>
<li>多值(通过 tuple). <code>fn hello_world() -&gt; (i32, i32){}</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>注释: <code>// your comment</code></p>
</li>
<li>
<p>控制流程</p>
<ul>
<li><code>if expression</code> 注意, 它是表达式来的.
<ul>
<li><code>if bool-expression {} else if bool-expression2 {} else {}</code></li>
<li>用在 <code>let</code> 中 : <code>let number = if condition {} else {};</code>
<ul>
<li>这时,  if 与 else 的 <code>expression</code> 结果, 都需要一致.</li>
</ul>
</li>
</ul>
</li>
<li>循环
<ul>
<li><code>loop</code>
<ul>
<li>无限循环. <code>loop {}</code></li>
</ul>
</li>
<li><code>while</code>
<ul>
<li><code>while condition {}</code></li>
</ul>
</li>
<li><code>for</code>
<ul>
<li>遍历数组 <code>for e in arr.iter() {}</code></li>
<li><code>for number in (1..4).rev() {}</code></li>
</ul>
</li>
<li>中断循环 : <code>break;</code> 它是 <code>expression</code> . <code>break x * 2;</code> 表示中断, 并返回值 <code>x*2</code></li>
<li>继续循环 : <code>continue;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ownership">Ownership</h1>
<h2 id="rules">rules</h2>
<ul>
<li>在 Rust 中的每个值都有一个称为 <code>owner</code> 的变量</li>
<li>同一时间, 只允许一个 <code>owner</code></li>
<li>当 <code>owner</code> 离开了作用域, 则这个 value 将被 drop 掉.
<ul>
<li>即 Rust 在变量离开作用域时, 自动调用 <code>drop</code> 函数来释放资源.</li>
</ul>
</li>
</ul>
<h2 id="stack-and-heap">stack and heap</h2>
<ul>
<li>Stack : 所有保存在 stack 的数据必须是编译期已知的, 固定大小的.</li>
<li>Heap : 编译期未知大小的或大小允许被改变的数据则存储在 heap.</li>
</ul>
<h2 id="变量与数据交互">变量与数据交互</h2>
<h3 id="move">move</h3>
<p>类似其他类型的 <code>shallow copy</code> , 在 Rust 中称为 <code>move</code> .</p>
<p>当一个变量 move 到另一个变量时, 则旧的变量将变成无效了. 即 ownership move 了.</p>
<h3 id="clone">clone</h3>
<p>类似其他类型的 <code>deep copy</code> ,  在 Rust 中是调用 <code>clone()</code> 方法. 开销比较大, 容易影响性能.</p>
<h3 id="stack-only">stack only</h3>
<p>在 stack 上的数据, 都是  <code>copy</code> . (即不会 move)</p>
<p>在 stack 中的数据, <code>shadow copy</code> 与 <code>deep copy</code> 是一样的.</p>
<blockquote>
<p>Rust 不允许在某个类型拥有 Drop trait  的添加 Copy trait .</p>
</blockquote>
<h3 id="copy-trait-的数据类型">copy trait 的数据类型</h3>
<ul>
<li>integer</li>
<li>bool</li>
<li>float point number</li>
<li>character</li>
<li>tuple 并且仅包含是  <code>copy trait</code> 的元素. 例如 <code>(i32, i32)</code> . 但 <code>(i32, String)</code> 则不是.</li>
</ul>
<h2 id="ownership-与-function">ownership 与 function</h2>
<p>从语义上说, 传递一个值给函数, 跟赋值给一个变量是同义的. 所以,传递一个变量给一个函数, 将会导致 <code>copy</code> 或 <code>move</code> , 像赋值那样子.</p>
<p>返回值也同样会 transer ownership .</p>
<h2 id="references-and-borrowing">references and borrowing</h2>
<p>可以通过 reference 一个对象作为参数, 而不是获取它的 ownership. (这称为  <code>borrowing</code> , 即函数参数是 reference , <code>&amp;</code> )</p>
<blockquote>
<p>注意,  <code>&amp;</code> 即 reference , 默认情况下也是 immutable 的.</p>
<p>要想 <code>&amp;</code> 即 reference 变成 muutable, 则要 <code>let mut s = String.from(&quot;hello&quot;);</code> 然后传递reference 时使用 <code>&amp;mut s</code> 即可(相应的函数参数也要指定为 <code>&amp;mut String</code></p>
<p>mutable 的 reference 有一个很大的限制, 即在同一个作用域内, 只允许一个 mutable reference . 比如下面这样子就不允许:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">let mut s <span style="color:#f92672">=</span> String.from<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span>;
let r1 <span style="color:#f92672">=</span> &amp;mut s;
let r2 <span style="color:#f92672">=</span> &amp;mut s;
</code></pre></div><p>也不允许 mutable reference 与 immutable reference 共存.</p>
<p>但可以允许多个 immutable reference 共存</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_length</span>(s:<span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">usize</span> {
  s.len()
}
</code></pre></div><p>下面这种则会获取 ownership . 这时  s 在调用完函数后会被 drop 掉.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_length</span>(s:String) -&gt; <span style="color:#66d9ef">usize</span> {
  s.len()
}
</code></pre></div><h3 id="dangling-reference">dangling reference</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> no_dangle();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, s);
}
<span style="color:#75715e">// 这个方法是 borrow, ownership 在 dangle() 方法内, 返回后, Rust 会释放 s 的内存. 导致 dangle reference, 所以在编译期就禁止了.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">dangle</span>() -&gt; <span style="color:#66d9ef">&amp;</span>String {
    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
    <span style="color:#f92672">&amp;</span>s
}

<span style="color:#75715e">// 这个方法是 move, 即将 ownership 移出去, 这样子, Rust 就不会释放 s 的内存了
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">no_dangle</span>() -&gt; String {
    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
    s
}
</code></pre></div><h3 id="reference-rule">reference rule</h3>
<ul>
<li>在给定的任意时间, 要么只有一个 mutable reference 要么多个 immutable reference . 但不能共存.</li>
<li>reference 必须总是有效的.</li>
</ul>
<h3 id="slice-type">slice type</h3>
<blockquote>
<p>slice 并不拥有 ownership</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
<span style="color:#66d9ef">let</span> slice <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">2</span>..<span style="color:#ae81ff">4</span>];
</code></pre></div><p>返回 String slice</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hello_world</span>(s : <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
  <span style="color:#f92672">&amp;</span>s[..]
}
</code></pre></div><p>string 字面值</p>
<blockquote>
<p>所有 string 字面值, 都是 slice 类型. 即 <code>&amp;str</code> .  也意味着它是 immutable 的. 因为 reference 默认是 immutable 的.</p>
</blockquote>
<p>其他类型的 slice</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>];
<span style="color:#66d9ef">let</span> slice <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a[<span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// slice 是 &amp;[i32] 类型
</span></code></pre></div><h1 id="struct">struct</h1>
<h2 id="定义">定义</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">User</span> {
  name : String,
  email : String,
  active : <span style="color:#66d9ef">bool</span>,
}
</code></pre></div><h2 id="实例化">实例化</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> user1 <span style="color:#f92672">=</span> User {
  name : String::from(<span style="color:#e6db74">&#34;yang&#34;</span>),
  email : String::from(<span style="color:#e6db74">&#34;xx@qq.com&#34;</span>),
  active : <span style="color:#a6e22e">true</span>,
};

<span style="color:#75715e">// mutable 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> user1 <span style="color:#f92672">=</span> User {
  name : String::from(<span style="color:#e6db74">&#34;yang&#34;</span>),
  email : String::from(<span style="color:#e6db74">&#34;xx@qq.com&#34;</span>),
  active : <span style="color:#a6e22e">true</span>,
};


</code></pre></div><blockquote>
<p>注意, 整个实例要么是 immutable, 要么是 mutable, Rust 不允许 struct 中部分字段是 mutable, 部分是 immutable</p>
</blockquote>
<p>使用函数来初始化可以简化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build_user</span>(email : String, name : String) -&gt; <span style="color:#a6e22e">User</span> {
  User {
    email,
    name,
    active: <span style="color:#a6e22e">true</span>,
  }
}
</code></pre></div><blockquote>
<p>即函数参数跟成员同名即可.</p>
</blockquote>
<p>使用旧的 struct 实例来初始化新的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> user1 <span style="color:#f92672">=</span> User {
  name : String::from(<span style="color:#e6db74">&#34;yang&#34;</span>),
  email : String::from(<span style="color:#e6db74">&#34;xx@qq.com&#34;</span>),
  active : <span style="color:#a6e22e">true</span>,
};

<span style="color:#66d9ef">let</span> user2 <span style="color:#f92672">=</span> User {
  name : String::from(<span style="color:#e6db74">&#34;yang&#34;</span>),
  email : String::from(<span style="color:#e6db74">&#34;xx@qq.com&#34;</span>),
  ..user1
};
</code></pre></div><blockquote>
<p>这表示, user2 中除了 name, email 不同值之外, 其他成员字段值跟 user1一致.</p>
</blockquote>
<h2 id="tuple-struct">tuple struct</h2>
<blockquote>
<p>类似 tuple, 但没有名字, 只有类型. 可以像 tuple 那样解构以及通过索引访问</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Color</span>(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>);
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>);
</code></pre></div><h2 id="unit-like-struct">unit like struct</h2>
<p>它没有任何成员. <code>()</code></p>
<p>通常用于实现一个 trait, 但没有任何数据要存储到这个类型上.</p>
<h2 id="print">print</h2>
<p>默认情况下, 自定义的 struct 类型并没有实现 <code>std::fmt::Display</code> 这个 trait . 所以当使用 <code>println!()</code> 来打印 struct 对象时会编译报错.</p>
<p>可修改为 debug print</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Are</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> are <span style="color:#f92672">=</span> Are {
        width: <span style="color:#ae81ff">16</span>,
        height: <span style="color:#ae81ff">16</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;are -&gt; {:?}&#34;</span>, are);
}
</code></pre></div><blockquote>
<p>即 println! 中的 <code>{:?}</code> 表示使用 <code>#[derive(Debug)]</code>  的 trait 来显示.</p>
</blockquote>
<h2 id="method">method</h2>
<blockquote>
<p>method 不完全同于 function. Method 是定义在 struct (或 enum, 或 trait 对象) 的上下文中的.</p>
<p>Method 可以 move ownership (self), 或 borrow immutable (&amp;self) 或 borrow mutable  (&amp;mut self)</p>
<p>Rust 在调用 method 的时候, 会自动将 struct 转换为 method 签名的类型.(如果兼容的话)</p>
</blockquote>
<p>定义 method</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Are</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#75715e">// struct 允许有多个 impl .
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Are {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">area</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.height <span style="color:#f92672">*</span> self.width
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> are <span style="color:#f92672">=</span> Are {
        width: <span style="color:#ae81ff">16</span>,
        height: <span style="color:#ae81ff">16</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;are -&gt; {:?}&#34;</span>, are.area());
}
</code></pre></div><p>Method 的第一个参数, 总是 <code>self</code> (可以为 <code>&amp;self</code> 或 <code>&amp;mut self</code>).</p>
<h2 id="associated-function">associated function</h2>
<p>在 impl 语句块中的函数第一个参数不是 <code>self</code> 的函数, 即是  associated function. 它不是 method, 因为它不与实例关联.</p>
<blockquote>
<p>String::from 就是一个 associcated function</p>
</blockquote>
<h1 id="enum-与-pattern-matching">enum 与 pattern matching</h1>
<p>定义</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">IP</span> {
  V4,
  V6,
}
<span style="color:#960050;background-color:#1e0010">或</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Message</span> {
  Quit,
  Move {x: <span style="color:#66d9ef">u32</span>, y: <span style="color:#66d9ef">u32</span>},
  Write(String),
  Color(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>),
}

</code></pre></div><p>类似 struct, 也可以为 enum 添加 impl .</p>
<blockquote>
<p>Option enum.</p>
<p>Rust 中没有 null 这种特性.</p>
</blockquote>
<p>match <code>expression</code> .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">value_in_message</span>(message: <span style="color:#a6e22e">Message</span>) -&gt; <span style="color:#66d9ef">u8</span> {
  <span style="color:#66d9ef">match</span> message {
    Message::Quit <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>,
    Message::Move <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>,
    Message::Write <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>,
    Message::Color <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>,
  }
}

<span style="color:#75715e">//绑定值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, plus_one(Some(<span style="color:#ae81ff">32</span>)));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">plus_one</span>(x : Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">match</span> x {
        None <span style="color:#f92672">=&gt;</span> None,
        Some(i) <span style="color:#f92672">=&gt;</span> Some(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
    }
}

<span style="color:#75715e">// 结合 if let. 它与 match 类似, 当 match 条件匹配时, 则执行某动作. 注意, if let xx 后面是 = 号, 而不是 ==
</span><span style="color:#75715e">// 可以想象为 if let 是 match 语法糖, 它只执行 match 其中之一, 而忽略剩余其他的全部. 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> som <span style="color:#f92672">=</span> plus_one(Some(<span style="color:#ae81ff">32</span>));
    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#ae81ff">33</span>) <span style="color:#f92672">=</span> som {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;33&#34;</span>);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">plus_one</span>(x : Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">match</span> x {
        None <span style="color:#f92672">=&gt;</span> None,
        Some(i) <span style="color:#f92672">=&gt;</span> Some(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
    }
}
</code></pre></div><blockquote>
<p>match 必须匹配所有情况. 特殊的 <code>_</code> 表示剩余所有情况.</p>
<p>因为 match 要匹配所有情况. 所以, 如果你只想处理其中之一的情况, 请记得用 if let 语法.</p>
</blockquote>
<h1 id="project-manage">Project manage</h1>
<ul>
<li>Package</li>
<li>Crates</li>
<li>Modules 以及 use</li>
<li>Paths</li>
</ul>
<h2 id="package-and-crates">package and crates</h2>
<p>一个 crate 是一个 binary (<code>main.rs</code>) 或 lib. (<code>lib.rs</code>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># binary</span>
cargo new project 
<span style="color:#75715e"># lib</span>
cargo new --lib libname
</code></pre></div><p>一个 package 是一个或多个 crate. 一个 package 包含一个 <code>Cargo.toml</code> 文件描述如何构建这些 crate.  一个 package 可以包含 0 或至多一个 lib crate.</p>
<h2 id="module">module</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 创建库</span>
 cargo new --lib mathlib

<span style="color:#75715e"># 添加模块. 修改 src/lib.rs 文件</span>
mod hello <span style="color:#f92672">{</span>
    fn say_world<span style="color:#f92672">(</span>s: &amp;str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello {}&#34;</span>, s<span style="color:#f92672">)</span>;
    <span style="color:#f92672">}</span>

    mod sub <span style="color:#f92672">{</span>
        fn say_world<span style="color:#f92672">(</span>s: &amp;str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s<span style="color:#f92672">)</span>;
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>module tree</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">根据上面的情况, module tree 为
crate -&gt; hello -&gt; say_world
               -&gt; sub -&gt; say_world
</code></pre></div><h2 id="module-引用路径">module 引用路径</h2>
<ul>
<li>绝对路径: 通过 crate 名字或以 <code>crate</code> 开头.</li>
<li>相对路径: 在当前模块中, 使用 <code>self</code> 或 <code>super</code> 或直接当前模块的标识符</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">mod</span> hello {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello {}&#34;</span>, s);
    }

    <span style="color:#66d9ef">mod</span> sub {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s);
        }
    }
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    hello::say_world(s);
}
</code></pre></div><blockquote>
<p>默认情况下, rust 所有东西(function, method, struct, enum, module, constant)都是 private 的.  要想导出路径, 则使用 pub 关键字.</p>
</blockquote>
<p>调用父模块的方法(每一次 super , 相当于目录的 <code> ../</code>, 即上级目录)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">mod</span> hello {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello {}&#34;</span>, s);
    }

    <span style="color:#66d9ef">mod</span> sub {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s);
            <span style="color:#66d9ef">super</span>::<span style="color:#66d9ef">super</span>::say_world_parent(s);
        }
    }
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world_parent</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    hello::say_world(s);
}
</code></pre></div><h2 id="struct-与-enum-的-pub">struct 与 enum 的 pub</h2>
<p>注意, 在 struct 之前使用 <code>pub</code> 表示该 struct 是 pub 的, 但里面的字段仍然是 <code>private</code> 的. 但 enum 的话 如果 pub 了, 则所有都默认都是 pub 的.</p>
<h2 id="use-与-as">use 与 as</h2>
<p>use : 导入路径.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">mod</span> hello {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello {}&#34;</span>, s);
    }

    <span style="color:#66d9ef">mod</span> sub {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s);
            <span style="color:#66d9ef">super</span>::<span style="color:#66d9ef">super</span>::say_world_parent(s);
        }
    }
}

<span style="color:#66d9ef">use</span> hello::say_world;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world_parent</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    say_world(s);
}
</code></pre></div><p>其他用法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::{com::Ordering, io};
<span style="color:#66d9ef">use</span> std::io::{self, Write};
<span style="color:#66d9ef">use</span> std::io::<span style="color:#f92672">*</span>;
</code></pre></div><p>as : 别名</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">mod</span> hello {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello {}&#34;</span>, s);
    }

    <span style="color:#66d9ef">mod</span> sub {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s);
            <span style="color:#66d9ef">super</span>::<span style="color:#66d9ef">super</span>::say_world_parent(s);
        }
    }
}

<span style="color:#66d9ef">use</span> hello::say_world <span style="color:#66d9ef">as</span> h;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world_parent</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    h(s);
}
</code></pre></div><h2 id="将-lib-分离不同文件">将 lib 分离不同文件</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">src/lib.rs
src/hello.rs

只要在 lib.rs 文件中使用
mod hello; 
即可导入到 lib.rs 合并了.
</code></pre></div><h2 id="使用本地库">使用本地库</h2>
<p><code>Cargo.toml</code>  文件修改:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>dependencies<span style="color:#f92672">]</span>
rand <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.3.14&#34;</span>
<span style="color:#75715e"># 注意 这个命名, 要跟库项目中的 Cargo.toml 中的 name 一致.</span>
mathlib <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;../mathlib&#34;</span><span style="color:#f92672">}</span> <span style="color:#75715e"># 这里指向库的根目录</span>
</code></pre></div><p>使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mathlib;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    mathlib::hello::say_world(<span style="color:#e6db74">&#34;fuck&#34;</span>);
}
</code></pre></div><h1 id="常用集合-collections">常用集合 Collections</h1>
<blockquote>
<p>这些数据结构是保存在 heap 的.</p>
</blockquote>
<h2 id="vector">vector</h2>
<blockquote>
<p>每个元素只能是同一种类型. 不过, 可以利用 enum 来持有其他类型.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// 创建
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Vec::new();
    <span style="color:#66d9ef">let</span> vv <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
}

<span style="color:#75715e">// 添加/删除元素
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Vec::new();
    v.push(<span style="color:#ae81ff">13</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, v);
    v.remove(<span style="color:#ae81ff">0</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, v);
}

<span style="color:#75715e">//遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>v {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, i);
    }
}
</code></pre></div><blockquote>
<p>注意. 这里是用 <code>&amp;v</code> , 如果为 <code>v</code> , 则表示将 let v 的 ownership move 到 for 语句块了. 当结束时, v 就无效了, 即后面的代码不能再访问 v 了.</p>
</blockquote>
<h2 id="string">String</h2>
<blockquote>
<p>它是 UTF8 encode 的.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();

<span style="color:#75715e">//修改
</span><span style="color:#75715e"></span>s.push_str(<span style="color:#e6db74">&#34;hello world&#34;</span>);

<span style="color:#75715e">//拼接 concat
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello &#34;</span>);
    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);
    <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, s3);
}
<span style="color:#960050;background-color:#1e0010">实际调用的方法签名伪代码为</span> 
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, s:<span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {}

<span style="color:#960050;background-color:#1e0010">所以</span>, <span style="color:#960050;background-color:#1e0010">第一个参数</span>(<span style="color:#960050;background-color:#1e0010">即</span> s1)<span style="color:#960050;background-color:#1e0010">的</span> ownership <span style="color:#960050;background-color:#1e0010">已经</span> <span style="color:#66d9ef">move</span> <span style="color:#960050;background-color:#1e0010">了</span>. <span style="color:#960050;background-color:#1e0010">之后的代码中</span>, s1 <span style="color:#960050;background-color:#1e0010">不再有效</span>. <span style="color:#960050;background-color:#1e0010">由于</span> s2 <span style="color:#960050;background-color:#1e0010">只是借用而非</span> <span style="color:#66d9ef">move</span>, <span style="color:#960050;background-color:#1e0010">所以</span> s2 <span style="color:#960050;background-color:#1e0010">仍然是</span> valid <span style="color:#960050;background-color:#1e0010">的</span>. 

<span style="color:#75715e">//拼接 2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello &#34;</span>);
    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);
    <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}{}&#34;</span>, s1, s2);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;s1 {}, s2 {}, s3 {}&#34;</span>, s1, s2, s3);
}

<span style="color:#75715e">//索引 String. Rust 的 String 不同于其他的编程语言可以直接根据下标来索引字符.
</span><span style="color:#75715e">// Rust 的 String 内部是使用 Vec&lt;u8&gt; . 即 Vec&lt;byte&gt; 来保存的. 即字节 Vec
</span><span style="color:#75715e">// String.len() 返回的是字节的长度, 而不是字符.
</span><span style="color:#75715e">// Rust 中的 String 有三种表示. bytes, scalar values, grapheme clusters.
</span><span style="color:#75715e">// Rust 不允许使用索引来引用 String 的另一个原因是, 索引操作预期是 O(1) 的, 但Rust 中的 String 并不能这样子, 只能从头到尾来决定字符是否有效.
</span><span style="color:#75715e">// 允许使用索引的情况是返回值为 a byte, a character, a grapheme cluster 或 string slice.
</span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;hello&#34;</span>.chars()
<span style="color:#e6db74">&#34;hello&#34;</span>.bytes()
grapheme <span style="color:#960050;background-color:#1e0010">比较复杂</span>, <span style="color:#960050;background-color:#1e0010">并没有在标准库中提供</span>.
</code></pre></div><h2 id="hashmap">HashMap</h2>
<blockquote>
<p>类似 vector, Hashmap 保存在 heap. k 要同一类型. v 也要同一类型.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::collections::HashMap;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
    scores.insert(String::from(<span style="color:#e6db74">&#34;hello&#34;</span>), <span style="color:#ae81ff">10</span>);
    scores.insert(String::from(<span style="color:#e6db74">&#34;world&#34;</span>), <span style="color:#ae81ff">20</span>);


    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, scores);
}

<span style="color:#75715e">//通过两个 vec 来构建 HashMap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::collections::HashMap;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> teams <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[String::from(<span style="color:#e6db74">&#34;hello&#34;</span>), String::from(<span style="color:#e6db74">&#34;world&#34;</span>)];
    <span style="color:#66d9ef">let</span> scores <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>];

    <span style="color:#66d9ef">let</span> m: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>_, _<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> teams.iter().zip(scores.iter()).collect();

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, m);
}

<span style="color:#75715e">//遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (k, v) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>m {
  
}
</code></pre></div><h3 id="ownership-1">ownership</h3>
<p>对于实现了 Copy trait 的, 例如 <code>i32</code> , 则值将 copy 到 HashMap, 而对于 owned value 的, 例如 <code>String</code>, 则 ownership 将会 move 到 HashMap. 例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::collections::HashMap;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
    <span style="color:#66d9ef">let</span> w <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
    map.insert(h, w);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, map);
    <span style="color:#75715e">//println!(&#34;h {}, w {}&#34;, h, w); h, w 的 ownership 已经 move 到 map 了, 所以 insert 之后, 这两个变量已经 invalid 了. 
</span><span style="color:#75715e"></span>}
</code></pre></div><blockquote>
<p>不过, 如果我们插入 reference 的话, 则 ownership 不会 move .</p>
<p>但这种情况下,  reference 的生命周期至少要与 hashMap 一样有效.</p>
</blockquote>
<h3 id="更新-hashmap">更新 hashmap</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">		<span style="color:#75715e">//直接覆盖
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
    <span style="color:#66d9ef">let</span> w <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
    map.insert(h, w);
    map.insert(String::from(<span style="color:#e6db74">&#34;hello&#34;</span>), String::from(<span style="color:#e6db74">&#34;new world&#34;</span>));

		<span style="color:#75715e">//只在 key 没有值的时候插入
</span><span style="color:#75715e"></span>		map.entry(String::from(<span style="color:#e6db74">&#34;newKey&#34;</span>)).or_insert(String::from(<span style="color:#e6db74">&#34;fuck&#34;</span>));

		<span style="color:#75715e">//基于旧值更新. or_insert 实际返回的是 &amp;mut v, 这样子就可以修改这个值即可.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> map.entry(xx).or_insert(yy);
		<span style="color:#f92672">*</span>v <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;

</code></pre></div><h3 id="hash-function">hash function</h3>
<p>默认情况下 HashMap 使用的是 siphash 函数. 但它不是性能最快的, 但权衡了安全性. 如果你发现它不能满足的你性能要求, 可以指定其他的 hash function .</p>
<h1 id="错误处理">错误处理</h1>
<h2 id="不可恢复的错误-panic">不可恢复的错误 panic</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;crash message...&#34;</span>);
</code></pre></div><p>当使用该宏时, 会打印 panic 信息, 然后 unwind 以及程序清理栈, 最后退出.</p>
<blockquote>
<p>Unwinding 要执行许多工作. 一个可选的方式是立即 abort . 这会导致程序直接退出, 而不进行清理. (例如内存的释放交由操作系统来处理, 而不是程序自身).</p>
<p>如果你的程序binary文件想尽可能小, 则可以切换 panic 为 abort 处理模式. 在 Cargo.toml 文件中添加</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>profile.release<span style="color:#f92672">]</span>
panic <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;abort&#39;</span>
</code></pre></div></blockquote>
<p>跟踪栈. (此时, debug symbols 必须要开启. <code>--release</code> 参数构建的 binanry 则没有)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RUST_BACKTRACE<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> cargo run
</code></pre></div><h2 id="可恢复错误-result">可恢复错误 Result</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
<span style="color:#66d9ef">use</span> std::fs::File;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>);
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> f {
        Ok(file) <span style="color:#f92672">=&gt;</span> file,
        Err(error) <span style="color:#f92672">=&gt;</span> {
            panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;open file error {:?}&#34;</span>, error);
        }
    };
}
<span style="color:#75715e">//进一步处理不同的错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::fs::File;
<span style="color:#66d9ef">use</span> std::io::ErrorKind;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>);
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> f {
        Ok(file) <span style="color:#f92672">=&gt;</span> file,
        Err(error) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> error.kind() {
            ErrorKind::NotFound <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> File::create(<span style="color:#e6db74">&#34;hello.txt&#34;</span>) {
                Ok(file) <span style="color:#f92672">=&gt;</span> file,
                Err(err) <span style="color:#f92672">=&gt;</span> {
                    panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;create file error {}&#34;</span>, err);
                }
            },
            _ <span style="color:#f92672">=&gt;</span> {
                panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;other error  {}&#34;</span>, error);
            }
        }
    };
}
</code></pre></div><h2 id="在-error-中快速-panic">在 Error 中快速 panic</h2>
<ul>
<li><code>unwrap()</code> : 即如果 Result 是 Ok 则返回 Ok 持有的数据. 如果返回的是 Err 则调用 <code>panic!().</code> <code>let f = File::open(&quot;hello.txt&quot;).unwrap();</code></li>
<li><code>expect(msg)</code> :  类似 unwrap, 但让我们选择 panic 输出的 message.</li>
</ul>
<h2 id="传播-error">传播 error</h2>
<p>即将错误处理交由 caller 调用者来决定.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_line</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span> {
  
}
</code></pre></div><p>快速传播 Error 操作符: <code>?</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_string</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> f <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>)<span style="color:#f92672">?</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();
    f.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s)<span style="color:#f92672">?</span>;
    ok(s)
}

<span style="color:#75715e">//简化调用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_string</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();
  File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>)<span style="color:#f92672">?</span>.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s)<span style="color:#f92672">?</span>;
  Ok(s)
}
<span style="color:#75715e">//再一步
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::fs;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_string</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span> {
	fs::read_to_string(<span style="color:#e6db74">&#34;hello.txt&#34;</span>)
}
</code></pre></div><p>即在 <code>Result</code> 类型后添加 <code>?</code> .  如果返回 Ok, 则会继续执行. 否则 return 返回调用者.</p>
<p><code>?</code> 与 match 的区别是: <code>?</code> 会调用 <code>From trait</code> 的 <code>from</code> 函数, 该函数用于将 error 类型转换为另一个类型.</p>
<h1 id="泛型-trait-以及生命周期">泛型, trait 以及生命周期</h1>
<h2 id="泛型函数">泛型函数</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">largest</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(list:<span style="color:#66d9ef">&amp;</span>[T]) -&gt; <span style="color:#a6e22e">T</span> {
  
}
</code></pre></div><h2 id="trait">trait</h2>
<blockquote>
<p>定义共享行为</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> p <span style="color:#f92672">=</span> Person{};
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, p.say_hello());
}

<span style="color:#75715e">//定义一个 trait
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> TraitName {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_hello</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
  
  	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_hello2</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
      <span style="color:#75715e">//添加默认实现
</span><span style="color:#75715e"></span>      String::from(<span style="color:#e6db74">&#34;default value&#34;</span>)
  	}
}

<span style="color:#75715e">//为某类型实现 trait
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {

}

<span style="color:#66d9ef">impl</span> TraitName <span style="color:#66d9ef">for</span> Person {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_hello</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        String::from(<span style="color:#e6db74">&#34;hello world&#34;</span>)
    }
}
</code></pre></div><h3 id="trait-作为参数">trait 作为参数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">notify</span>(item: <span style="color:#a6e22e">impl</span> TraitName) {
  
}

<span style="color:#75715e">//或
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">notify</span><span style="color:#f92672">&lt;</span>T:<span style="color:#a6e22e">TraitName</span><span style="color:#f92672">&gt;</span>(item: <span style="color:#a6e22e">T</span>) {
  
}

<span style="color:#75715e">//多种 Trait 结合
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">notify</span>(item: <span style="color:#a6e22e">impl</span> TraitName <span style="color:#f92672">+</span> Display) {
  
}
<span style="color:#75715e">//where clause
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">notify</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>(t: <span style="color:#a6e22e">T</span>, u: <span style="color:#a6e22e">U</span>) -&gt; <span style="color:#66d9ef">i32</span> 
	<span style="color:#a6e22e">where</span> T: <span style="color:#a6e22e">Display</span> <span style="color:#f92672">+</span> Clone,
				U: Clone <span style="color:#f92672">+</span> Debug
{
  
}
</code></pre></div><h3 id="trait-作为返回值">trait 作为返回值</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">notify</span>() -&gt; <span style="color:#a6e22e">impl</span> TraitName {
  
}
</code></pre></div><h2 id="reference-lifetime">reference lifetime</h2>
<p>每个引用的 lifetime , 即是它们的作用域. 大多数时候, lifetime 是隐含及推断的.</p>
<blockquote>
<p>它的主要目的是防止 dangling reference.</p>
</blockquote>
<p>lifetime annotation : 它并不改变一个引用能存活多久. 它只是描述了在多个 reference 之间的 lifetime 关系. 语法如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#f92672">&amp;</span><span style="color:#66d9ef">i32</span> , <span style="color:#960050;background-color:#1e0010">添加</span> lifetime annotation <span style="color:#960050;background-color:#1e0010">则为</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">i32</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> <span style="color:#ae81ff">32</span>
</code></pre></div><p>单个 reference 标注 lifetime 并没有多大意义. 因为 annotation 主要是告诉 Rust 在多个 reference 之间的 lifetime 关系.</p>
<h3 id="默认lifetime-rules">默认lifetime rules</h3>
<ul>
<li>每个reference 参数都有它们自己的 lifetime</li>
<li>如果仅有一个输入参数, 则输出(返回参数)的 lifetime 跟输入的一致.</li>
<li>如果有多个输入参数, 但其中之一是 <code>&amp;self</code> 或 <code>&amp;mut self</code> , 由于是 method, 则 <code>self</code> 的 lifetime 被应用于所有输出参数.</li>
</ul>
<h3 id="static-lifetime">static lifetime</h3>
<p>有个特殊的 lifetime anntion , 它就是 <code>'static</code> . 所有 string 字面量都是这种 lifetime .</p>
<h2 id="它们组合在一起">它们组合在一起</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest_with</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>, y:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>, ann: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span> <span style="color:#66d9ef">where</span> T: <span style="color:#a6e22e">Display</span> {
  println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;ann {}&#34;</span>, ann);
  <span style="color:#66d9ef">if</span> x.len() <span style="color:#f92672">&gt;</span> y.len() {
    x
  } <span style="color:#66d9ef">else</span> {
    y
  }
}
</code></pre></div><h1 id="自动化测试">自动化测试</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">mod</span> hello {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello {}&#34;</span>, s);
    }

    <span style="color:#66d9ef">mod</span> sub {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello in sub mod {}&#34;</span>, s);
            <span style="color:#66d9ef">super</span>::<span style="color:#66d9ef">super</span>::say_world_parent(s);
        }
    }
}

<span style="color:#66d9ef">use</span> hello::say_world <span style="color:#66d9ef">as</span> h;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world_parent</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    h(s);
}

<span style="color:#75715e">#[cfg(test)]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#75715e">#[test]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">testSay</span>() {
        <span style="color:#66d9ef">super</span>::hello::say_world(<span style="color:#e6db74">&#34;fuck the world&#34;</span>);
        assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
    }
}
</code></pre></div><p>测试命令</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 执行所有测试代码</span>
cargo test 

<span style="color:#75715e"># 控制并行数</span>
cargo test -- --test-threads<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 只执行特定测试方法</span>
cargo test 方法名

<span style="color:#75715e"># 执行显式指定属性的测试方法</span>
<span style="color:#75715e">#[cfg(test)]</span>
mod tests <span style="color:#f92672">{</span>
    <span style="color:#75715e">#[test]</span>
    fn testSay<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        super::hello::say_world<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fuck the world&#34;</span><span style="color:#f92672">)</span>;
        assert_eq!<span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> + 2, 5<span style="color:#f92672">)</span>;
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">#[test]</span>
    <span style="color:#75715e">#[ignore]</span>
    fn testSay2<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        super::hello::say_world<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fuck the world2&#34;</span><span style="color:#f92672">)</span>;
        assert_eq!<span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> + 2, 5<span style="color:#f92672">)</span>;
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
这时
cargo test -- --ignored 
则只会执行带有 <span style="color:#e6db74">`</span><span style="color:#75715e">#[ignore]` 属性的测试方法. 而普通 cargo test 则不会执行.</span>
</code></pre></div><h1 id="io">I/O</h1>
<h2 id="读取命令行参数">读取命令行参数</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;? =&gt; {:?}&#34;</span>, args);
}
<span style="color:#960050;background-color:#1e0010">注意</span>, args() <span style="color:#960050;background-color:#1e0010">如果包含有无效的</span> unicode <span style="color:#960050;background-color:#1e0010">则会导致</span> panic. <span style="color:#960050;background-color:#1e0010">如果想包含这种数据的话</span>, <span style="color:#960050;background-color:#1e0010">则要用</span> args_os() .
<span style="color:#960050;background-color:#1e0010">传递参数来运行</span>
cargo run hello world ,<span style="color:#960050;background-color:#1e0010">则输出如下</span>
   Compiling hello<span style="color:#f92672">-</span>rust v0.<span style="color:#ae81ff">1.0</span> (<span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>emacsist<span style="color:#f92672">/</span>Documents<span style="color:#f92672">/</span>rust<span style="color:#f92672">/</span>hello<span style="color:#f92672">-</span>rust)
    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.80</span>s
     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>hello<span style="color:#f92672">-</span>rust hello world<span style="color:#960050;background-color:#1e0010">`</span>
[<span style="color:#e6db74">&#34;target/debug/hello-rust&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>]
</code></pre></div><h1 id="函数式语言特征-iterator-与-closure">函数式语言特征: iterator 与 closure</h1>
<p>Closure : anonymous functions that can capture their environment . 即, 它可以捕获定义他们地方所有作用域的值.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> clo <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>num<span style="color:#f92672">|</span> {
  println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;in closure ....&#34;</span>);
  num
};
<span style="color:#75715e">//注意, let clo 表示 clo 包含匿名函数的定义, 则不是执行后的返回值.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//如果不指定参数类型, 则 Rust 以第一次调用时的为准. 
</span></code></pre></div><p>fn trait</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cache</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> T: Fn(<span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#66d9ef">u32</span> {
  exec: <span style="color:#a6e22e">T</span>,
  value: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>,
}
</code></pre></div><h2 id="捕获-environment">捕获 environment</h2>
<p>有三种方式, 对应函数参数的三种方式(take ownership, borrowing mutably, borrowing immutably). 三个 trait 如下</p>
<ul>
<li><code>FnOnce</code> : 将会 take ownership.</li>
<li><code>FnMut</code> : borrowing mutably</li>
<li><code>Fn</code> : borrowing immutably</li>
</ul>
<p>可以显式指定 move :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;
<span style="color:#66d9ef">let</span> clo <span style="color:#f92672">=</span> <span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>param<span style="color:#f92672">|</span> param <span style="color:#f92672">==</span> x
<span style="color:#960050;background-color:#1e0010">这时</span>, x <span style="color:#960050;background-color:#1e0010">的</span> ownership <span style="color:#66d9ef">move</span> <span style="color:#960050;background-color:#1e0010">到了</span> closure <span style="color:#960050;background-color:#1e0010">里了</span>. <span style="color:#960050;background-color:#1e0010">后面将不再有效</span>
</code></pre></div><h2 id="iterator">iterator</h2>
<blockquote>
<p>注意, iter().next() 返回的是 &amp;item</p>
</blockquote>
<p>所有 iterators 都是 lazy 的. 例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
<span style="color:#66d9ef">let</span> v2 <span style="color:#f92672">=</span> v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 这时 v2 是 Map 类型. 要调用 collect() 来消费 map 产生的 iter 
</span><span style="color:#75715e"></span>


<span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    <span style="color:#66d9ef">let</span> v2: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>).collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, v2);
}
</code></pre></div><p>它与 for 的性能: 在 Rust 中, 不用担心这些开销, iterator 与 for 几乎一样的.</p>
<h1 id="cargo">Cargo</h1>
<p>默认的 profile 是 <code>dev</code> : 它的默认优化级别是 0.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Cargo.toml 文件中

<span style="color:#f92672">[</span>profile.dev<span style="color:#f92672">]</span>
opt-level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#f92672">[</span>profile.release<span style="color:#f92672">]</span>
opt-level <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

</code></pre></div><p>文档化注释 <code>/// doc</code></p>
<p>workspace :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">tree .
.
├── Cargo.toml
├── hello
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── hello-lib
    ├── Cargo.toml
    └── src
        └── lib.rs

在 workspace 根目录执行命令
cargo build
   Compiling hello v0.1.0 <span style="color:#f92672">(</span>/private/tmp/work/hello<span style="color:#f92672">)</span>
   Compiling hello-lib v0.1.0 <span style="color:#f92672">(</span>/private/tmp/work/hello-lib<span style="color:#f92672">)</span>
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 1.82s
</code></pre></div><p>从 cargo.io 安装 binary: <code>cargo install xxx</code></p>
<h1 id="smart-pointer">smart pointer</h1>
<p> ## <code>Box&lt;T&gt;</code></p>
<p>用于指向在 heap 的数据. 它没有性能开销, 除了保存数据在 heap 而不是 stack 外.</p>
<h3 id="recursive-type">recursive type</h3>
<p>在编译时, Rust 需要知道一种类型要占多少空间. 如果在编译时不知道大小的类型, 它就是一个 <code>recursive type</code> , 即该值是它自身同一类型的另一个值的一部分. 但 Box 有大小, 所以可以用它来实现 recursive type.</p>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
  Cons(<span style="color:#66d9ef">i32</span>, List),
  Nil,
}

<span style="color:#66d9ef">use</span> List::{Cons,Nil};
<span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">1</span>, Cons(<span style="color:#ae81ff">2</span>, Cons(<span style="color:#ae81ff">3</span>, Nil)));
</code></pre></div><blockquote>
<p>上面代码编译不了. 因为 Rust 编译时不知道 List 的大小.</p>
</blockquote>
<p>借助 Box 就可以编译了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
  Cons(<span style="color:#66d9ef">i32</span>, Box<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
  Nil,
}

<span style="color:#66d9ef">use</span> List::{Cons,Nil};
<span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">1</span>, Box::new(Cons(<span style="color:#ae81ff">2</span>, Box::new(Cons(<span style="color:#ae81ff">3</span>, Box::new(Nil))))));
</code></pre></div><p>通过 <code>Deref</code> trait , 让 smark pointer 与普通 reference 一样.</p>
<p>通过实现 Deref trait , 允许你自定义 dereference operator, <code>*</code> .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);


<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Deref <span style="color:#66d9ef">for</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span> <span style="color:#f92672">=</span> T;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span> {
        <span style="color:#f92672">&amp;</span>self.<span style="color:#ae81ff">0</span>
    }
}

<span style="color:#960050;background-color:#1e0010">这时</span> 
<span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> MyBox(<span style="color:#ae81ff">13</span>);
<span style="color:#f92672">*</span>m <span style="color:#960050;background-color:#1e0010">等同于</span> <span style="color:#f92672">*</span>(m.deref())
</code></pre></div><h2 id="drop-trait">Drop trait</h2>
<p>当变量 owner 离开作用域时, Rust 会调用该变量的 <code>drop()</code> (如果有的话)来释放资源.</p>
<p>但该方法, 不允许显式调用. 例如 <code>o.drop();</code> . 但可以通过 <code>std::mem::drop</code> 来处理. <code>drop(o);</code></p>
<h2 id="rct"><code>Rc&lt;T&gt;</code></h2>
<p>变量默认是单个 ownership 的. 如果想开启多个 ownership, 则可使用该类型.</p>
<p>注意, 它只能用于单线程环境.</p>
<p>只增加引用计数: <code>Rc::clone(&amp;ref);</code> 如果调用 <code>ref.clone()</code> 这是deep copy 了</p>
<h2 id="refcellt"><code>RefCell&lt;T&gt;</code></h2>
<p>它不同用 <code>Box&lt;T&gt; </code> (编译期, compile time , 检查 borrow 规则), 而 <code>RefCell&lt;T&gt;</code> (运行期, runtime, 检查 borrow 规则)</p>
<p>它也只能用于单线程环境.</p>
<h2 id="概括">概括</h2>
<ul>
<li><code>Rc&lt;T&gt;</code> 允许同一份数据有多个 owner. 而 <code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 是 single owner</li>
<li><code>Box&lt;T&gt;</code> 允许 immutable 或 mutable borrow , 并且是在 compile time 检查. <code>Rc&lt;T&gt;</code> 只允许 immutable borrow  , 并且在 compile time 检查. <code>RefCell&lt;T&gt;</code> 允许 immutable 或 mutable borrow, 但是在 runtime 检查.</li>
<li>由于 <code>RefCell&lt;T&gt;</code> 允许 mutable borrow 并且在 runtime 才检查, 所以, 你可以更改在 <code>RefCell&lt;T&gt;</code> 的值, 即使 <code>RefCell&lt;T&gt;</code> 是 immutable 的也可以.</li>
</ul>
<h1 id="并发">并发</h1>
<p>在 Rust 的线程实现中, 与操作系统的是 <code>1:1</code> 模型.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::time::Duration;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    thread::spawn(<span style="color:#f92672">||</span> {
        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">10</span> {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hi {}, in thread&#34;</span>, i);
            thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
        }
    });
    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">5</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hi {}, in main&#34;</span>, i);
        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
    }
}

<span style="color:#75715e">//等待线程完成. hand 是 JoinHandle 类型.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::time::Duration;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> hand <span style="color:#f92672">=</span> thread::spawn(<span style="color:#f92672">||</span> {
        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">10</span> {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hi {}, in thread&#34;</span>, i);
            thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
        }
    });
    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">5</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hi {}, in main&#34;</span>, i);
        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
    }
    hand.join().unwrap();
}
</code></pre></div><h2 id="move-1">move</h2>
<blockquote>
<p>这样, 可以让某线程从另一条线程数据中 move ownership.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::time::Duration;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];

    <span style="color:#66d9ef">let</span> hand <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, v);
    });

    hand.join().unwrap();

    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">5</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hi {}, in main&#34;</span>, i);
        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
    }

}
</code></pre></div><h2 id="线程之间消息传递">线程之间消息传递</h2>
<blockquote>
<p>mpsc, multi producer, single consumer</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
<span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::time::Duration;
<span style="color:#66d9ef">use</span> std::sync::mpsc;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> mpsc::channel();
    thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
        <span style="color:#66d9ef">let</span> msg <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hi&#34;</span>);
        tx.send(msg).unwrap();
    });

    <span style="color:#66d9ef">let</span> recMsg <span style="color:#f92672">=</span> rx.recv().unwrap();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Got {}&#34;</span>, recMsg);
}

<span style="color:#75715e">//多个 tx
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> tx1 <span style="color:#f92672">=</span> mpsc::Sender::clone(<span style="color:#f92672">&amp;</span>tx);
</code></pre></div><h3 id="channel-与-ownership">channel 与 ownership</h3>
<p>在 <code>tx</code> 发送消息时 <code>send()</code> 函数会 take ownership , 即参数的 ownership 会 move , 然后被传送到 rx.</p>
<h2 id="mutex">Mutex</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::sync::Mutex;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> Mutex::new(<span style="color:#ae81ff">5</span>);

    {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num <span style="color:#f92672">=</span> m.lock().unwrap();
        <span style="color:#f92672">*</span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
    }
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, m);
}
</code></pre></div><h2 id="arct"><code>Arc&lt;T&gt;</code></h2>
<p>类似 <code>Rc&lt;T&gt;</code> , 但是线程安全的.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::sync::{Mutex, Arc};
<span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  	<span style="color:#75715e">//你可能已经看到, counter 是 immutable 的. 但后面却修改了它.
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">// 这意味着 Mutex&lt;T&gt; 提供了内部修改的能力. 类似 Cell 家族.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> counter <span style="color:#f92672">=</span> Arc::new(Mutex::new(<span style="color:#ae81ff">0</span>));

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span>..<span style="color:#ae81ff">10</span> {
        <span style="color:#66d9ef">let</span> counter <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>counter);
        <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num <span style="color:#f92672">=</span> counter.lock().unwrap();
            <span style="color:#f92672">*</span>num <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        });
        handles.push(handle);
    }

    <span style="color:#66d9ef">for</span> handle <span style="color:#66d9ef">in</span> handles {
        handle.join().unwrap();
    }
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, <span style="color:#f92672">*</span>counter.lock().unwrap());
}
</code></pre></div><blockquote>
<p>如果这里修改为 Rc , 则会导致编译错误.</p>
</blockquote>
<h1 id="oop">OOP</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">//定义 Object
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
  name: String,
  age: <span style="color:#66d9ef">u16</span>,
}

<span style="color:#75715e">//定义方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Person {
  <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">getName</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
    
  }
}

<span style="color:#75715e">// Trait 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Run {
  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self);
}

<span style="color:#75715e">//为 Person 实现 Run trait
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Run <span style="color:#66d9ef">for</span> Person {
  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
    <span style="color:#75715e">//code...
</span><span style="color:#75715e"></span>  }
}
</code></pre></div><h1 id="常见问题及解决">常见问题及解决</h1>
<h2 id="blocking-waiting-for-file-lock-on-package-cache">Blocking waiting for file lock on package cache</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">rm ~/.cargo/.package-cache
然后重新 cargo run 
</code></pre></div>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2019-08-27</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/rust/">rust</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2019/09/05/redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Redis最佳实践</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2019/08/23/linux-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">&lt;Linux 内核设计与实现&gt;笔记</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2019-08-27 11:13:20 \x2b0800 CST',
    title: '2019 Rust学习',
    link: decodeURI(location.href),
    desc: '准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
