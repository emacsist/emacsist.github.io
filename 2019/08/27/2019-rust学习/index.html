<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2019 Rust学习 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="2019 Rust学习" />
<meta property="og:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2019-08-27T11:13:20+08:00" />
<meta property="article:modified_time" content="2019-08-27T11:13:20+08:00" />
<meta itemprop="name" content="2019 Rust学习">
<meta itemprop="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl">


<meta itemprop="datePublished" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="dateModified" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="wordCount" content="7435">



<meta itemprop="keywords" content="rust," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2019 Rust学习"/>
<meta name="twitter:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2019 Rust学习</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-08-27 </span>
        
        <span class="more-meta"> 7435 words </span>
        <span class="more-meta"> 15 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#准备工作">准备工作</a>
<ul>
<li><a href="#rustup">rustup</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#本地文档">本地文档</a></li>
<li><a href="#删除">删除</a></li>
<li><a href="#自动补全">自动补全</a></li>
<li><a href="#更新">更新</a></li>
<li><a href="#安装其他版本">安装其他版本</a></li>
<li><a href="#替换-crate-源">替换 crate 源</a></li>
<li><a href="#cargo-常用命令">cargo 常用命令</a></li>
</ul></li>
<li><a href="#rust-概念">Rust 概念</a></li>
<li><a href="#ownership">Ownership</a>
<ul>
<li><a href="#rules">rules</a></li>
<li><a href="#stack-and-heap">stack and heap</a></li>
<li><a href="#变量与数据交互">变量与数据交互</a>
<ul>
<li><a href="#move">move</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#stack-only">stack only</a></li>
<li><a href="#copy-trait-的数据类型">copy trait 的数据类型</a></li>
</ul></li>
<li><a href="#ownership-与-function">ownership 与 function</a></li>
<li><a href="#references-and-borrowing">references and borrowing</a></li>
</ul></li>
<li><a href="#binary">binary</a></li>
<li><a href="#lib">lib</a></li>
<li><a href="#创建库">创建库</a></li>
<li><a href="#添加模块-修改-src-lib-rs-文件">添加模块. 修改 src/lib.rs 文件</a></li>
<li><a href="#注意-这个命名-要跟库项目中的-cargo-toml-中的-name-一致">注意 这个命名, 要跟库项目中的 Cargo.toml 中的 name 一致.</a></li>
<li><a href="#执行所有测试代码">执行所有测试代码</a></li>
<li><a href="#控制并行数">控制并行数</a></li>
<li><a href="#只执行特定测试方法">只执行特定测试方法</a></li>
<li><a href="#执行显式指定属性的测试方法">执行显式指定属性的测试方法</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="准备工作">准备工作</h1>

<h2 id="rustup">rustup</h2>

<p><a href="https://github.com/rust-lang/rustup.rs/blob/master/README.md">rustup github</a></p>

<blockquote>
<p>rustup 用于安装 Rust , 并可管理 rust 不同的版本(stable, beta, nightly) 并更新它们.</p>
</blockquote>

<p>rust 被安装在 <code>$HOME/.cargo/bin</code> 目录下.</p>

<p><code>cargo install</code> 安装的程序和插件, 同样也在上面的目录中.</p>

<h2 id="安装">安装</h2>

<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh

在当前窗口加载环境配置
source $HOME/.cargo/env
</code></pre>

<h2 id="本地文档">本地文档</h2>

<pre><code class="language-bash">rustup doc
</code></pre>

<h2 id="删除">删除</h2>

<p><code>rustup self uninstall</code></p>

<h2 id="自动补全">自动补全</h2>

<pre><code class="language-bash"># bash
rustup completions bash &gt; $(brew --prefix)/etc/bash_completion.d/rustup.bash-completion
# zsh
rustup completions zsh &gt; ~/.zfunc/_rustup
在 ~/.zshrc 文件中, 在 compinit 之前添加以下语句
fpath+=~/.zfunc
</code></pre>

<h2 id="更新">更新</h2>

<pre><code class="language-bash">rustup update

rustup self update
</code></pre>

<h2 id="安装其他版本">安装其他版本</h2>

<blockquote>
<p>rustup 安装 rust 时, 默认是 stable 版本</p>
</blockquote>

<pre><code class="language-bash"> # 安装 nightly 版本
 rustup toolchain install nightly
 # 运行 nightly 版本编译器
 rustup run nightly rustc --version
 # 切换默认版本为 nightly
 rustup default nightly
</code></pre>

<h2 id="替换-crate-源">替换 crate 源</h2>

<pre><code class="language-bash">vim  $HOME/.cargo/config
添加以下内容

[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>

<ul>
<li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates">https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates</a></li>
</ul>

<h2 id="cargo-常用命令">cargo 常用命令</h2>

<pre><code class="language-bash">cargo new project-name
cargo run
cargo build  --release

# 升级依赖. 成功后, 会更新 Cargo.lock 文件
cargo update

# 为你的项目及依赖生成文档
cargo doc --open
</code></pre>

<blockquote>
<p>Cargo.lock 文件是你第一次执行  <code>cargo build</code> 后输出的文件.</p>

<p>你的项目在其他人里编译时, 如果 cargo 发现有 Cargo.lock 文件, 则以该文件里的一切配置及版本为准来编译项目. 这方便重现你的项目.</p>
</blockquote>

<h1 id="rust-概念">Rust 概念</h1>

<ul>
<li><p>默认情况下, 变量是不可变的. <code>immutable by default</code></p>

<ul>
<li>要想使变量可变, 则要用 <code>mut</code> 来修饰.</li>
</ul></li>

<li><p>默认情况下, 引用也是不可变的. <code>references are immutable by default</code></p>

<ul>
<li>要想使引用可变, 则要 <code>&amp;mut</code> 来修饰</li>
</ul></li>

<li><p><code>immutable</code> 表示一旦绑定 <code>bind</code> 就不可以再改变其值.</p></li>

<li><p><code>Result</code> 是枚举类型. <code>Ok</code> 或 <code>Err</code> .</p></li>

<li><p><code>cargo</code> 文件 <code>Cargo.toml</code> 的版本写法 <code>rand = &quot;0.3.14&quot;</code> 等同于 <code>rand = &quot;^0.3.14&quot;</code> 表示任意兼容 <code>0.3.14</code> 版本 API 的版本即可.</p></li>

<li><p><code>crate</code> 表示库</p></li>

<li><p><code>trait</code> 表示接口</p></li>

<li><p><code>shadow</code> : 通常用于同一个变量名, 从一种类型切换到另一种类型.</p>

<ul>
<li><code>let x = 5; let x = x + 1;</code></li>
</ul></li>

<li><p><code>shadow</code> 与 <code>mut</code> 的区别</p>

<ul>
<li>如果没有 <code>let</code> 然后重新声明同样名的变量会编译错误. 通过 <code>let</code> 我们可以方便地从一个变量转变为  <code>immuable</code></li>
<li><code>let</code> 可以重用原来的变量名, 但类型可以不同. 而 <code>mut</code> 不可以.</li>
</ul></li>

<li><p>指定变量类型 <code>let var_name: var_type</code></p></li>

<li><p><code>_</code> : 特殊变量, 表示所有.</p></li>

<li><p><code>const</code> 与 <code>immutable</code> 的区别</p>

<ul>
<li><code>const</code> 不允许用 <code>mut</code> 修饰. 它是一直都不可变的.</li>
<li><code>const</code> 中, 类型必须显式指定</li>
<li><code>const</code> 可以在任何地方声明</li>
<li><code>const</code> 只允许 <code>const</code> 表达式赋值, 而不是一个函数调用或其他在 runtime 时计算出来的值.</li>
</ul></li>

<li><p>数据类型</p>

<ul>
<li><p>scalar : 表示一个单独的值. 有 4 种.</p></li>

<li><p>integer</p></li>
</ul>

<p>| length | signed                      | unsigned |
  | &mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&ndash; |
  | 8bit   | i8                          | u8       |
  | 16bit  | i16                         | u16      |
  | 32bit  | i32 (默认,即使是 64 位平台) | u32      |
  | 64bit  | i64                         | u64      |
  | 128bit | i128                        | u128     |
  | arch   | isize                       | usize    |</p>

<p>字面量</p>

<p>| 类型               | 示例       |
  | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;- |
  | 十进制             | 98_222     |
  | 十六进制           | 0xff       |
  | 八进制             | 0o77       |
  | 二进制             | 0b1111_000 |
  | 字节(仅限 u8 类型) | b&rsquo;A&rsquo;       |</p>

<p>溢出处理</p>

<p>Debug 模式: 会检测是否溢出. 然后产生 <code>panic</code> 退出.</p>

<p>Release 模式: 并不会检测溢出. 超出值范围的话, 会产生  <code>two's complement wrapping</code> .</p>

<ul>
<li>foating-point number</li>
</ul>

<p>| bit  | type       |
  | &mdash;- | &mdash;&mdash;&mdash;- |
  | 32   | f32        |
  | 64   | f64 (默认) |</p>

<ul>
<li><p>bool</p>

<ul>
<li>只有两个值 <code>false</code>, <code>true</code></li>
<li>大小为 <code>1 byte</code></li>
</ul></li>

<li><p>character</p>

<ul>
<li>使用单引用. 双引用的话是 String 类型.</li>
<li>它是 14 bytes`  大小.</li>
</ul></li>

<li><p>compound : 这可以组成多个值为一个类型. 有两种</p></li>

<li><p>tule</p>

<ul>
<li>可以由多种类型组合为一种.</li>
<li>它是固定长度. 一旦声明, 则不能改变大小.</li>
<li>声明: <code>let tup =(32, 6.4, 1)</code> . `  要获取值</li>
<li><code>let (x, y, z) = tup;</code> : 这种称为解构 <code>destructuring</code></li>
<li>也可以通过下标直接访问 <code>tup.0</code>, <code>tup.1</code> . 第一个索引的下标为 0.</li>
<li>元素不必是相同类型</li>
</ul></li>

<li><p>array</p>

<ul>
<li>固定长度.</li>
<li>声明 <code>let a = [1,2,3,4,5];</code></li>
<li><code>let a : [i32; 5] = [1,2,3,4,5];</code></li>
<li><code>let a = [3; 5]</code> . 表示元素全是 3, 一共 5 个.</li>
</ul></li>
</ul></li>

<li><p>函数</p>

<ul>
<li>风格 <code>fn hello_world()</code></li>
<li>参数 <code>fn hello_world(x:i32)</code> 参数中的类型是必填的</li>
<li>函数体. 包含许多 statement 以及结尾可选的 expression.</li>
<li><code>statement</code> :  执行一些动作, 但没有返回值.

<ul>
<li>比如函数声明</li>
<li><code>let</code></li>
</ul></li>
<li><code>expression</code> : 它会给出一个值.

<ul>
<li>调用函数</li>
<li>调用 macro</li>
<li><code>{}</code> 定义作用域: <code>let y = {let x = 3; x + 1}</code></li>
</ul></li>
<li>注意 <code>5+1</code> 是 expression. 但 <code>5+1;</code>  是 statement.</li>
<li><code>expression</code> 可以是 <code>statement</code> 的一部分.</li>
<li>注意, Rust 是一门 <code>expression-based</code> 的语言. 这跟其他的有很大的不同.</li>
<li>返回值</li>
<li><code>fn hello_world() -&gt; i32 {}</code></li>
<li>函数体最后一个 expression 就是函数的返回值.</li>
<li>多值(通过 tuple). <code>fn hello_world() -&gt; (i32, i32){}</code></li>
</ul></li>

<li><p>注释: <code>// your comment</code></p></li>

<li><p>控制流程</p>

<ul>
<li><code>if expression</code> 注意, 它是表达式来的.</li>
<li><code>if bool-expression {} else if bool-expression2 {} else {}</code></li>
<li>用在 <code>let</code> 中 : <code>let number = if condition {} else {};</code>

<ul>
<li>这时,  if 与 else 的 <code>expression</code> 结果, 都需要一致.</li>
</ul></li>
<li>循环</li>
<li><code>loop</code>

<ul>
<li>无限循环. <code>loop {}</code></li>
</ul></li>
<li><code>while</code>

<ul>
<li><code>while condition {}</code></li>
</ul></li>
<li><code>for</code>

<ul>
<li>遍历数组 <code>for e in arr.iter() {}</code></li>
<li><code>for number in (1..4).rev() {}</code></li>
</ul></li>
<li>中断循环 : <code>break;</code> 它是 <code>expression</code> . <code>break x * 2;</code> 表示中断, 并返回值 <code>x*2</code></li>
<li>继续循环 : <code>continue;</code></li>
</ul></li>
</ul>

<h1 id="ownership">Ownership</h1>

<h2 id="rules">rules</h2>

<ul>
<li>在 Rust 中的每个值都有一个称为 <code>owner</code> 的变量</li>
<li>同一时间, 只允许一个 <code>owner</code></li>
<li>当 <code>owner</code> 离开了作用域, 则这个 value 将被 drop 掉.

<ul>
<li>即 Rust 在变量离开作用域时, 自动调用 <code>drop</code> 函数来释放资源.</li>
</ul></li>
</ul>

<h2 id="stack-and-heap">stack and heap</h2>

<ul>
<li>Stack : 所有保存在 stack 的数据必须是编译期已知的, 固定大小的.</li>
<li>Heap : 编译期未知大小的或大小允许被改变的数据则存储在 heap.</li>
</ul>

<h2 id="变量与数据交互">变量与数据交互</h2>

<h3 id="move">move</h3>

<p>类似其他类型的 <code>shallow copy</code> , 在 Rust 中称为 <code>move</code> .</p>

<p>当一个变量 move 到另一个变量时, 则旧的变量将变成无效了. 即 ownership move 了.</p>

<h3 id="clone">clone</h3>

<p>类似其他类型的 <code>deep copy</code> ,  在 Rust 中是调用 <code>clone()</code> 方法. 开销比较大, 容易影响性能.</p>

<h3 id="stack-only">stack only</h3>

<p>在 stack 上的数据, 都是  <code>copy</code> . (即不会 move)</p>

<p>在 stack 中的数据, <code>shadow copy</code> 与 <code>deep copy</code> 是一样的.</p>

<blockquote>
<p>Rust 不允许在某个类型拥有 Drop trait  的添加 Copy trait .</p>
</blockquote>

<h3 id="copy-trait-的数据类型">copy trait 的数据类型</h3>

<ul>
<li>integer</li>
<li>bool</li>
<li>float point number</li>
<li>character</li>
<li>tuple 并且仅包含是  <code>copy trait</code> 的元素. 例如 <code>(i32, i32)</code> . 但 <code>(i32, String)</code> 则不是.</li>
</ul>

<h2 id="ownership-与-function">ownership 与 function</h2>

<p>从语义上说, 传递一个值给函数, 跟赋值给一个变量是同义的. 所以,传递一个变量给一个函数, 将会导致 <code>copy</code> 或 <code>move</code> , 像赋值那样子.</p>

<p>返回值也同样会 transer ownership .</p>

<h2 id="references-and-borrowing">references and borrowing</h2>

<p>可以通过 reference 一个对象作为参数, 而不是获取它的 ownership. (这称为  <code>borrowing</code> , 即函数参数是 reference , <code>&amp;</code> )</p>

<blockquote>
<p>注意,  <code>&amp;</code> 即 reference , 默认情况下也是 immutable 的.</p>

<p>要想 <code>&amp;</code> 即 reference 变成 muutable, 则要 <code>let mut s = String.from(&quot;hello&quot;);</code> 然后传递reference 时使用 <code>&amp;mut s</code> 即可(相应的函数参数也要指定为 <code>&amp;mut String</code></p>

<p>mutable 的 reference 有一个很大的限制, 即在同一个作用域内, 只允许一个 mutable reference . 比如下面这样子就不允许:</p>

<pre><code class="language-bash">&gt; let mut s = String.from(&quot;hello&quot;);
&gt; let r1 = &amp;mut s;
&gt; let r2 = &amp;mut s;
&gt; ```
&gt;
&gt; 也不允许 mutable reference 与 immutable reference 共存.
&gt;
&gt; 但可以允许多个 immutable reference 共存

</code></pre>

<p>rust
fn get_length(s:&amp;String) -&gt; usize {
  s.len()
}</p>

<pre><code>
下面这种则会获取 ownership . 这时  s 在调用完函数后会被 drop 掉.

</code></pre>

<p>rust
fn get_length(s:String) -&gt; usize {
  s.len()
}</p>

<pre><code>
### dangling reference

</code></pre>

<p>rust
fn main() {
    let s = no_dangle();
    println!(&ldquo;{}&rdquo;, s);
}
// 这个方法是 borrow, ownership 在 dangle() 方法内, 返回后, Rust 会释放 s 的内存. 导致 dangle reference, 所以在编译期就禁止了.
fn dangle() -&gt; &amp;String {
    let s = String::from(&ldquo;hello&rdquo;);
    &amp;s
}</p>
</blockquote>

<p>// 这个方法是 move, 即将 ownership 移出去, 这样子, Rust 就不会释放 s 的内存了
fn no_dangle() -&gt; String {
    let s = String::from(&ldquo;hello&rdquo;);
    s
}</p>

<pre><code>
### reference rule

- 在给定的任意时间, 要么只有一个 mutable reference 要么多个 immutable reference . 但不能共存.
- reference 必须总是有效的.

### slice type

&gt; slice 并不拥有 ownership



</code></pre>

<p>rust
let s = String::from(&ldquo;hello&rdquo;);
let slice = &amp;s[2..4];</p>

<pre><code>
返回 String slice

</code></pre>

<p>rust
fn hello_world(s : &amp;String) -&gt; &amp;str {
  &amp;s[..]
}</p>

<pre><code>
string 字面值

&gt; 所有 string 字面值, 都是 slice 类型. 即 `&amp;str` .  也意味着它是 immutable 的. 因为 reference 默认是 immutable 的.

其他类型的 slice

</code></pre>

<p>rust
let a = [1,2,3,4,5];
let slice = &amp;a[1..3]; // slice 是 &amp;[i32] 类型</p>

<pre><code>
# struct

## 定义

</code></pre>

<p>rust
struct User {
  name : String,
  email : String,
  active : bool,
}</p>

<pre><code>
## 实例化

</code></pre>

<p>rust
let user1 = User {
  name : String::from(&ldquo;yang&rdquo;),
  email : String::from(&ldquo;xx@qq.com&rdquo;),
  active : true,
};</p>

<p>// mutable
let mut user1 = User {
  name : String::from(&ldquo;yang&rdquo;),
  email : String::from(&ldquo;xx@qq.com&rdquo;),
  active : true,
};</p>

<pre><code>
&gt; 注意, 整个实例要么是 immutable, 要么是 mutable, Rust 不允许 struct 中部分字段是 mutable, 部分是 immutable

使用函数来初始化可以简化

</code></pre>

<p>rust
fn build_user(email : String, name : String) -&gt; User {
  User {
    email,
    name,
    active: true,
  }
}</p>

<pre><code>
&gt; 即函数参数跟成员同名即可.

使用旧的 struct 实例来初始化新的

</code></pre>

<p>rust
let user1 = User {
  name : String::from(&ldquo;yang&rdquo;),
  email : String::from(&ldquo;xx@qq.com&rdquo;),
  active : true,
};</p>

<p>let user2 = User {
  name : String::from(&ldquo;yang&rdquo;),
  email : String::from(&ldquo;xx@qq.com&rdquo;),
  ..user1
};</p>

<pre><code>
&gt; 这表示, user2 中除了 name, email 不同值之外, 其他成员字段值跟 user1一致.

## tuple struct

&gt; 类似 tuple, 但没有名字, 只有类型. 可以像 tuple 那样解构以及通过索引访问

</code></pre>

<p>rust
struct Color(i32, i32, i32);
struct Point(i32, i32);</p>

<pre><code>
## unit like struct

它没有任何成员. `()`

通常用于实现一个 trait, 但没有任何数据要存储到这个类型上.

## print

默认情况下, 自定义的 struct 类型并没有实现 `std::fmt::Display` 这个 trait . 所以当使用 `println!()` 来打印 struct 对象时会编译报错. 

可修改为 debug print

</code></pre>

<p>rust
#[derive(Debug)]
struct Are {
    width: u32,
    height: u32,
}</p>

<p>fn main() {
    let are = Are {
        width: 16,
        height: 16,
    };
    println!(&ldquo;are -&gt; {:?}&ldquo;, are);
}</p>

<pre><code>
&gt; 即 println! 中的 `{:?}` 表示使用 `#[derive(Debug)]`  的 trait 来显示.

## method

&gt; method 不完全同于 function. Method 是定义在 struct (或 enum, 或 trait 对象) 的上下文中的.
&gt;
&gt; Method 可以 move ownership (self), 或 borrow immutable (&amp;self) 或 borrow mutable  (&amp;mut self)
&gt;
&gt; Rust 在调用 method 的时候, 会自动将 struct 转换为 method 签名的类型.(如果兼容的话)

定义 method

</code></pre>

<p>rust
#[derive(Debug)]
struct Are {
    width: u32,
    height: u32,
}</p>

<p>// struct 允许有多个 impl .
impl Are {
    fn area(&amp;self) -&gt; u32 {
        self.height * self.width
    }
}</p>

<p>fn main() {
    let are = Are {
        width: 16,
        height: 16,
    };
    println!(&ldquo;are -&gt; {:?}&ldquo;, are.area());
}</p>

<pre><code>
Method 的第一个参数, 总是 `self` (可以为 `&amp;self` 或 `&amp;mut self`). 

## associated function

在 impl 语句块中的函数第一个参数不是 `self` 的函数, 即是  associated function. 它不是 method, 因为它不与实例关联. 

&gt; String::from 就是一个 associcated function

# enum 与 pattern matching

定义

</code></pre>

<p>rust
enum IP {
  V4,
  V6,
}
或
enum Message {
  Quit,
  Move {x: u32, y: u32},
  Write(String),
  Color(i32, i32, i32),
}</p>

<pre><code>
类似 struct, 也可以为 enum 添加 impl . 

&gt; Option enum. 
&gt;
&gt; Rust 中没有 null 这种特性.

match `expression` . 

</code></pre>

<p>rust
fn value_in_message(message: Message) -&gt; u8 {
  match message {
    Message::Quit =&gt; 1,
    Message::Move =&gt; 2,
    Message::Write =&gt; 3,
    Message::Color =&gt; 4,
  }
}</p>

<p>//绑定值
fn main() {
    println!(&ldquo;{:?}&ldquo;, plus_one(Some(32)));
}</p>

<p>fn plus_one(x : Option<i32>) -&gt; Option<i32> {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}</p>

<p>// 结合 if let. 它与 match 类似, 当 match 条件匹配时, 则执行某动作. 注意, if let xx 后面是 = 号, 而不是 ==
// 可以想象为 if let 是 match 语法糖, 它只执行 match 其中之一, 而忽略剩余其他的全部.
fn main() {
    let som = plus_one(Some(32));
    if let Some(33) = som {
        println!(&ldquo;33&rdquo;);
    }
}</p>

<p>fn plus_one(x : Option<i32>) -&gt; Option<i32> {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}</p>

<pre><code>
&gt; match 必须匹配所有情况. 特殊的 `_` 表示剩余所有情况.
&gt;
&gt; 因为 match 要匹配所有情况. 所以, 如果你只想处理其中之一的情况, 请记得用 if let 语法.



# Project manage

- Package
- Crates
- Modules 以及 use 
- Paths 

## package and crates

一个 crate 是一个 binary (`main.rs`) 或 lib. (`lib.rs`)

</code></pre>

<p>bash</p>

<h1 id="binary">binary</h1>

<p>cargo new project</p>

<h1 id="lib">lib</h1>

<p>cargo new &ndash;lib libname</p>

<pre><code>


一个 package 是一个或多个 crate. 一个 package 包含一个 `Cargo.toml` 文件描述如何构建这些 crate.  一个 package 可以包含 0 或至多一个 lib crate.

## module

</code></pre>

<p>bash</p>

<h1 id="创建库">创建库</h1>

<p>cargo new &ndash;lib mathlib</p>

<h1 id="添加模块-修改-src-lib-rs-文件">添加模块. 修改 src/lib.rs 文件</h1>

<p>mod hello {
    fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
    }
}
</code></pre>

<p>}</p>

<pre><code>
module tree 

</code></pre>

<p>bash
根据上面的情况, module tree 为
crate -&gt; hello -&gt; say_world
               -&gt; sub -&gt; say_world</p>

<pre><code>
## module 引用路径

- 绝对路径: 通过 crate 名字或以 `crate` 开头.
- 相对路径: 在当前模块中, 使用 `self` 或 `super` 或直接当前模块的标识符

</code></pre>

<p>rust
pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
    }
}
</code></pre>

<p>}</p>

<p>pub fn say_world(s: &amp;str) {
    hello::say_world(s);
}</p>

<pre><code>
&gt; 默认情况下, rust 所有东西(function, method, struct, enum, module, constant)都是 private 的.  要想导出路径, 则使用 pub 关键字. 

调用父模块的方法(每一次 super , 相当于目录的 ` ../`, 即上级目录)

</code></pre>

<p>rust
pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
        super::super::say_world_parent(s);
    }
}
</code></pre>

<p>}</p>

<p>pub fn say_world_parent(s: &amp;str) {
    hello::say_world(s);
}</p>

<pre><code>
## struct 与 enum 的 pub

注意, 在 struct 之前使用 `pub` 表示该 struct 是 pub 的, 但里面的字段仍然是 `private` 的. 但 enum 的话 如果 pub 了, 则所有都默认都是 pub 的.

## use 与 as

use : 导入路径.

</code></pre>

<p>rust
pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
        super::super::say_world_parent(s);
    }
}
</code></pre>

<p>}</p>

<p>use hello::say_world;</p>

<p>pub fn say_world_parent(s: &amp;str) {
    say_world(s);
}</p>

<pre><code>
其他用法

</code></pre>

<p>rust
use std::{com::Ordering, io};
use std::io::{self, Write};
use std::io::*;</p>

<pre><code>


as : 别名

</code></pre>

<p>rust
pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
        super::super::say_world_parent(s);
    }
}
</code></pre>

<p>}</p>

<p>use hello::say_world as h;</p>

<p>pub fn say_world_parent(s: &amp;str) {
    h(s);
}</p>

<pre><code>
## 将 lib 分离不同文件

</code></pre>

<p>bash
src/lib.rs
src/hello.rs</p>

<p>只要在 lib.rs 文件中使用
mod hello;
即可导入到 lib.rs 合并了.</p>

<pre><code>
## 使用本地库

`Cargo.toml`  文件修改:

</code></pre>

<p>bash
[dependencies]
rand = &ldquo;0.3.14&rdquo;</p>

<h1 id="注意-这个命名-要跟库项目中的-cargo-toml-中的-name-一致">注意 这个命名, 要跟库项目中的 Cargo.toml 中的 name 一致.</h1>

<p>mathlib = {path = &ldquo;../mathlib&rdquo;} # 这里指向库的根目录</p>

<pre><code>
使用

</code></pre>

<p>rust
use mathlib;</p>

<p>fn main() {
    mathlib::hello::say_world(&ldquo;fuck&rdquo;);
}</p>

<pre><code>
# 常用集合 Collections

&gt; 这些数据结构是保存在 heap 的.

## vector

&gt; 每个元素只能是同一种类型. 不过, 可以利用 enum 来持有其他类型.

</code></pre>

<p>rust
// 创建
fn main() {
    let v: Vec<i32> = Vec::new();
    let vv = vec![1, 2, 3];
}</p>

<p>// 添加/删除元素
fn main() {
    let mut v: Vec<i32> = Vec::new();
    v.push(13);
    println!(&ldquo;{:?}&ldquo;, v);
    v.remove(0);
    println!(&ldquo;{:?}&ldquo;, v);
}</p>

<p>//遍历
fn main() {
    let v = vec![1, 2, 3, 4];
    for i in &amp;v {
        println!(&ldquo;{}&rdquo;, i);
    }
}</p>

<pre><code>
&gt; 注意. 这里是用 `&amp;v` , 如果为 `v` , 则表示将 let v 的 ownership move 到 for 语句块了. 当结束时, v 就无效了, 即后面的代码不能再访问 v 了. 

## String

&gt; 它是 UTF8 encode 的.

</code></pre>

<p>rust
let mut s = String::new();</p>

<p>//修改
s.push_str(&ldquo;hello world&rdquo;);</p>

<p>//拼接 concat
fn main() {
    let s1 = String::from(&ldquo;hello &ldquo;);
    let s2 = String::from(&ldquo;world&rdquo;);
    let s3 = s1 + &s2;
    println!(&ldquo;{}&rdquo;, s3);
}
实际调用的方法签名伪代码为
fn add(self, s:&amp;str) -&gt; String {}</p>

<p>所以, 第一个参数(即 s1)的 ownership 已经 move 了. 之后的代码中, s1 不再有效. 由于 s2 只是借用而非 move, 所以 s2 仍然是 valid 的.</p>

<p>//拼接 2
fn main() {
    let s1 = String::from(&ldquo;hello &ldquo;);
    let s2 = String::from(&ldquo;world&rdquo;);
    let s3 = format!(&ldquo;{}{}&rdquo;, s1, s2);
    println!(&ldquo;s1 {}, s2 {}, s3 {}&rdquo;, s1, s2, s3);
}</p>

<p>//索引 String. Rust 的 String 不同于其他的编程语言可以直接根据下标来索引字符.
// Rust 的 String 内部是使用 Vec<u8> . 即 Vec<byte> 来保存的. 即字节 Vec
// String.len() 返回的是字节的长度, 而不是字符.
// Rust 中的 String 有三种表示. bytes, scalar values, grapheme clusters.
// Rust 不允许使用索引来引用 String 的另一个原因是, 索引操作预期是 O(1) 的, 但Rust 中的 String 并不能这样子, 只能从头到尾来决定字符是否有效.
// 允许使用索引的情况是返回值为 a byte, a character, a grapheme cluster 或 string slice.
&ldquo;hello&rdquo;.chars()
&ldquo;hello&rdquo;.bytes()
grapheme 比较复杂, 并没有在标准库中提供.</p>

<pre><code>
## HashMap

&gt; 类似 vector, Hashmap 保存在 heap. k 要同一类型. v 也要同一类型.

</code></pre>

<p>rust
use std::collections::HashMap;</p>

<p>fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from(&ldquo;hello&rdquo;), 10);
    scores.insert(String::from(&ldquo;world&rdquo;), 20);</p>

<pre><code>println!(&quot;{:?}&quot;, scores);
</code></pre>

<p>}</p>

<p>//通过两个 vec 来构建 HashMap
use std::collections::HashMap;</p>

<p>fn main() {
    let teams = vec![String::from(&ldquo;hello&rdquo;), String::from(&ldquo;world&rdquo;)];
    let scores = vec![10, 20];</p>

<pre><code>let m: HashMap&lt;_, _&gt; = teams.iter().zip(scores.iter()).collect();

println!(&quot;{:?}&quot;, m);
</code></pre>

<p>}</p>

<p>//遍历
for (k, v) in &amp;m {</p>

<p>}</p>

<pre><code>
### ownership

对于实现了 Copy trait 的, 例如 `i32` , 则值将 copy 到 HashMap, 而对于 owned value 的, 例如 `String`, 则 ownership 将会 move 到 HashMap. 例如

</code></pre>

<p>rust
use std::collections::HashMap;</p>

<p>fn main() {
    let h = String::from(&ldquo;hello&rdquo;);
    let w = String::from(&ldquo;world&rdquo;);</p>

<pre><code>let mut map = HashMap::new();
map.insert(h, w);

println!(&quot;{:?}&quot;, map);
//println!(&quot;h {}, w {}&quot;, h, w); h, w 的 ownership 已经 move 到 map 了, 所以 insert 之后, 这两个变量已经 invalid 了. 
</code></pre>

<p>}</p>

<pre><code>
&gt; 不过, 如果我们插入 reference 的话, 则 ownership 不会 move .
&gt;
&gt; 但这种情况下,  reference 的生命周期至少要与 hashMap 一样有效.

### 更新 hashmap

</code></pre>

<p>rust
		//直接覆盖
    let h = String::from(&ldquo;hello&rdquo;);
    let w = String::from(&ldquo;world&rdquo;);</p>

<pre><code>let mut map = HashMap::new();
map.insert(h, w);
map.insert(String::from(&quot;hello&quot;), String::from(&quot;new world&quot;));
</code></pre>

<p>		//只在 key 没有值的时候插入
		map.entry(String::from(&ldquo;newKey&rdquo;)).or_insert(String::from(&ldquo;fuck&rdquo;));</p>

<p>		//基于旧值更新. or_insert 实际返回的是 &amp;mut v, 这样子就可以修改这个值即可.
		let v = map.entry(xx).or_insert(yy);
		*v += 1;</p>

<pre><code>
### hash function

默认情况下 HashMap 使用的是 siphash 函数. 但它不是性能最快的, 但权衡了安全性. 如果你发现它不能满足的你性能要求, 可以指定其他的 hash function . 

# 错误处理

## 不可恢复的错误 panic

</code></pre>

<p>rust
panic!(&ldquo;crash message&hellip;&rdquo;);</p>

<pre><code>
当使用该宏时, 会打印 panic 信息, 然后 unwind 以及程序清理栈, 最后退出.

&gt; Unwinding 要执行许多工作. 一个可选的方式是立即 abort . 这会导致程序直接退出, 而不进行清理. (例如内存的释放交由操作系统来处理, 而不是程序自身).
&gt;
&gt; 如果你的程序binary文件想尽可能小, 则可以切换 panic 为 abort 处理模式. 在 Cargo.toml 文件中添加
&gt;
&gt; ```bash
&gt; [profile.release]
&gt; panic = 'abort'
&gt; ```

跟踪栈. (此时, debug symbols 必须要开启. `--release` 参数构建的 binanry 则没有)

</code></pre>

<p>bash
RUST_BACKTRACE=1 cargo run</p>

<pre><code>
## 可恢复错误 Result

</code></pre>

<p>rust</p>

<p>use std::fs::File;</p>

<p>fn main() {
    let f = File::open(&ldquo;hello.txt&rdquo;);
    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&ldquo;open file error {:?}&ldquo;, error);
        }
    };
}
//进一步处理不同的错误
use std::fs::File;
use std::io::ErrorKind;</p>

<p>fn main() {
    let f = File::open(&ldquo;hello.txt&rdquo;);
    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&ldquo;hello.txt&rdquo;) {
                Ok(file) =&gt; file,
                Err(err) =&gt; {
                    panic!(&ldquo;create file error {}&rdquo;, err);
                }
            },
            _ =&gt; {
                panic!(&ldquo;other error  {}&rdquo;, error);
            }
        }
    };
}</p>

<pre><code>
## 在 Error 中快速 panic

- `unwrap()` : 即如果 Result 是 Ok 则返回 Ok 持有的数据. 如果返回的是 Err 则调用 `panic!().` `let f = File::open(&quot;hello.txt&quot;).unwrap();`
- `expect(msg)` :  类似 unwrap, 但让我们选择 panic 输出的 message. 

## 传播 error

即将错误处理交由 caller 调用者来决定. 

</code></pre>

<p>rust
fn read_line() -&gt; Result<String, io::Error> {</p>

<p>}</p>

<pre><code>
快速传播 Error 操作符: `?`

</code></pre>

<p>rust
fn read_string() -&gt; Result<String, io::Error> {
    let mut f = File::open(&ldquo;hello.txt&rdquo;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    ok(s)
}</p>

<p>//简化调用
fn read_string() -&gt; Result<String, io::Error> {
  let mut s = String::new();
  File::open(&ldquo;hello.txt&rdquo;)?.read_to_string(&amp;mut s)?;
  Ok(s)
}
//再一步
use std::fs;</p>

<p>fn read_string() -&gt; Result<String, io::Error> {
	fs::read_to_string(&ldquo;hello.txt&rdquo;)
}</p>

<pre><code>
即在 `Result` 类型后添加 `?` .  如果返回 Ok, 则会继续执行. 否则 return 返回调用者. 

`?` 与 match 的区别是: `?` 会调用 `From trait` 的 `from` 函数, 该函数用于将 error 类型转换为另一个类型.

# 泛型, trait 以及生命周期

## 泛型函数

</code></pre>

<p>rust
fn largest<T>(list:&amp;[T]) -&gt; T {</p>

<p>}</p>

<pre><code>
## trait

&gt; 定义共享行为

</code></pre>

<p>rust
fn main() {
    let p = Person{};
    println!(&ldquo;{}&rdquo;, p.say_hello());
}</p>

<p>//定义一个 trait
pub trait TraitName {
    fn say_hello(&amp;self) -&gt; String;</p>

<p>	fn say_hello2(&amp;self) -&gt; String {
      //添加默认实现
      String::from(&ldquo;default value&rdquo;)
  	}
}</p>

<p>//为某类型实现 trait
struct Person {</p>

<p>}</p>

<p>impl TraitName for Person {
    fn say_hello(&amp;self) -&gt; String {
        String::from(&ldquo;hello world&rdquo;)
    }
}</p>

<pre><code>
### trait 作为参数

</code></pre>

<p>rust
pub fn notify(item: impl TraitName) {</p>

<p>}</p>

<p>//或
pub fn notify<T:TraitName>(item: T) {</p>

<p>}</p>

<p>//多种 Trait 结合
pub fn notify(item: impl TraitName + Display) {</p>

<p>}
//where clause
fn notify<T, U>(t: T, u: U) -&gt; i32
	where T: Display + Clone,
				U: Clone + Debug
{</p>

<p>}</p>

<pre><code>
### trait 作为返回值

</code></pre>

<p>rust
fn notify() -&gt; impl TraitName {</p>

<p>}</p>

<pre><code>
## reference lifetime

每个引用的 lifetime , 即是它们的作用域. 大多数时候, lifetime 是隐含及推断的. 

&gt; 它的主要目的是防止 dangling reference. 

lifetime annotation : 它并不改变一个引用能存活多久. 它只是描述了在多个 reference 之间的 lifetime 关系. 语法如下

</code></pre>

<p>rust
&amp;i32 , 添加 lifetime annotation 则为 &amp;&lsquo;a i32, &amp;&lsquo;a mut 32</p>

<pre><code>
单个 reference 标注 lifetime 并没有多大意义. 因为 annotation 主要是告诉 Rust 在多个 reference 之间的 lifetime 关系.

### 默认lifetime rules

- 每个reference 参数都有它们自己的 lifetime
- 如果仅有一个输入参数, 则输出(返回参数)的 lifetime 跟输入的一致.
- 如果有多个输入参数, 但其中之一是 `&amp;self` 或 `&amp;mut self` , 由于是 method, 则 `self` 的 lifetime 被应用于所有输出参数.

### static lifetime

有个特殊的 lifetime anntion , 它就是 `'static` . 所有 string 字面量都是这种 lifetime . 

## 它们组合在一起

</code></pre>

<p>rust
fn longest_with&lt;&lsquo;a, T&gt;(x: &amp;&lsquo;a str, y:&amp;&lsquo;a str, ann: T) -&gt; &amp;&lsquo;a str where T: Display {
  println!(&ldquo;ann {}&rdquo;, ann);
  if x.len() &gt; y.len() {
    x
  } else {
    y
  }
}</p>

<pre><code>
# 自动化测试

</code></pre>

<p>rust
pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&ldquo;hello {}&rdquo;, s);
    }</p>

<pre><code>mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
        super::super::say_world_parent(s);
    }
}
</code></pre>

<p>}</p>

<p>use hello::say_world as h;</p>

<p>pub fn say_world_parent(s: &amp;str) {
    h(s);
}</p>

<p>#[cfg(test)]
mod tests {
    #[test]
    fn testSay() {
        super::hello::say_world(&ldquo;fuck the world&rdquo;);
        assert_eq!(2 + 2, 5);
    }
}</p>

<pre><code>
测试命令

</code></pre>

<p>bash</p>

<h1 id="执行所有测试代码">执行所有测试代码</h1>

<p>cargo test</p>

<h1 id="控制并行数">控制并行数</h1>

<p>cargo test &ndash; &ndash;test-threads=1</p>

<h1 id="只执行特定测试方法">只执行特定测试方法</h1>

<p>cargo test 方法名</p>

<h1 id="执行显式指定属性的测试方法">执行显式指定属性的测试方法</h1>

<p>#[cfg(test)]
mod tests {
    #[test]
    fn testSay() {
        super::hello::say_world(&ldquo;fuck the world&rdquo;);
        assert_eq!(2 + 2, 5);
    }</p>

<pre><code>#[test]
#[ignore]
fn testSay2() {
    super::hello::say_world(&quot;fuck the world2&quot;);
    assert_eq!(2 + 2, 5);
}
</code></pre>

<p>}
这时
cargo test &ndash; &ndash;ignored
则只会执行带有 <code>#[ignore]</code> 属性的测试方法. 而普通 cargo test 则不会执行.</p>

<pre><code>
# I/O

## 读取命令行参数

</code></pre>

<p>rust
use std::env;</p>

<p>fn main() {
    let args: Vec<String> = env::args().collect();
    println!(&ldquo;? =&gt; {:?}&ldquo;, args);
}
注意, args() 如果包含有无效的 unicode 则会导致 panic. 如果想包含这种数据的话, 则要用 args_os() .
传递参数来运行
cargo run hello world ,则输出如下
   Compiling hello-rust v0.1.0 (/Users/emacsist/Documents/rust/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.80s
     Running <code>target/debug/hello-rust hello world</code>
[&ldquo;target/debug/hello-rust&rdquo;, &ldquo;hello&rdquo;, &ldquo;world&rdquo;]</p>

<pre><code>
# 函数式语言特征: iterator 与 closure

Closure : anonymous functions that can capture their environment . 即, 它可以捕获定义他们地方所有作用域的值.

</code></pre>

<p>rust
let clo = |num| {
  println!(&ldquo;in closure &hellip;.&rdquo;);
  num
};
//注意, let clo 表示 clo 包含匿名函数的定义, 则不是执行后的返回值.</p>

<p>//如果不指定参数类型, 则 Rust 以第一次调用时的为准.</p>

<pre><code>
fn trait

</code></pre>

<p>rust
struct Cache<T> where T: Fn(u32) -&gt; u32 {
  exec: T,
  value: Option<u32>,
}</p>

<pre><code>
## 捕获 environment

有三种方式, 对应函数参数的三种方式(take ownership, borrowing mutably, borrowing immutably). 三个 trait 如下

- `FnOnce` : 将会 take ownership. 
- `FnMut` : borrowing mutably
- `Fn` : borrowing immutably

可以显式指定 move : 

</code></pre>

<p>rust
let x = 32;
let clo = move |param| param == x
这时, x 的 ownership move 到了 closure 里了. 后面将不再有效</p>

<pre><code>
## iterator

&gt; 注意, iter().next() 返回的是 &amp;item 

所有 iterators 都是 lazy 的. 例如

</code></pre>

<p>rust
let v1 = vec![1,2,3];
let v2 = v1.iter().map(|x| x + 1); // 这时 v2 是 Map 类型. 要调用 collect() 来消费 map 产生的 iter</p>

<p>use std::env;
fn main() {
    let v1 = vec![1, 2, 3];
    let v2: Vec<i32> = v1.iter().map(|x| x + 1).collect();
    println!(&ldquo;{:?}&ldquo;, v2);
}</p>

<pre><code>
它与 for 的性能: 在 Rust 中, 不用担心这些开销, iterator 与 for 几乎一样的.

# Cargo

默认的 profile 是 `dev` : 它的默认优化级别是 0. 

</code></pre>

<p>bash
Cargo.toml 文件中</p>

<p>[profile.dev]
opt-level = 0</p>

<p>[profile.release]
opt-level = 3</p>

<pre><code>
文档化注释 `/// doc`

workspace : 

</code></pre>

<p>bash
tree .
.
├── Cargo.toml
├── hello
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── hello-lib
    ├── Cargo.toml
    └── src
        └── lib.rs</p>

<p>在 workspace 根目录执行命令
cargo build
   Compiling hello v0.1.0 (/private/tmp/work/hello)
   Compiling hello-lib v0.1.0 (/private/tmp/work/hello-lib)
    Finished dev [unoptimized + debuginfo] target(s) in 1.82s</p>

<pre><code>
从 cargo.io 安装 binary: `cargo install xxx`

# smart pointer

 ## `Box&lt;T&gt;`

用于指向在 heap 的数据. 它没有性能开销, 除了保存数据在 heap 而不是 stack 外.

### recursive type

在编译时, Rust 需要知道一种类型要占多少空间. 如果在编译时不知道大小的类型, 它就是一个 `recursive type` , 即该值是它自身同一类型的另一个值的一部分. 但 Box 有大小, 所以可以用它来实现 recursive type.

例如

</code></pre>

<p>rust
enum List {
  Cons(i32, List),
  Nil,
}</p>

<p>use List::{Cons,Nil};
let list = Cons(1, Cons(2, Cons(3, Nil)));</p>

<pre><code>
&gt; 上面代码编译不了. 因为 Rust 编译时不知道 List 的大小.

借助 Box 就可以编译了

</code></pre>

<p>rust
enum List {
  Cons(i32, Box<List>),
  Nil,
}</p>

<p>use List::{Cons,Nil};
let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));</p>

<pre><code>


通过 `Deref` trait , 让 smark pointer 与普通 reference 一样. 

通过实现 Deref trait , 允许你自定义 dereference operator, `*` . 

</code></pre>

<p>rust
struct MyBox<T>(T);</p>

<p>impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}</p>

<p>这时
let m = MyBox(13);
*m 等同于 *(m.deref())</p>

<pre><code>


## Drop trait

当变量 owner 离开作用域时, Rust 会调用该变量的 `drop()` (如果有的话)来释放资源.

但该方法, 不允许显式调用. 例如 `o.drop();` . 但可以通过 `std::mem::drop` 来处理. `drop(o);`

## `Rc&lt;T&gt;`

变量默认是单个 ownership 的. 如果想开启多个 ownership, 则可使用该类型. 

注意, 它只能用于单线程环境.

只增加引用计数: `Rc::clone(&amp;ref);` 如果调用 `ref.clone()` 这是deep copy 了

## `RefCell&lt;T&gt;`

它不同用 `Box&lt;T&gt; ` (编译期, compile time , 检查 borrow 规则), 而 `RefCell&lt;T&gt;` (运行期, runtime, 检查 borrow 规则)

它也只能用于单线程环境.

## 概括

- `Rc&lt;T&gt;` 允许同一份数据有多个 owner. 而 `Box&lt;T&gt;` 和 `RefCell&lt;T&gt;` 是 single owner
- `Box&lt;T&gt;` 允许 immutable 或 mutable borrow , 并且是在 compile time 检查. `Rc&lt;T&gt;` 只允许 immutable borrow  , 并且在 compile time 检查. `RefCell&lt;T&gt;` 允许 immutable 或 mutable borrow, 但是在 runtime 检查.
- 由于 `RefCell&lt;T&gt;` 允许 mutable borrow 并且在 runtime 才检查, 所以, 你可以更改在 `RefCell&lt;T&gt;` 的值, 即使 `RefCell&lt;T&gt;` 是 immutable 的也可以.

# 并发

在 Rust 的线程实现中, 与操作系统的是 `1:1` 模型.

</code></pre>

<p>rust
use std::thread;
use std::time::Duration;</p>

<p>fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&ldquo;hi {}, in thread&rdquo;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!(&ldquo;hi {}, in main&rdquo;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</p>

<p>//等待线程完成. hand 是 JoinHandle 类型.
use std::thread;
use std::time::Duration;</p>

<p>fn main() {
    let hand = thread::spawn(|| {
        for i in 1..10 {
            println!(&ldquo;hi {}, in thread&rdquo;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!(&ldquo;hi {}, in main&rdquo;, i);
        thread::sleep(Duration::from_millis(1));
    }
    hand.join().unwrap();
}</p>

<pre><code>
##  move

&gt; 这样, 可以让某线程从另一条线程数据中 move ownership.

</code></pre>

<p>rust
use std::thread;
use std::time::Duration;</p>

<p>fn main() {</p>

<pre><code>let v = vec![1, 2, 3];

let hand = thread::spawn(move || {
    println!(&quot;{:?}&quot;, v);
});

hand.join().unwrap();

for i in 1..5 {
    println!(&quot;hi {}, in main&quot;, i);
    thread::sleep(Duration::from_millis(1));
}
</code></pre>

<p>}</p>

<pre><code>
## 线程之间消息传递

&gt; mpsc, multi producer, single consumer

</code></pre>

<p>rust</p>

<p>use std::thread;
use std::time::Duration;
use std::sync::mpsc;</p>

<p>fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let msg = String::from(&ldquo;hi&rdquo;);
        tx.send(msg).unwrap();
    });</p>

<pre><code>let recMsg = rx.recv().unwrap();
println!(&quot;Got {}&quot;, recMsg);
</code></pre>

<p>}</p>

<p>//多个 tx
let tx1 = mpsc::Sender::clone(&amp;tx);</p>

<pre><code>
### channel 与 ownership

在 `tx` 发送消息时 `send()` 函数会 take ownership , 即参数的 ownership 会 move , 然后被传送到 rx.

## Mutex

</code></pre>

<p>rust
use std::sync::Mutex;</p>

<p>fn main() {
    let m = Mutex::new(5);</p>

<pre><code>{
    let mut num = m.lock().unwrap();
    *num = 6;
}
println!(&quot;{:?}&quot;, m);
</code></pre>

<p>}</p>

<pre><code>
## `Arc&lt;T&gt;`

类似 `Rc&lt;T&gt;` , 但是线程安全的. 

</code></pre>

<p>rust
use std::sync::{Mutex, Arc};
use std::thread;
use std::rc::Rc;</p>

<p>fn main() {
  	//你可能已经看到, counter 是 immutable 的. 但后面却修改了它.
  	// 这意味着 Mutex<T> 提供了内部修改的能力. 类似 Cell 家族.
    let counter = Arc::new(Mutex::new(0));</p>

<pre><code>let mut handles = vec![];
for _ in 1..10 {
    let counter = Arc::clone(&amp;counter);
    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
println!(&quot;{:?}&quot;, *counter.lock().unwrap());
</code></pre>

<p>}</p>

<pre><code>
&gt; 如果这里修改为 Rc , 则会导致编译错误.

# OOP

</code></pre>

<p>rust
//定义 Object
pub struct Person {
  name: String,
  age: u16,
}</p>

<p>//定义方法
impl Person {
  pub fn getName(&amp;self) -&gt; &amp;str {</p>

<p>}
}</p>

<p>// Trait
pub trait Run {
  fn run(&amp;self);
}</p>

<p>//为 Person 实现 Run trait
impl Run for Person {
  fn run(&amp;self) {
    //code&hellip;
  }
}</p>

<pre><code>


# 常见问题及解决

## Blocking waiting for file lock on package cache

</code></pre>

<p>bash
rm ~/.cargo/.package-cache
然后重新 cargo run
```</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2019-08-27</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/rust/">rust</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2019/09/05/redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Redis最佳实践</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2019/08/23/linux-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">&lt;Linux 内核设计与实现&gt;笔记</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2019-08-27 11:13:20 \x2b0800 CST',
    title: '2019 Rust学习',
    link: decodeURI(location.href),
    desc: '准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
