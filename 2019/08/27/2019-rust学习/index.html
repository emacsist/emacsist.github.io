<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2019 Rust学习 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.57.0" />


<link rel="canonical" href="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="2019 Rust学习" />
<meta property="og:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2019/08/27/2019-rust%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2019-08-27T11:13:20+08:00" />
<meta property="article:modified_time" content="2019-08-27T11:13:20+08:00" />
<meta itemprop="name" content="2019 Rust学习">
<meta itemprop="description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl">


<meta itemprop="datePublished" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="dateModified" content="2019-08-27T11:13:20&#43;08:00" />
<meta itemprop="wordCount" content="10911">



<meta itemprop="keywords" content="rust," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2019 Rust学习"/>
<meta name="twitter:description" content="准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2019 Rust学习</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-08-27 </span>
        
        <span class="more-meta"> 10911 words </span>
        <span class="more-meta"> 22 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#准备工作">准备工作</a>
<ul>
<li><a href="#rustup">rustup</a></li>
<li><a href="#安装-nightly-版本">安装 nightly 版本</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#本地文档">本地文档</a></li>
<li><a href="#删除">删除</a></li>
<li><a href="#自动补全">自动补全</a></li>
<li><a href="#更新">更新</a></li>
<li><a href="#安装其他版本">安装其他版本</a></li>
<li><a href="#替换-crate-源">替换 crate 源</a></li>
<li><a href="#cargo-常用命令">cargo 常用命令</a></li>
<li><a href="#rust-项目的命名风格">Rust 项目的命名风格</a></li>
</ul></li>
<li><a href="#项目结构">项目结构</a>
<ul>
<li><a href="#可见性">可见性</a></li>
</ul></li>
<li><a href="#变量与绑定">变量与绑定</a>
<ul>
<li><a href="#求值上下文">求值上下文</a></li>
<li><a href="#所有权与引用">所有权与引用</a></li>
<li><a href="#变量的生命周期">变量的生命周期</a></li>
<li><a href="#闭包">闭包</a></li>
</ul></li>
<li><a href="#println-宏"><code>println!</code> 宏</a></li>
<li><a href="#rust-概念">Rust 概念</a>
<ul>
<li><a href="#数据类型">数据类型</a>
<ul>
<li><a href="#scalar">scalar</a>
<ul>
<li><a href="#integer">integer</a></li>
<li><a href="#foating-point-number">foating-point number</a></li>
<li><a href="#bool">bool</a></li>
<li><a href="#character">character</a></li>
</ul></li>
<li><a href="#compound-这可以组成多个值为一个类型-有两种">compound : 这可以组成多个值为一个类型. 有两种</a>
<ul>
<li><a href="#tule">tule</a></li>
<li><a href="#array">array</a></li>
</ul></li>
</ul></li>
<li><a href="#string">String</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#控制流程">控制流程</a></li>
</ul></li>
<li><a href="#值语义和引用语义">值语义和引用语义</a>
<ul>
<li><a href="#所有权机制">所有权机制</a>
<ul>
<li><a href="#闭包-1">闭包</a></li>
<li><a href="#所有权借用">所有权借用</a></li>
</ul></li>
<li><a href="#检查是复制语义还是移动语义">检查是复制语义还是移动语义</a></li>
</ul></li>
<li><a href="#ownership">Ownership</a>
<ul>
<li><a href="#rules">rules</a></li>
<li><a href="#stack-and-heap">stack and heap</a></li>
<li><a href="#变量与数据交互">变量与数据交互</a>
<ul>
<li><a href="#move">move</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#stack-only">stack only</a></li>
<li><a href="#copy-trait-的数据类型">copy trait 的数据类型</a></li>
</ul></li>
<li><a href="#ownership-与-function">ownership 与 function</a></li>
<li><a href="#references-and-borrowing">references and borrowing</a>
<ul>
<li><a href="#dangling-reference">dangling reference</a></li>
<li><a href="#reference-rule">reference rule</a></li>
<li><a href="#slice-type">slice type</a></li>
</ul></li>
</ul></li>
<li><a href="#struct">struct</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#实例化">实例化</a></li>
<li><a href="#tuple-struct">tuple struct</a></li>
<li><a href="#unit-like-struct">unit like struct</a></li>
<li><a href="#print">print</a></li>
<li><a href="#method">method</a></li>
<li><a href="#associated-function">associated function</a></li>
</ul></li>
<li><a href="#enum-与-pattern-matching">enum 与 pattern matching</a></li>
<li><a href="#project-manage">Project manage</a>
<ul>
<li><a href="#package-and-crates">package and crates</a></li>
<li><a href="#module">module</a></li>
<li><a href="#module-引用路径">module 引用路径</a></li>
<li><a href="#struct-与-enum-的-pub">struct 与 enum 的 pub</a></li>
<li><a href="#use-与-as">use 与 as</a></li>
<li><a href="#将-lib-分离不同文件">将 lib 分离不同文件</a></li>
<li><a href="#使用本地库">使用本地库</a></li>
<li><a href="#使用同一项目中其他目录的模块">使用同一项目中其他目录的模块</a></li>
</ul></li>
<li><a href="#常用集合-collections">常用集合 Collections</a>
<ul>
<li><a href="#vector">vector</a></li>
<li><a href="#string-1">String</a></li>
<li><a href="#hashmap">HashMap</a>
<ul>
<li><a href="#ownership-1">ownership</a></li>
<li><a href="#更新-hashmap">更新 hashmap</a></li>
<li><a href="#hash-function">hash function</a></li>
</ul></li>
</ul></li>
<li><a href="#错误处理">错误处理</a>
<ul>
<li><a href="#不可恢复的错误-panic">不可恢复的错误 panic</a></li>
<li><a href="#可恢复错误-result">可恢复错误 Result</a></li>
<li><a href="#在-error-中快速-panic">在 Error 中快速 panic</a></li>
<li><a href="#传播-error">传播 error</a></li>
</ul></li>
<li><a href="#泛型-trait-以及生命周期">泛型, trait 以及生命周期</a>
<ul>
<li><a href="#泛型函数">泛型函数</a></li>
<li><a href="#trait">trait</a>
<ul>
<li><a href="#trait-作为参数">trait 作为参数</a></li>
<li><a href="#trait-作为返回值">trait 作为返回值</a></li>
</ul></li>
<li><a href="#reference-lifetime">reference lifetime</a>
<ul>
<li><a href="#默认lifetime-rules">默认lifetime rules</a></li>
<li><a href="#static-lifetime">static lifetime</a></li>
<li><a href="#生命周期参数">生命周期参数</a>
<ul>
<li><a href="#显式生命周期">显式生命周期</a></li>
<li><a href="#生命周期省略规则">生命周期省略规则</a></li>
</ul></li>
</ul></li>
<li><a href="#它们组合在一起">它们组合在一起</a></li>
</ul></li>
<li><a href="#自动化测试">自动化测试</a>
<ul>
<li><a href="#性能测试">性能测试</a></li>
</ul></li>
<li><a href="#i-o">I/O</a>
<ul>
<li><a href="#读取命令行参数">读取命令行参数</a></li>
</ul></li>
<li><a href="#函数式语言特征-iterator-与-closure">函数式语言特征: iterator 与 closure</a>
<ul>
<li><a href="#捕获-environment">捕获 environment</a></li>
<li><a href="#iterator">iterator</a></li>
</ul></li>
<li><a href="#cargo">Cargo</a></li>
<li><a href="#smart-pointer">smart pointer</a>
<ul>
<li><a href="#box-t"><code>Box&lt;T&gt;</code></a>
<ul>
<li><a href="#recursive-type">recursive type</a></li>
</ul></li>
<li><a href="#drop-trait">Drop trait</a></li>
<li><a href="#rc-t"><code>Rc&lt;T&gt;</code></a></li>
<li><a href="#refcell-t"><code>RefCell&lt;T&gt;</code></a></li>
<li><a href="#概括">概括</a></li>
</ul></li>
<li><a href="#并发">并发</a>
<ul>
<li><a href="#move-1">move</a></li>
<li><a href="#线程之间消息传递">线程之间消息传递</a>
<ul>
<li><a href="#channel-与-ownership">channel 与 ownership</a></li>
</ul></li>
<li><a href="#mutex">Mutex</a></li>
<li><a href="#arc-t"><code>Arc&lt;T&gt;</code></a></li>
</ul></li>
<li><a href="#oop">OOP</a></li>
<li><a href="#常见问题及解决">常见问题及解决</a>
<ul>
<li><a href="#blocking-waiting-for-file-lock-on-package-cache">Blocking waiting for file lock on package cache</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="准备工作">准备工作</h1>

<h2 id="rustup">rustup</h2>

<p><a href="https://github.com/rust-lang/rustup.rs/blob/master/README.md">rustup github</a></p>

<blockquote>
<p>rustup 用于安装 Rust , 并可管理 rust 不同的版本(stable, beta, nightly) 并更新它们.</p>
</blockquote>

<p>rust 被安装在 <code>$HOME/.cargo/bin</code> 目录下.</p>

<p><code>cargo install</code> 安装的程序和插件, 同样也在上面的目录中.</p>

<h2 id="安装-nightly-版本">安装 nightly 版本</h2>

<pre><code class="language-bash">rustup toolchain install nightly

# 只运行
rustup run nightly rustc --version

# 切换默认为 nightly
rustup default nightly
</code></pre>

<h2 id="安装">安装</h2>

<p><a href="https://rustup.rs/">https://rustup.rs/</a></p>

<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh

#在当前窗口加载环境配置
source $HOME/.cargo/env
</code></pre>

<h2 id="本地文档">本地文档</h2>

<pre><code class="language-bash">rustup doc
</code></pre>

<h2 id="删除">删除</h2>

<p><code>rustup self uninstall</code></p>

<h2 id="自动补全">自动补全</h2>

<pre><code class="language-bash"># bash
rustup completions bash &gt; $(brew --prefix)/etc/bash_completion.d/rustup.bash-completion
# zsh
rustup completions zsh &gt; ~/.zfunc/_rustup
在 ~/.zshrc 文件中, 在 compinit 之前添加以下语句
fpath+=~/.zfunc
</code></pre>

<h2 id="更新">更新</h2>

<pre><code class="language-bash">rustup update

rustup self update
</code></pre>

<h2 id="安装其他版本">安装其他版本</h2>

<blockquote>
<p>rustup 安装 rust 时, 默认是 stable 版本</p>
</blockquote>

<pre><code class="language-bash"> # 安装 nightly 版本
 rustup toolchain install nightly
 # 运行 nightly 版本编译器
 rustup run nightly rustc --version
 # 切换默认版本为 nightly
 rustup default nightly
</code></pre>

<h2 id="替换-crate-源">替换 crate 源</h2>

<pre><code class="language-bash">vim ~/.zshrc

export RUSTUP_DIST_SERVER=&quot;https://mirrors.ustc.edu.cn/rust-static&quot;
export RUSTUP_UPDATE_ROOT=&quot;https://mirrors.ustc.edu.cn/rust-static/rustup&quot;
</code></pre>

<pre><code class="language-bash">vim  $HOME/.cargo/config
添加以下内容

[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>

<ul>
<li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates">https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates</a></li>
</ul>

<h2 id="cargo-常用命令">cargo 常用命令</h2>

<pre><code class="language-bash">cargo new project-name
cargo run
cargo build  --release

# 升级依赖. 成功后, 会更新 Cargo.lock 文件
cargo update

# 为你的项目及依赖生成文档
cargo doc --open
</code></pre>

<blockquote>
<p>Cargo.lock 文件是你第一次执行  <code>cargo build</code> 后输出的文件.</p>

<p>你的项目在其他人里编译时, 如果 cargo 发现有 Cargo.lock 文件, 则以该文件里的一切配置及版本为准来编译项目. 这方便重现你的项目.</p>
</blockquote>

<h2 id="rust-项目的命名风格">Rust 项目的命名风格</h2>

<ul>
<li>小写字母 + 下划线</li>
</ul>

<h1 id="项目结构">项目结构</h1>

<p>在同一项目中编写自己的模块时, 可以这样子使用</p>

<p><code>hello.rs</code> :</p>

<pre><code class="language-rust">pub fn say_hello(hello: &amp;str) {
    println!(&quot;\nhelo {}&quot;, hello);
}
</code></pre>

<p><code>main.rs</code> :</p>

<pre><code class="language-rust">mod hello;
use hello::say_hello;

fn main() {
    say_hello(&quot; world&quot;);
}
</code></pre>

<pre><code class="language-bash">src
├── hello.rs
└── main.rs
</code></pre>

<h2 id="可见性">可见性</h2>

<ul>
<li>如果不显示使用pub声明，则函数或模块的可见性默认为私有的。</li>
<li><code>pub</code>，可以对外暴露公共接口，隐藏内部实现细节。</li>
<li><code>pub（crate）</code>，对整个crate可见。</li>
<li><code>pub（in Path）</code>，其中Path是模块路径，表示可以通过此Path路径来限定可见范围。</li>
<li><code>pub（self）</code>，等价于pub（in self），表示只限当前模块可见。</li>
<li><code>pub（super）</code>，等价于pub（in super），表示在当前模块和父模块中可见。</li>
</ul>

<h1 id="变量与绑定">变量与绑定</h1>

<p>Rust 中的表达式一般可以分为位置表达式（ <code>Place Expression</code>）和值表达式（ <code>ValueExpression</code>）。在其他语言中，一般叫作左值（<code>LValue</code>）和右值（<code>RValue</code>）</p>

<h2 id="求值上下文">求值上下文</h2>

<p>求值上下文也分为位置上下文（<code>PlaceContext</code>）和值上下文（<code>Value Context</code>）。下面几种表达式属于位置上下文</p>

<ul>
<li>赋值或者复合赋值语句左侧的操作数。</li>
<li>一元引用表达式的独立操作数。</li>
<li>包含隐式借用（引用）的操作数。</li>
<li>match判别式或let绑定右侧在使用ref模式匹配的时候也是位置上下文。</li>
</ul>

<p>除了上述几种情况，其余表达式都属于值上下文. 值表达式不能出现在位置上下文中.</p>

<h2 id="所有权与引用">所有权与引用</h2>

<p>当<code>位置表达式</code>出现在<code>值上下文</code>中时，该位置表达式将会把内存地址转移给另外一个位置表达式，这其实是所有权的转移.</p>

<p>在语义上，每个变量绑定实际上都拥有该存储单元的所有权，这种转移内存地址的行为就是所有权（<code>OwnerShip</code>）的转移，在 Rust 中称为移动（<code>Move</code>）语义，那种不转移的情况实际上是一种复制（<code>Copy</code>）语义。Rust没有GC，所以完全依靠所有权来进行内存管理</p>

<h2 id="变量的生命周期">变量的生命周期</h2>

<p>从使用 let 声明创建变量绑定开始，到超出词法作用域的范围时结束</p>

<h2 id="闭包">闭包</h2>

<p>在一般情况下，闭包默认会按引用捕获变量。如果将此闭包返回，则引用也会跟着返回. 所以闭包最后通常会使用 <code>move</code> 来将所有权转移.</p>

<h1 id="println-宏"><code>println!</code> 宏</h1>

<ul>
<li>nothing代表Display，比如<code>println！（＂{}＂，2）</code></li>
<li>?代表Debug，比如<code>println！（＂{：？}＂，2）</code></li>
<li>o代表八进制，比如<code>println！（＂{：o}＂，2）</code></li>
<li>x代表十六进制小写，比如<code>println！（＂{：x}＂，2）</code></li>
<li>X代表十六进制大写，比如<code>println！（＂{：X}＂，2）</code></li>
<li>p代表指针，比如<code>println！（＂{：p}＂，2）</code></li>
<li>b代表二进制，比如<code>println！（＂{：b}＂，2）</code></li>
<li>e代表指数小写，比如<code>println！（＂{：e}＂，2）</code></li>
<li>E代表指数大写，比如<code>println！（＂{：E}＂，2）</code></li>
</ul>

<h1 id="rust-概念">Rust 概念</h1>

<blockquote>
<p>它是一门表达式语言, 一切皆表达式</p>
</blockquote>

<ul>
<li><p>默认情况下, 变量是不可变的. <code>immutable by default</code></p>

<ul>
<li>要想使变量可变, 则要用 <code>mut</code> 来修饰.</li>
</ul></li>

<li><p>默认情况下, 引用也是不可变的. <code>references are immutable by default</code></p>

<ul>
<li>要想使引用可变, 则要 <code>&amp;mut</code> 来修饰</li>
</ul></li>

<li><p><code>immutable</code> 表示一旦绑定 <code>bind</code> 就不可以再改变其值.</p></li>

<li><p><code>Result</code> 是枚举类型. <code>Ok</code> 或 <code>Err</code> .</p></li>

<li><p><code>cargo</code> 文件 <code>Cargo.toml</code> 的版本写法 <code>rand = &quot;0.3.14&quot;</code> 等同于 <code>rand = &quot;^0.3.14&quot;</code> 表示任意兼容 <code>0.3.14</code> 版本 API 的版本即可.</p></li>

<li><p><code>crate</code> 表示库</p></li>

<li><p><code>trait</code> 表示接口</p></li>

<li><p><code>shadow</code> : 通常用于同一个变量名, 从一种类型切换到另一种类型.</p>

<ul>
<li><code>let x = 5; let x = x + 1;</code></li>
</ul></li>

<li><p><code>shadow</code> 与 <code>mut</code> 的区别</p>

<ul>
<li>如果没有 <code>let</code> 然后重新声明同样名的变量会编译错误. 通过 <code>let</code> 我们可以方便地从一个变量转变为  <code>immuable</code></li>
<li><code>let</code> 可以重用原来的变量名, 但类型可以不同. 而 <code>mut</code> 不可以.</li>
</ul></li>

<li><p>指定变量类型 <code>let var_name: var_type</code></p></li>

<li><p><code>_</code> : 特殊变量, 表示所有.</p></li>

<li><p><code>const</code> 与 <code>immutable</code> 的区别</p>

<ul>
<li><code>const</code> 不允许用 <code>mut</code> 修饰. 它是一直都不可变的.</li>
<li><code>const</code> 中, 类型必须显式指定</li>
<li><code>const</code> 可以在任何地方声明</li>
<li><code>const</code> 只允许 <code>const</code> 表达式赋值, 而不是一个函数调用或其他在 runtime 时计算出来的值.</li>
</ul></li>
</ul>

<h2 id="数据类型">数据类型</h2>

<h3 id="scalar">scalar</h3>

<p>表示一个单独的值. 有 4 种.</p>

<h4 id="integer">integer</h4>

<table>
<thead>
<tr>
<th>length</th>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>

<tbody>
<tr>
<td>8bit</td>
<td>i8</td>
<td>u8</td>
</tr>

<tr>
<td>16bit</td>
<td>i16</td>
<td>u16</td>
</tr>

<tr>
<td>32bit</td>
<td>i32 (默认,即使是 64 位平台)</td>
<td>u32</td>
</tr>

<tr>
<td>64bit</td>
<td>i64</td>
<td>u64</td>
</tr>

<tr>
<td>128bit</td>
<td>i128</td>
<td>u128</td>
</tr>

<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>

<p>字面量</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>

<tbody>
<tr>
<td>十进制</td>
<td>98_222</td>
</tr>

<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>

<tr>
<td>八进制</td>
<td>0o77</td>
</tr>

<tr>
<td>二进制</td>
<td>0b1111_000</td>
</tr>

<tr>
<td>字节(仅限 u8 类型)</td>
<td>b&rsquo;A&rsquo;</td>
</tr>
</tbody>
</table>

<p>溢出处理</p>

<p>Debug 模式: 会检测是否溢出. 然后产生 <code>panic</code> 退出.</p>

<p>Release 模式: 并不会检测溢出. 超出值范围的话, 会产生  <code>two's complement wrapping</code>  .</p>

<h4 id="foating-point-number">foating-point number</h4>

<table>
<thead>
<tr>
<th>bit</th>
<th>type</th>
</tr>
</thead>

<tbody>
<tr>
<td>32</td>
<td>f32</td>
</tr>

<tr>
<td>64</td>
<td>f64 (默认)</td>
</tr>
</tbody>
</table>

<h4 id="bool">bool</h4>

<ul>
<li>只有两个值 <code>false</code>, <code>true</code></li>
<li>大小为 <code>1 byte</code></li>
</ul>

<h4 id="character">character</h4>

<ul>
<li>使用单引用. 双引用的话是 String 类型.</li>
<li>它是 4 <code>bytes</code>  大小.</li>
</ul>

<h3 id="compound-这可以组成多个值为一个类型-有两种">compound : 这可以组成多个值为一个类型. 有两种</h3>

<h4 id="tule">tule</h4>

<ul>
<li>可以由多种类型组合为一种.</li>
<li>它是固定长度. 一旦声明, 则不能改变大小.</li>
<li>声明: <code>let tup =(32, 6.4, 1)</code> . `  要获取值</li>
<li><code>let (x, y, z) = tup;</code> : 这种称为解构 <code>destructuring</code></li>
<li>也可以通过下标直接访问 <code>tup.0</code>, <code>tup.1</code> . 第一个索引的下标为 0.</li>
<li>元素不必是相同类型</li>
</ul>

<h4 id="array">array</h4>

<ul>
<li>- 固定长度.</li>
<li>声明 <code>let a = [1,2,3,4,5];</code></li>
<li><code>let a : [i32; 5] = [1,2,3,4,5];</code></li>
<li><code>let a = [3; 5]</code> . 表示元素全是 3, 一共 5 个.</li>
</ul>

<h2 id="string">String</h2>

<p>在Rust中每个char类型的字符都代表一个有效的u32类型的整数.</p>

<p>Rust 中字符串是 UTF-8 编码序列。出于内存安全的考虑，在Rust中字符串分为以下几种类型</p>

<ul>
<li>str，表示固定长度的字符串</li>
<li>String，表示可增长的字符串</li>
<li>CStr，表示由C分配而被Rust借用的字符串，一般用于和C语言交互</li>
<li>CString，表示由Rust分配且可以传递给C函数使用的C字符串，同样用于和C语言交互</li>
<li>OsStr，表示和操作系统相关的字符串。这是为了兼容Windows系统</li>
<li>OsString，表示OsStr的可变版本。与Rust字符串可以相互转换</li>
<li>Path，表示路径，定义于<code>std::path</code>模块中。Path包装了OsStr</li>
<li>PathBuf，跟Path配对，是Path的可变版本。PathBuf包装了OsString</li>
</ul>

<p>String 类型本质为一个成员变量是 <code>Vec＜u8＞</code> 类型的结构体，所以它是直接将字符内容存放于堆中的.</p>

<ul>
<li><code>len</code> 方法获取的是堆中字节序列的字节数，而非字符个数</li>
<li><code>as_ptr</code> 获取的是堆中字节序列的指针地址</li>
<li>通过引用操作符<code>&amp;</code>得到的地址为字符串变量在栈上指针的地址</li>
</ul>

<p>Rust提供了<code>bytes</code>和<code>chars</code>两个方法来分别返回按字节和按字符迭代的迭代器。所以，在Rust中对字符串的操作大致分为两种方式：按字节处理和按字符处理</p>

<h2 id="函数">函数</h2>

<ul>
<li>风格 <code>fn hello_world()</code></li>
<li>参数 <code>fn hello_world(x:i32)</code> 参数中的类型是必填的</li>
<li>函数体. 包含许多 statement 以及结尾可选的 expression.

<ul>
<li><code>statement</code> :  执行一些动作, 但没有返回值.

<ul>
<li>比如函数声明</li>
<li><code>let</code></li>
</ul></li>
<li><code>expression</code> : 它会给出一个值.

<ul>
<li>调用函数</li>
<li>调用 macro</li>
<li><code>{}</code> 定义作用域: <code>let y = {let x = 3; x + 1}</code></li>
</ul></li>
<li>注意 <code>5+1</code> 是 expression. 但 <code>5+1;</code>  是 statement.</li>
<li><code>expression</code> 可以是 <code>statement</code> 的一部分.</li>
</ul></li>
<li>注意, Rust 是一门 <code>expression-based</code> 的语言. 这跟其他的有很大的不同.</li>
<li>返回值

<ul>
<li><code>fn hello_world() -&gt; i32 {}</code></li>
<li>函数体最后一个 expression 就是函数的返回值.</li>
<li>多值(通过 tuple). <code>fn hello_world() -&gt; (i32, i32){}</code></li>
</ul></li>
<li>注释: <code>// your comment</code></li>
</ul>

<p>函数参数可以按值传递，也可以按引用传递。</p>

<p>当参数按值传递时，会转移所有权或者执行复制（Copy）语义。(按值传递的参数使用<code>mut</code>关键字)</p>

<p>当参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数。(按引用传递参数时的<code>mut</code>用法: <code>&amp;mut</code>)</p>

<p>当符合生命周期参数省略规则时，编译器可以通过自动推断补齐函数参数的生命周期参数，否则，需要显式地为参数标明生命周期参数</p>

<h2 id="控制流程">控制流程</h2>

<ul>
<li><code>if expression</code> 注意, 它是表达式来的.

<ul>
<li><code>if bool-expression {} else if bool-expression2 {} else {}</code></li>
<li>用在 <code>let</code> 中 : <code>let number = if condition {} else {};</code>

<ul>
<li>这时,  if 与 else 的 <code>expression</code> 结果, 都需要一致.</li>
</ul></li>
</ul></li>
<li>循环

<ul>
<li><code>loop</code>

<ul>
<li>无限循环. <code>loop {}</code></li>
</ul></li>
<li><code>while</code>

<ul>
<li><code>while condition {}</code></li>
</ul></li>
<li><code>for</code>

<ul>
<li>遍历数组 <code>for e in arr.iter() {}</code></li>
<li><code>for number in (1..4).rev() {}</code></li>
</ul></li>
<li>中断循环 : <code>break;</code> 它是 <code>expression</code> . <code>break x * 2;</code> 表示中断, 并返回值 <code>x*2</code></li>
<li>继续循环 : <code>continue;</code></li>
</ul></li>
</ul>

<h1 id="值语义和引用语义">值语义和引用语义</h1>

<p>为了更加精准地对这种情况进行描述，值语义（Value Semantic）和引用语义（ReferenceSemantic）被引入，定义如下。</p>

<ul>
<li>值语义：按位复制以后，与原始对象无关。引用语义：也叫指针语义。一般是指将数据存储于堆内存中，通过栈内存的指针来管理堆内存的数据，并且引用语义禁止按位复制。按位复制就是指栈复制，也叫浅复制，它只复制栈上的数据。相对而言，深复制就是对栈上和堆上的数据一起复制</li>
<li>引用语义：也叫指针语义。一般是指将数据存储于堆内存中，通过栈内存的指针来管理堆内存的数据，并且引用语义禁止按位复制。</li>
</ul>

<p>按位复制就是指<code>栈复制</code>，也叫<code>浅复制</code>，它只复制栈上的数据。相对而言，<code>深复制</code>就是对<code>栈上和堆上的数据一起复制</code></p>

<h2 id="所有权机制">所有权机制</h2>

<blockquote>
<p>解引用操作会获得所有权</p>
</blockquote>

<p>复制（<code>Copy</code>）语义和移动（<code>Move</code>）语义。</p>

<p>复制语义对应值语义，移动语义对应引用语义。</p>

<p>这样划分是因为引入了所有权机制，在所有权机制下<code>同时保证内存安全和性能</code></p>

<p>枚举体<code>enum</code>和结构体<code>struct</code>是类似的，当成员均为复制语义类型时，不会自动实现Copy。</p>

<p>而对于元组类型(<code>tuple</code>)来说，其本身实现了Copy，如果元素均为复制语义类型，则默认是按位复制的，否则会执行移动语义.</p>

<p>数组<code>array</code>和Option类型与元组类型都遵循这样的规则：如果元素都是复制语义类型，也就是都实现了Copy，那么它们就可以按位复制，否则就转移所有权</p>

<blockquote>
<p>字符串字面量，支持按位复制</p>
</blockquote>

<h3 id="闭包-1">闭包</h3>

<p>闭包闭包会创建新的作用域，对于环境变量来说有以下三种捕获方式：</p>

<ul>
<li>对于复制语义类型，以不可变引用（<code>&amp;T</code>）来捕获。</li>
<li>对于移动语义类型，执行移动语义（<code>move</code>）转移所有权来捕获。</li>
<li>对于可变绑定，如果在闭包中包含对其进行修改的操作，则以可变引用（<code>&amp;mut</code>）来捕获。</li>
</ul>

<h3 id="所有权借用">所有权借用</h3>

<p>在所有权系统中，引用<code>&amp;x</code>也可称为x的借用（<code>Borrowing</code>），通过<code>&amp;</code>操作符来完成所有权租借。既然是借用所有权，那么引用并不会造成绑定变量所有权的转移。但是借用所有权会让所有者（<code>owner</code>）受到如下限制：</p>

<ul>
<li>在不可变借用(<code>&amp;</code>)期间，所有者不能修改资源，并且也不能再进行可变借用。</li>
<li>在可变借用期间(<code>&amp;mut</code>)，所有者不能访问资源，并且也不能再出借所有权。</li>
</ul>

<p>引用在离开作用域之时，就是其归还所有权之时。使用借用，与直接使用拥有所有权的值一样自然，而且还不需要转移所有权。</p>

<p>借用规则为了保证内存安全，借用必须遵循以下三个规则。</p>

<ul>
<li>规则一：借用的生命周期不能长于出借方（拥有所有权的对象）的生命周期。</li>
<li>规则二：可变借用（引用）不能有别名（Alias），因为可变借用具有独占性。</li>
<li>规则三：不可变借用（引用）不能再次出借为可变借用。</li>
</ul>

<h2 id="检查是复制语义还是移动语义">检查是复制语义还是移动语义</h2>

<pre><code class="language-rust">fn test_copy(hello: impl Copy) -&gt; impl Copy {
    hello
}

fn main() {
    let x = Box::new(&quot;hello&quot;);

    test_copy(x);

    println!(&quot;{}&quot;, x);
}

</code></pre>

<h1 id="ownership">Ownership</h1>

<h2 id="rules">rules</h2>

<ul>
<li>在 Rust 中的每个值都有一个称为 <code>owner</code> 的变量</li>
<li>同一时间, 只允许一个 <code>owner</code></li>
<li>当 <code>owner</code> 离开了作用域, 则这个 value 将被 drop 掉.

<ul>
<li>即 Rust 在变量离开作用域时, 自动调用 <code>drop</code> 函数来释放资源.</li>
</ul></li>
</ul>

<h2 id="stack-and-heap">stack and heap</h2>

<ul>
<li>Stack : 所有保存在 stack 的数据必须是编译期已知的, 固定大小的.</li>
<li>Heap : 编译期未知大小的或大小允许被改变的数据则存储在 heap.</li>
</ul>

<h2 id="变量与数据交互">变量与数据交互</h2>

<h3 id="move">move</h3>

<p>类似其他类型的 <code>shallow copy</code> , 在 Rust 中称为 <code>move</code> .</p>

<p>当一个变量 move 到另一个变量时, 则旧的变量将变成无效了. 即 ownership move 了.</p>

<h3 id="clone">clone</h3>

<p>类似其他类型的 <code>deep copy</code> ,  在 Rust 中是调用 <code>clone()</code> 方法. 开销比较大, 容易影响性能.</p>

<h3 id="stack-only">stack only</h3>

<p>在 stack 上的数据, 都是  <code>copy</code> . (即不会 move)</p>

<p>在 stack 中的数据, <code>shadow copy</code> 与 <code>deep copy</code> 是一样的.</p>

<blockquote>
<p>Rust 不允许在某个类型拥有 Drop trait  的添加 Copy trait .</p>
</blockquote>

<h3 id="copy-trait-的数据类型">copy trait 的数据类型</h3>

<ul>
<li>integer</li>
<li>bool</li>
<li>float point number</li>
<li>character</li>
<li>tuple 并且仅包含是  <code>copy trait</code> 的元素. 例如 <code>(i32, i32)</code> . 但 <code>(i32, String)</code> 则不是.</li>
</ul>

<h2 id="ownership-与-function">ownership 与 function</h2>

<p>从语义上说, 传递一个值给函数, 跟赋值给一个变量是同义的. 所以,传递一个变量给一个函数, 将会导致 <code>copy</code> 或 <code>move</code> , 像赋值那样子.</p>

<p>返回值也同样会 transer ownership .</p>

<h2 id="references-and-borrowing">references and borrowing</h2>

<p>可以通过 reference 一个对象作为参数, 而不是获取它的 ownership. (这称为  <code>borrowing</code> , 即函数参数是 reference , <code>&amp;</code> )</p>

<blockquote>
<p>注意,  <code>&amp;</code> 即 reference , 默认情况下也是 immutable 的.</p>

<p>要想 <code>&amp;</code> 即 reference 变成 muutable, 则要 <code>let mut s = String.from(&quot;hello&quot;);</code> 然后传递reference 时使用 <code>&amp;mut s</code> 即可(相应的函数参数也要指定为 <code>&amp;mut String</code></p>

<p>mutable 的 reference 有一个很大的限制, 即在同一个作用域内, 只允许一个 mutable reference . 比如下面这样子就不允许:</p>

<pre><code class="language-rust">let mut s = String.from(&quot;hello&quot;);
let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>

<p>也不允许 mutable reference 与 immutable reference 共存.</p>

<p>但可以允许多个 immutable reference 共存</p>
</blockquote>

<pre><code class="language-rust">fn get_length(s:&amp;String) -&gt; usize {
  s.len()
}
</code></pre>

<p>下面这种则会获取 ownership . 这时  s 在调用完函数后会被 drop 掉.</p>

<pre><code class="language-rust">fn get_length(s:String) -&gt; usize {
  s.len()
}
</code></pre>

<h3 id="dangling-reference">dangling reference</h3>

<pre><code class="language-rust">fn main() {
    let s = no_dangle();
    println!(&quot;{}&quot;, s);
}
// 这个方法是 borrow, ownership 在 dangle() 方法内, 返回后, Rust 会释放 s 的内存. 导致 dangle reference, 所以在编译期就禁止了.
fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}

// 这个方法是 move, 即将 ownership 移出去, 这样子, Rust 就不会释放 s 的内存了
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);
    s
}
</code></pre>

<h3 id="reference-rule">reference rule</h3>

<ul>
<li>在给定的任意时间, 要么只有一个 mutable reference 要么多个 immutable reference . 但不能共存.</li>
<li>reference 必须总是有效的.</li>
</ul>

<h3 id="slice-type">slice type</h3>

<blockquote>
<p>slice 并不拥有 ownership</p>
</blockquote>

<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
let slice = &amp;s[2..4];
</code></pre>

<p>返回 String slice</p>

<pre><code class="language-rust">fn hello_world(s : &amp;String) -&gt; &amp;str {
  &amp;s[..]
}
</code></pre>

<p>string 字面值</p>

<blockquote>
<p>所有 string 字面值, 都是 slice 类型. 即 <code>&amp;str</code> .  也意味着它是 immutable 的. 因为 reference 默认是 immutable 的.</p>
</blockquote>

<p>其他类型的 slice</p>

<pre><code class="language-rust">let a = [1,2,3,4,5];
let slice = &amp;a[1..3]; // slice 是 &amp;[i32] 类型
</code></pre>

<h1 id="struct">struct</h1>

<h2 id="定义">定义</h2>

<pre><code class="language-rust">struct User {
  name : String,
  email : String,
  active : bool,
}
</code></pre>

<h2 id="实例化">实例化</h2>

<pre><code class="language-rust">let user1 = User {
  name : String::from(&quot;yang&quot;),
  email : String::from(&quot;xx@qq.com&quot;),
  active : true,
};

// mutable 
let mut user1 = User {
  name : String::from(&quot;yang&quot;),
  email : String::from(&quot;xx@qq.com&quot;),
  active : true,
};


</code></pre>

<blockquote>
<p>注意, 整个实例要么是 immutable, 要么是 mutable, Rust 不允许 struct 中部分字段是 mutable, 部分是 immutable</p>
</blockquote>

<p>使用函数来初始化可以简化</p>

<pre><code class="language-rust">fn build_user(email : String, name : String) -&gt; User {
  User {
    email,
    name,
    active: true,
  }
}
</code></pre>

<blockquote>
<p>即函数参数跟成员同名即可.</p>
</blockquote>

<p>使用旧的 struct 实例来初始化新的</p>

<pre><code class="language-rust">let user1 = User {
  name : String::from(&quot;yang&quot;),
  email : String::from(&quot;xx@qq.com&quot;),
  active : true,
};

let user2 = User {
  name : String::from(&quot;yang&quot;),
  email : String::from(&quot;xx@qq.com&quot;),
  ..user1
};
</code></pre>

<blockquote>
<p>这表示, user2 中除了 name, email 不同值之外, 其他成员字段值跟 user1一致.</p>
</blockquote>

<h2 id="tuple-struct">tuple struct</h2>

<blockquote>
<p>类似 tuple, 但没有名字, 只有类型. 可以像 tuple 那样解构以及通过索引访问</p>
</blockquote>

<pre><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32);
</code></pre>

<h2 id="unit-like-struct">unit like struct</h2>

<p>它没有任何成员. <code>()</code></p>

<p>通常用于实现一个 trait, 但没有任何数据要存储到这个类型上.</p>

<h2 id="print">print</h2>

<p>默认情况下, 自定义的 struct 类型并没有实现 <code>std::fmt::Display</code> 这个 trait . 所以当使用 <code>println!()</code> 来打印 struct 对象时会编译报错.</p>

<p>可修改为 debug print</p>

<pre><code class="language-rust">#[derive(Debug)]
struct Are {
    width: u32,
    height: u32,
}

fn main() {
    let are = Are {
        width: 16,
        height: 16,
    };
    println!(&quot;are -&gt; {:?}&quot;, are);
}
</code></pre>

<blockquote>
<p>即 println! 中的 <code>{:?}</code> 表示使用 <code>#[derive(Debug)]</code>  的 trait 来显示.</p>
</blockquote>

<h2 id="method">method</h2>

<blockquote>
<p>method 不完全同于 function. Method 是定义在 struct (或 enum, 或 trait 对象) 的上下文中的.</p>

<p>Method 可以 move ownership (self), 或 borrow immutable (&amp;self) 或 borrow mutable  (&amp;mut self)</p>

<p>Rust 在调用 method 的时候, 会自动将 struct 转换为 method 签名的类型.(如果兼容的话)</p>
</blockquote>

<p>定义 method</p>

<pre><code class="language-rust">#[derive(Debug)]
struct Are {
    width: u32,
    height: u32,
}

// struct 允许有多个 impl .
impl Are {
    fn area(&amp;self) -&gt; u32 {
        self.height * self.width
    }
}

fn main() {
    let are = Are {
        width: 16,
        height: 16,
    };
    println!(&quot;are -&gt; {:?}&quot;, are.area());
}
</code></pre>

<p>Method 的第一个参数, 总是 <code>self</code> (可以为 <code>&amp;self</code> 或 <code>&amp;mut self</code>).</p>

<h2 id="associated-function">associated function</h2>

<p>在 impl 语句块中的函数第一个参数不是 <code>self</code> 的函数, 即是  associated function. 它不是 method, 因为它不与实例关联.</p>

<blockquote>
<p>String::from 就是一个 associcated function</p>
</blockquote>

<h1 id="enum-与-pattern-matching">enum 与 pattern matching</h1>

<p>定义</p>

<pre><code class="language-rust">enum IP {
  V4,
  V6,
}
或
enum Message {
  Quit,
  Move {x: u32, y: u32},
  Write(String),
  Color(i32, i32, i32),
}

</code></pre>

<p>类似 struct, 也可以为 enum 添加 impl .</p>

<blockquote>
<p>Option enum.</p>

<p>Rust 中没有 null 这种特性.</p>
</blockquote>

<p>match <code>expression</code> .</p>

<pre><code class="language-rust">fn value_in_message(message: Message) -&gt; u8 {
  match message {
    Message::Quit =&gt; 1,
    Message::Move =&gt; 2,
    Message::Write =&gt; 3,
    Message::Color =&gt; 4,
  }
}

//绑定值
fn main() {
    println!(&quot;{:?}&quot;, plus_one(Some(32)));
}

fn plus_one(x : Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

// 结合 if let. 它与 match 类似, 当 match 条件匹配时, 则执行某动作. 注意, if let xx 后面是 = 号, 而不是 ==
// 可以想象为 if let 是 match 语法糖, 它只执行 match 其中之一, 而忽略剩余其他的全部. 
fn main() {
    let som = plus_one(Some(32));
    if let Some(33) = som {
        println!(&quot;33&quot;);
    }
}

fn plus_one(x : Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>

<blockquote>
<p>match 必须匹配所有情况. 特殊的 <code>_</code> 表示剩余所有情况.</p>

<p>因为 match 要匹配所有情况. 所以, 如果你只想处理其中之一的情况, 请记得用 if let 语法.</p>
</blockquote>

<h1 id="project-manage">Project manage</h1>

<ul>
<li>Package</li>
<li>Crates</li>
<li>Modules 以及 use</li>
<li>Paths</li>
</ul>

<h2 id="package-and-crates">package and crates</h2>

<p>一个 crate 是一个 binary (<code>main.rs</code>) 或 lib. (<code>lib.rs</code>)</p>

<pre><code class="language-bash"># binary
cargo new project 
# lib
cargo new --lib libname
</code></pre>

<p>一个 package 是一个或多个 crate. 一个 package 包含一个 <code>Cargo.toml</code> 文件描述如何构建这些 crate.  一个 package 可以包含 0 或至多一个 lib crate.</p>

<h2 id="module">module</h2>

<pre><code class="language-bash"># 创建库
 cargo new --lib mathlib

# 添加模块. 修改 src/lib.rs 文件
mod hello {
    fn say_world(s: &amp;str) {
        println!(&quot;hello {}&quot;, s);
    }

    mod sub {
        fn say_world(s: &amp;str) {
            println!(&quot;hello in sub mod {}&quot;, s);
        }
    }
}
</code></pre>

<p>module tree</p>

<pre><code class="language-bash">根据上面的情况, module tree 为
crate -&gt; hello -&gt; say_world
               -&gt; sub -&gt; say_world
</code></pre>

<h2 id="module-引用路径">module 引用路径</h2>

<ul>
<li>绝对路径: 通过 crate 名字或以 <code>crate</code> 开头.</li>

<li><p>相对路径: 在当前模块中, 使用 <code>self</code> 或 <code>super</code> 或直接当前模块的标识符</p>

<pre><code class="language-rust">pub mod hello {
pub fn say_world(s: &amp;str) {
    println!(&quot;hello {}&quot;, s);
}

mod sub {
    fn say_world(s: &amp;str) {
        println!(&quot;hello in sub mod {}&quot;, s);
    }
}
}

pub fn say_world(s: &amp;str) {
hello::say_world(s);
}
</code></pre></li>
</ul>

<blockquote>
<p>默认情况下, rust 所有东西(function, method, struct, enum, module, constant)都是 private 的.  要想导出路径, 则使用 pub 关键字.</p>
</blockquote>

<p>调用父模块的方法(每一次 super , 相当于目录的 <code>../</code>, 即上级目录)</p>

<pre><code class="language-rust">pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&quot;hello {}&quot;, s);
    }

    mod sub {
        fn say_world(s: &amp;str) {
            println!(&quot;hello in sub mod {}&quot;, s);
            super::super::say_world_parent(s);
        }
    }
}

pub fn say_world_parent(s: &amp;str) {
    hello::say_world(s);
}
</code></pre>

<h2 id="struct-与-enum-的-pub">struct 与 enum 的 pub</h2>

<p>注意, 在 struct 之前使用 <code>pub</code> 表示该 struct 是 pub 的, 但里面的字段仍然是 <code>private</code> 的. 但 enum 的话 如果 pub 了, 则所有都默认都是 pub 的.</p>

<h2 id="use-与-as">use 与 as</h2>

<p>use : 导入路径.</p>

<pre><code class="language-rust">pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&quot;hello {}&quot;, s);
    }

    mod sub {
        fn say_world(s: &amp;str) {
            println!(&quot;hello in sub mod {}&quot;, s);
            super::super::say_world_parent(s);
        }
    }
}

use hello::say_world;

pub fn say_world_parent(s: &amp;str) {
    say_world(s);
}
</code></pre>

<p>其他用法</p>

<pre><code class="language-rust">use std::{com::Ordering, io};
use std::io::{self, Write};
use std::io::*;
</code></pre>

<p>as : 别名</p>

<pre><code class="language-rust">pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&quot;hello {}&quot;, s);
    }

    mod sub {
        fn say_world(s: &amp;str) {
            println!(&quot;hello in sub mod {}&quot;, s);
            super::super::say_world_parent(s);
        }
    }
}

use hello::say_world as h;

pub fn say_world_parent(s: &amp;str) {
    h(s);
}
</code></pre>

<h2 id="将-lib-分离不同文件">将 lib 分离不同文件</h2>

<pre><code class="language-bash">src/lib.rs
src/hello.rs

只要在 lib.rs 文件中使用
mod hello; 
即可导入到 lib.rs 合并了.
</code></pre>

<h2 id="使用本地库">使用本地库</h2>

<p><code>Cargo.toml</code>  文件修改:</p>

<pre><code class="language-bash">[dependencies]
rand = &quot;0.3.14&quot;
# 注意 这个命名, 要跟库项目中的 Cargo.toml 中的 name 一致.
mathlib = {path = &quot;../mathlib&quot;} # 这里指向库的根目录
</code></pre>

<p>使用</p>

<pre><code class="language-rust">use mathlib;

fn main() {
    mathlib::hello::say_world(&quot;fuck&quot;);
}
</code></pre>

<h2 id="使用同一项目中其他目录的模块">使用同一项目中其他目录的模块</h2>

<p>结构</p>

<pre><code class="language-bash">src
├── benches
│   └── my_benchmark.rs
├── ipdb.rs
├── kit
│   ├── ip_kit.rs
│   └── mod.rs
├── main.rs
└── parser
    ├── bid_request.rs
    ├── mod.rs
    └── parser.rs

</code></pre>

<p><code>my_benchmark.rs</code> 中调用 <code>ipdb.rs</code> 的函数</p>

<pre><code class="language-rust">#[path = &quot;../ipdb.rs&quot;] mod ipdb;

fn say() {
  ipdb::find();
}
</code></pre>

<h1 id="常用集合-collections">常用集合 Collections</h1>

<blockquote>
<p>这些数据结构是保存在 heap 的.</p>
</blockquote>

<h2 id="vector">vector</h2>

<blockquote>
<p>每个元素只能是同一种类型. 不过, 可以利用 enum 来持有其他类型.</p>
</blockquote>

<pre><code class="language-rust">// 创建
fn main() {
    let v: Vec&lt;i32&gt; = Vec::new();
    let vv = vec![1, 2, 3];
}

// 添加/删除元素
fn main() {
    let mut v: Vec&lt;i32&gt; = Vec::new();
    v.push(13);
    println!(&quot;{:?}&quot;, v);
    v.remove(0);
    println!(&quot;{:?}&quot;, v);
}

//遍历
fn main() {
    let v = vec![1, 2, 3, 4];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre>

<blockquote>
<p>注意. 这里是用 <code>&amp;v</code> , 如果为 <code>v</code> , 则表示将 let v 的 ownership move 到 for 语句块了. 当结束时, v 就无效了, 即后面的代码不能再访问 v 了.</p>
</blockquote>

<h2 id="string-1">String</h2>

<blockquote>
<p>它是 UTF8 encode 的.</p>
</blockquote>

<pre><code class="language-rust">let mut s = String::new();

//修改
s.push_str(&quot;hello world&quot;);

//拼接 concat
fn main() {
    let s1 = String::from(&quot;hello &quot;);
    let s2 = String::from(&quot;world&quot;);
    let s3 = s1 + &amp;s2;
    println!(&quot;{}&quot;, s3);
}
实际调用的方法签名伪代码为 
fn add(self, s:&amp;str) -&gt; String {}

所以, 第一个参数(即 s1)的 ownership 已经 move 了. 之后的代码中, s1 不再有效. 由于 s2 只是借用而非 move, 所以 s2 仍然是 valid 的. 

//拼接 2
fn main() {
    let s1 = String::from(&quot;hello &quot;);
    let s2 = String::from(&quot;world&quot;);
    let s3 = format!(&quot;{}{}&quot;, s1, s2);
    println!(&quot;s1 {}, s2 {}, s3 {}&quot;, s1, s2, s3);
}

//索引 String. Rust 的 String 不同于其他的编程语言可以直接根据下标来索引字符.
// Rust 的 String 内部是使用 Vec&lt;u8&gt; . 即 Vec&lt;byte&gt; 来保存的. 即字节 Vec
// String.len() 返回的是字节的长度, 而不是字符.
// Rust 中的 String 有三种表示. bytes, scalar values, grapheme clusters.
// Rust 不允许使用索引来引用 String 的另一个原因是, 索引操作预期是 O(1) 的, 但Rust 中的 String 并不能这样子, 只能从头到尾来决定字符是否有效.
// 允许使用索引的情况是返回值为 a byte, a character, a grapheme cluster 或 string slice.
&quot;hello&quot;.chars()
&quot;hello&quot;.bytes()
grapheme 比较复杂, 并没有在标准库中提供.
</code></pre>

<h2 id="hashmap">HashMap</h2>

<blockquote>
<p>类似 vector, Hashmap 保存在 heap. k 要同一类型. v 也要同一类型.</p>
</blockquote>

<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;hello&quot;), 10);
    scores.insert(String::from(&quot;world&quot;), 20);


    println!(&quot;{:?}&quot;, scores);
}

//通过两个 vec 来构建 HashMap
use std::collections::HashMap;

fn main() {
    let teams = vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)];
    let scores = vec![10, 20];

    let m: HashMap&lt;_, _&gt; = teams.iter().zip(scores.iter()).collect();

    println!(&quot;{:?}&quot;, m);
}

//遍历
for (k, v) in &amp;m {
  
}
</code></pre>

<h3 id="ownership-1">ownership</h3>

<p>对于实现了 Copy trait 的, 例如 <code>i32</code> , 则值将 copy 到 HashMap, 而对于 owned value 的, 例如 <code>String</code>, 则 ownership 将会 move 到 HashMap. 例如</p>

<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let h = String::from(&quot;hello&quot;);
    let w = String::from(&quot;world&quot;);

    let mut map = HashMap::new();
    map.insert(h, w);

    println!(&quot;{:?}&quot;, map);
    //println!(&quot;h {}, w {}&quot;, h, w); h, w 的 ownership 已经 move 到 map 了, 所以 insert 之后, 这两个变量已经 invalid 了. 
}
</code></pre>

<blockquote>
<p>不过, 如果我们插入 reference 的话, 则 ownership 不会 move .</p>

<p>但这种情况下,  reference 的生命周期至少要与 hashMap 一样有效.</p>
</blockquote>

<h3 id="更新-hashmap">更新 hashmap</h3>

<pre><code class="language-rust">		//直接覆盖
    let h = String::from(&quot;hello&quot;);
    let w = String::from(&quot;world&quot;);

    let mut map = HashMap::new();
    map.insert(h, w);
    map.insert(String::from(&quot;hello&quot;), String::from(&quot;new world&quot;));

		//只在 key 没有值的时候插入
		map.entry(String::from(&quot;newKey&quot;)).or_insert(String::from(&quot;fuck&quot;));

		//基于旧值更新. or_insert 实际返回的是 &amp;mut v, 这样子就可以修改这个值即可.
		let v = map.entry(xx).or_insert(yy);
		*v += 1;

</code></pre>

<h3 id="hash-function">hash function</h3>

<p>默认情况下 HashMap 使用的是 siphash 函数. 但它不是性能最快的, 但权衡了安全性. 如果你发现它不能满足的你性能要求, 可以指定其他的 hash function .</p>

<h1 id="错误处理">错误处理</h1>

<h2 id="不可恢复的错误-panic">不可恢复的错误 panic</h2>

<pre><code class="language-rust">panic!(&quot;crash message...&quot;);
</code></pre>

<p>当使用该宏时, 会打印 panic 信息, 然后 unwind 以及程序清理栈, 最后退出.</p>

<blockquote>
<p>Unwinding 要执行许多工作. 一个可选的方式是立即 abort . 这会导致程序直接退出, 而不进行清理. (例如内存的释放交由操作系统来处理, 而不是程序自身).</p>

<p>如果你的程序binary文件想尽可能小, 则可以切换 panic 为 abort 处理模式. 在 Cargo.toml 文件中添加</p>
</blockquote>

<pre><code class="language-bash">[profile.release]
panic = 'abort'
</code></pre>

<p>跟踪栈. (此时, debug symbols 必须要开启. <code>--release</code> 参数构建的 binanry 则没有)</p>

<pre><code class="language-bash">RUST_BACKTRACE=1 cargo run
</code></pre>

<h2 id="可恢复错误-result">可恢复错误 Result</h2>

<pre><code class="language-rust">
use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;open file error {:?}&quot;, error);
        }
    };
}
//进一步处理不同的错误
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(file) =&gt; file,
                Err(err) =&gt; {
                    panic!(&quot;create file error {}&quot;, err);
                }
            },
            _ =&gt; {
                panic!(&quot;other error  {}&quot;, error);
            }
        }
    };
}
</code></pre>

<h2 id="在-error-中快速-panic">在 Error 中快速 panic</h2>

<ul>
<li><code>unwrap()</code> : 即如果 Result 是 Ok 则返回 Ok 持有的数据. 如果返回的是 Err 则调用 <code>panic!().</code> <code>let f = File::open(&quot;hello.txt&quot;).unwrap();</code></li>
<li><code>expect(msg)</code> :  类似 unwrap, 但让我们选择 panic 输出的 message.</li>
</ul>

<h2 id="传播-error">传播 error</h2>

<p>即将错误处理交由 caller 调用者来决定.</p>

<pre><code class="language-rust">fn read_line() -&gt; Result&lt;String, io::Error&gt; {
  
}
</code></pre>

<p>快速传播 Error 操作符: <code>?</code></p>

<pre><code class="language-rust">fn read_string() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    ok(s)
}

//简化调用
fn read_string() -&gt; Result&lt;String, io::Error&gt; {
  let mut s = String::new();
  File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;
  Ok(s)
}
//再一步
use std::fs;

fn read_string() -&gt; Result&lt;String, io::Error&gt; {
	fs::read_to_string(&quot;hello.txt&quot;)
}
</code></pre>

<p>即在 <code>Result</code> 类型后添加 <code>?</code> .  如果返回 Ok, 则会继续执行. 否则 return 返回调用者.</p>

<p><code>?</code> 与 match 的区别是: <code>?</code> 会调用 <code>From trait</code> 的 <code>from</code> 函数, 该函数用于将 error 类型转换为另一个类型.</p>

<h1 id="泛型-trait-以及生命周期">泛型, trait 以及生命周期</h1>

<h2 id="泛型函数">泛型函数</h2>

<pre><code class="language-rust">fn largest&lt;T&gt;(list:&amp;[T]) -&gt; T {
  
}
</code></pre>

<h2 id="trait">trait</h2>

<blockquote>
<p>定义共享行为</p>
</blockquote>

<pre><code class="language-rust">fn main() {
    let p = Person{};
    println!(&quot;{}&quot;, p.say_hello());
}

//定义一个 trait
pub trait TraitName {
    fn say_hello(&amp;self) -&gt; String;
  
  	fn say_hello2(&amp;self) -&gt; String {
      //添加默认实现
      String::from(&quot;default value&quot;)
  	}
}

//为某类型实现 trait
struct Person {

}

impl TraitName for Person {
    fn say_hello(&amp;self) -&gt; String {
        String::from(&quot;hello world&quot;)
    }
}
</code></pre>

<h3 id="trait-作为参数">trait 作为参数</h3>

<pre><code class="language-rust">pub fn notify(item: impl TraitName) {
  
}

//或
pub fn notify&lt;T:TraitName&gt;(item: T) {
  
}

//多种 Trait 结合
pub fn notify(item: impl TraitName + Display) {
  
}
//where clause
fn notify&lt;T, U&gt;(t: T, u: U) -&gt; i32 
	where T: Display + Clone,
				U: Clone + Debug
{
  
}
</code></pre>

<h3 id="trait-作为返回值">trait 作为返回值</h3>

<pre><code class="language-rust">fn notify() -&gt; impl TraitName {
  
}
</code></pre>

<h2 id="reference-lifetime">reference lifetime</h2>

<p>每个引用的 lifetime , 即是它们的作用域. 大多数时候, lifetime 是隐含及推断的.</p>

<blockquote>
<p>它的主要目的是防止 dangling reference.</p>
</blockquote>

<p>lifetime annotation : 它并不改变一个引用能存活多久. 它只是描述了在多个 reference 之间的 lifetime 关系. 语法如下</p>

<pre><code class="language-rust">&amp;i32 , 添加 lifetime annotation 则为 &amp;'a i32, &amp;'a mut 32
</code></pre>

<p>单个 reference 标注 lifetime 并没有多大意义. 因为 annotation 主要是告诉 Rust 在多个 reference 之间的 lifetime 关系.</p>

<h3 id="默认lifetime-rules">默认lifetime rules</h3>

<ul>
<li>每个reference 参数都有它们自己的 lifetime</li>
<li>如果仅有一个输入参数, 则输出(返回参数)的 lifetime 跟输入的一致.</li>
<li>如果有多个输入参数, 但其中之一是 <code>&amp;self</code> 或 <code>&amp;mut self</code> , 由于是 method, 则 <code>self</code> 的 lifetime 被应用于所有输出参数.</li>
</ul>

<h3 id="static-lifetime">static lifetime</h3>

<p>有个特殊的 lifetime anntion , 它就是 <code>'static</code> . 所有 string 字面量都是这种 lifetime</p>

<h3 id="生命周期参数">生命周期参数</h3>

<p>值的生命周期和词法作用域有关, 但是借用可以在各个函数间传递，必然会跨越多个词法作用域.</p>

<h4 id="显式生命周期">显式生命周期</h4>

<p>生命周期参数必须以单引号开头，参数名通常都是小写字母，比如<code>＇a</code>。生命周期参数位于引用符号<code>&amp;</code>后面，并使用空格来分割生命周期参数和类型. 比如</p>

<pre><code class="language-rust">&amp;'a i32
&amp;'a mut i32
</code></pre>

<p>标注生命周期参数并不能改变任何引用的生命周期长短，它只用于编译器的借用检查.</p>

<p>函数中使用的语法如下</p>

<pre><code class="language-rust">fn foo&lt;'a&gt;(s: &amp;'a str, t: &amp;'a str) -&gt; &amp;'a str;
</code></pre>

<p>函数名后面的<code>＜＇a＞</code>为生命周期参数的声明，与泛型参数类似，必须先声明才能使用。函数或方法参数的生命周期叫作输入生命周期（<code>input lifetime</code>），而返回值的生命周期被称为输出生命周期（<code>output lifetime</code>)</p>

<p>函数签名的生命周期参数有这样的限制条件：输出（借用方）的生命周期长度必须不长于输入（出借方）的生命周期长度（此条件依然遵循借用规则一）</p>

<h4 id="生命周期省略规则">生命周期省略规则</h4>

<ul>
<li>每个输入位置上省略的生命周期都将成为一个不同的生命周期参数</li>
<li>如果只有一个输入生命周期的位置（不管是否忽略），则该生命周期都将分配给输出生命周期</li>
<li>如果存在多个输入生命周期的位置，但是其中包含着<code>&amp;self</code>或<code>&amp;mut self</code>，则<code>self</code>的生命周期都将分配给输出生命周期</li>
</ul>

<h2 id="它们组合在一起">它们组合在一起</h2>

<pre><code class="language-rust">fn longest_with&lt;'a, T&gt;(x: &amp;'a str, y:&amp;'a str, ann: T) -&gt; &amp;'a str where T: Display {
  println!(&quot;ann {}&quot;, ann);
  if x.len() &gt; y.len() {
    x
  } else {
    y
  }
}
</code></pre>

<h1 id="自动化测试">自动化测试</h1>

<pre><code class="language-rust">pub mod hello {
    pub fn say_world(s: &amp;str) {
        println!(&quot;hello {}&quot;, s);
    }

    mod sub {
        fn say_world(s: &amp;str) {
            println!(&quot;hello in sub mod {}&quot;, s);
            super::super::say_world_parent(s);
        }
    }
}

use hello::say_world as h;

pub fn say_world_parent(s: &amp;str) {
    h(s);
}

#[cfg(test)]
mod tests {
    #[test]
    fn testSay() {
        super::hello::say_world(&quot;fuck the world&quot;);
        assert_eq!(2 + 2, 5);
    }
}
</code></pre>

<p>测试命令</p>

<pre><code class="language-bash"># 执行所有测试代码
cargo test 

# 控制并行数
cargo test -- --test-threads=1

# 只执行特定测试方法
cargo test 方法名

# 执行显式指定属性的测试方法
#[cfg(test)]
mod tests {
    #[test]
    fn testSay() {
        super::hello::say_world(&quot;fuck the world&quot;);
        assert_eq!(2 + 2, 5);
    }

    #[test]
    #[ignore]
    fn testSay2() {
        super::hello::say_world(&quot;fuck the world2&quot;);
        assert_eq!(2 + 2, 5);
    }
}
这时
cargo test -- --ignored 
则只会执行带有 `#[ignore]` 属性的测试方法. 而普通 cargo test 则不会执行.
</code></pre>

<h2 id="性能测试">性能测试</h2>

<p>示例性能测试代码</p>

<pre><code class="language-rust">#![feature(test)]

extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
</code></pre>

<pre><code class="language-bash">rustup install nightly
</code></pre>

<p>然后执行</p>

<pre><code class="language-bash">cargo +nightly bench
</code></pre>

<h1 id="i-o">I/O</h1>

<h2 id="读取命令行参数">读取命令行参数</h2>

<pre><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;? =&gt; {:?}&quot;, args);
}
注意, args() 如果包含有无效的 unicode 则会导致 panic. 如果想包含这种数据的话, 则要用 args_os() .
传递参数来运行
cargo run hello world ,则输出如下
   Compiling hello-rust v0.1.0 (/Users/emacsist/Documents/rust/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.80s
     Running `target/debug/hello-rust hello world`
[&quot;target/debug/hello-rust&quot;, &quot;hello&quot;, &quot;world&quot;]
</code></pre>

<h1 id="函数式语言特征-iterator-与-closure">函数式语言特征: iterator 与 closure</h1>

<p>Closure : anonymous functions that can capture their environment . 即, 它可以捕获定义他们地方所有作用域的值.</p>

<pre><code class="language-rust">let clo = |num| {
  println!(&quot;in closure ....&quot;);
  num
};
//注意, let clo 表示 clo 包含匿名函数的定义, 则不是执行后的返回值.

//如果不指定参数类型, 则 Rust 以第一次调用时的为准. 
</code></pre>

<p>fn trait</p>

<pre><code class="language-rust">struct Cache&lt;T&gt; where T: Fn(u32) -&gt; u32 {
  exec: T,
  value: Option&lt;u32&gt;,
}
</code></pre>

<p>闭包（Closure）通常是指词法闭包，是一个持有外部环境变量的函数。外部环境是指闭包定义时所在的词法作用域。外部环境变量，在函数式编程范式中也被称为自由变量，是指并不是在闭包内定义的变量。将自由变量和自身绑定的函数就是闭包</p>

<h2 id="捕获-environment">捕获 environment</h2>

<p>有三种方式, 对应函数参数的三种方式(take ownership, borrowing mutably, borrowing immutably). 三个 trait 如下</p>

<ul>
<li><code>FnOnce</code> : 将会 take ownership.</li>
<li><code>FnMut</code> : borrowing mutably</li>
<li><code>Fn</code> : borrowing immutably</li>
</ul>

<p>可以显式指定 move :</p>

<pre><code class="language-rust">let x = 32;
let clo = move |param| param == x
这时, x 的 ownership move 到了 closure 里了. 后面将不再有效
</code></pre>

<h2 id="iterator">iterator</h2>

<blockquote>
<p>注意, iter().next() 返回的是 &amp;item</p>
</blockquote>

<p>所有 iterators 都是 lazy 的. 例如</p>

<pre><code class="language-rust">let v1 = vec![1,2,3];
let v2 = v1.iter().map(|x| x + 1); // 这时 v2 是 Map 类型. 要调用 collect() 来消费 map 产生的 iter 



use std::env;
fn main() {
    let v1 = vec![1, 2, 3];
    let v2: Vec&lt;i32&gt; = v1.iter().map(|x| x + 1).collect();
    println!(&quot;{:?}&quot;, v2);
}
</code></pre>

<p>它与 for 的性能: 在 Rust 中, 不用担心这些开销, iterator 与 for 几乎一样的.</p>

<h1 id="cargo">Cargo</h1>

<p>默认的 profile 是 <code>dev</code> : 它的默认优化级别是 0.</p>

<pre><code class="language-bash">Cargo.toml 文件中

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3

</code></pre>

<p>文档化注释 <code>/// doc</code></p>

<p>workspace :</p>

<pre><code class="language-bash">tree .
.
├── Cargo.toml
├── hello
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── hello-lib
    ├── Cargo.toml
    └── src
        └── lib.rs

在 workspace 根目录执行命令
cargo build
   Compiling hello v0.1.0 (/private/tmp/work/hello)
   Compiling hello-lib v0.1.0 (/private/tmp/work/hello-lib)
    Finished dev [unoptimized + debuginfo] target(s) in 1.82s
</code></pre>

<p>从 cargo.io 安装 binary: <code>cargo install xxx</code></p>

<h1 id="smart-pointer">smart pointer</h1>

<h2 id="box-t"><code>Box&lt;T&gt;</code></h2>

<p>用于指向在 heap 的数据. 它没有性能开销, 除了保存数据在 heap 而不是 stack 外.</p>

<h3 id="recursive-type">recursive type</h3>

<p>在编译时, Rust 需要知道一种类型要占多少空间. 如果在编译时不知道大小的类型, 它就是一个 <code>recursive type</code> , 即该值是它自身同一类型的另一个值的一部分. 但 Box 有大小, 所以可以用它来实现 recursive type.</p>

<p>例如</p>

<pre><code class="language-rust">enum List {
  Cons(i32, List),
  Nil,
}

use List::{Cons,Nil};
let list = Cons(1, Cons(2, Cons(3, Nil)));
</code></pre>

<blockquote>
<p>上面代码编译不了. 因为 Rust 编译时不知道 List 的大小.</p>
</blockquote>

<p>借助 Box 就可以编译了</p>

<pre><code class="language-rust">enum List {
  Cons(i32, Box&lt;List&gt;),
  Nil,
}

use List::{Cons,Nil};
let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
</code></pre>

<p>通过 <code>Deref</code> trait , 让 smark pointer 与普通 reference 一样.</p>

<p>通过实现 Deref trait , 允许你自定义 dereference operator, <code>*</code> .</p>

<pre><code class="language-rust">struct MyBox&lt;T&gt;(T);


impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}

这时 
let m = MyBox(13);
*m 等同于 *(m.deref())
</code></pre>

<h2 id="drop-trait">Drop trait</h2>

<p>当变量 owner 离开作用域时, Rust 会调用该变量的 <code>drop()</code> (如果有的话)来释放资源.</p>

<p>但该方法, 不允许显式调用. 例如 <code>o.drop();</code> . 但可以通过 <code>std::mem::drop</code> 来处理. <code>drop(o);</code></p>

<h2 id="rc-t"><code>Rc&lt;T&gt;</code></h2>

<p>变量默认是单个 ownership 的. 如果想开启多个 ownership, 则可使用该类型.</p>

<p>注意, 它只能用于单线程环境.</p>

<p>只增加引用计数: <code>Rc::clone(&amp;ref);</code> 如果调用 <code>ref.clone()</code> 这是deep copy 了</p>

<h2 id="refcell-t"><code>RefCell&lt;T&gt;</code></h2>

<p>它不同用 <code>Box&lt;T&gt;</code> (编译期, compile time , 检查 borrow 规则), 而 <code>RefCell&lt;T&gt;</code> (运行期, runtime, 检查 borrow 规则)</p>

<p>它也只能用于单线程环境.</p>

<h2 id="概括">概括</h2>

<ul>
<li><code>Rc&lt;T&gt;</code> 允许同一份数据有多个 owner. 而 <code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 是 single owner</li>
<li><code>Box&lt;T&gt;</code> 允许 immutable 或 mutable borrow , 并且是在 compile time 检查. <code>Rc&lt;T&gt;</code> 只允许 immutable borrow  , 并且在 compile time 检查. <code>RefCell&lt;T&gt;</code> 允许 immutable 或 mutable borrow, 但是在 runtime 检查.</li>
<li>由于 <code>RefCell&lt;T&gt;</code> 允许 mutable borrow 并且在 runtime 才检查, 所以, 你可以更改在 <code>RefCell&lt;T&gt;</code> 的值, 即使 <code>RefCell&lt;T&gt;</code> 是 immutable 的也可以.</li>
</ul>

<h1 id="并发">并发</h1>

<p>在 Rust 的线程实现中, 与操作系统的是 <code>1:1</code> 模型.</p>

<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi {}, in thread&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!(&quot;hi {}, in main&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}

//等待线程完成. hand 是 JoinHandle 类型.
use std::thread;
use std::time::Duration;

fn main() {
    let hand = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi {}, in thread&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!(&quot;hi {}, in main&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
    hand.join().unwrap();
}
</code></pre>

<h2 id="move-1">move</h2>

<blockquote>
<p>这样, 可以让某线程从另一条线程数据中 move ownership.</p>
</blockquote>

<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {

    let v = vec![1, 2, 3];

    let hand = thread::spawn(move || {
        println!(&quot;{:?}&quot;, v);
    });

    hand.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi {}, in main&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

}
</code></pre>

<h2 id="线程之间消息传递">线程之间消息传递</h2>

<blockquote>
<p>mpsc, multi producer, single consumer</p>
</blockquote>

<pre><code class="language-rust">
use std::thread;
use std::time::Duration;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let msg = String::from(&quot;hi&quot;);
        tx.send(msg).unwrap();
    });

    let recMsg = rx.recv().unwrap();
    println!(&quot;Got {}&quot;, recMsg);
}

//多个 tx
let tx1 = mpsc::Sender::clone(&amp;tx);
</code></pre>

<h3 id="channel-与-ownership">channel 与 ownership</h3>

<p>在 <code>tx</code> 发送消息时 <code>send()</code> 函数会 take ownership , 即参数的 ownership 会 move , 然后被传送到 rx.</p>

<h2 id="mutex">Mutex</h2>

<pre><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!(&quot;{:?}&quot;, m);
}
</code></pre>

<h2 id="arc-t"><code>Arc&lt;T&gt;</code></h2>

<p>类似 <code>Rc&lt;T&gt;</code> , 但是线程安全的.</p>

<pre><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;
use std::rc::Rc;

fn main() {
  	//你可能已经看到, counter 是 immutable 的. 但后面却修改了它.
  	// 这意味着 Mutex&lt;T&gt; 提供了内部修改的能力. 类似 Cell 家族.
    let counter = Arc::new(Mutex::new(0));

    let mut handles = vec![];
    for _ in 1..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
    println!(&quot;{:?}&quot;, *counter.lock().unwrap());
}
</code></pre>

<blockquote>
<p>如果这里修改为 Rc , 则会导致编译错误.</p>
</blockquote>

<h1 id="oop">OOP</h1>

<pre><code class="language-rust">//定义 Object
pub struct Person {
  name: String,
  age: u16,
}

//定义方法
impl Person {
  pub fn getName(&amp;self) -&gt; &amp;str {
    
  }
}

// Trait 
pub trait Run {
  fn run(&amp;self);
}

//为 Person 实现 Run trait
impl Run for Person {
  fn run(&amp;self) {
    //code...
  }
}
</code></pre>

<h1 id="常见问题及解决">常见问题及解决</h1>

<h2 id="blocking-waiting-for-file-lock-on-package-cache">Blocking waiting for file lock on package cache</h2>

<pre><code class="language-bash">rm ~/.cargo/.package-cache
然后重新 cargo run 
</code></pre>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2019-08-27</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/rust/">rust</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2019/09/05/redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Redis最佳实践</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2019/08/23/linux-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">&lt;Linux 内核设计与实现&gt;笔记</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2019-08-27 11:13:20 \x2b0800 CST',
    title: '2019 Rust学习',
    link: decodeURI(location.href),
    desc: '准备工作 rustup rustup github rustup 用于安装 Rust , 并可管理 rust 不同的版本(stabl',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
