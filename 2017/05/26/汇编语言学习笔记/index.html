<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>《汇编语言》学习笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="第一章：基础知识 汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 &#43;, -, *," />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.54.0" />


<link rel="canonical" href="https://emacsist.github.io/2017/05/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="《汇编语言》学习笔记" />
<meta property="og:description" content="第一章：基础知识 汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 &#43;, -, *," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2017/05/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2017-05-26T11:28:44&#43;00:00"/>
<meta property="article:modified_time" content="2017-05-26T11:28:44&#43;00:00"/>

<meta itemprop="name" content="《汇编语言》学习笔记">
<meta itemprop="description" content="第一章：基础知识 汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 &#43;, -, *,">


<meta itemprop="datePublished" content="2017-05-26T11:28:44&#43;00:00" />
<meta itemprop="dateModified" content="2017-05-26T11:28:44&#43;00:00" />
<meta itemprop="wordCount" content="12230">



<meta itemprop="keywords" content="汇编语言," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《汇编语言》学习笔记"/>
<meta name="twitter:description" content="第一章：基础知识 汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 &#43;, -, *,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">《汇编语言》学习笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-05-26 </span>
        
        <span class="more-meta"> 12230 words </span>
        <span class="more-meta"> 25 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#第一章-基础知识">第一章：基础知识</a>
<ul>
<li><a href="#汇编语言的组成">汇编语言的组成</a></li>
<li><a href="#指令和数据">指令和数据</a></li>
<li><a href="#存储单元">存储单元</a></li>
<li><a href="#cpu-对存储器的读写">CPU 对存储器的读写</a></li>
<li><a href="#数据的读写">数据的读写</a></li>
<li><a href="#命令计算机读写">命令计算机读写</a></li>
<li><a href="#地址总线">地址总线</a></li>
<li><a href="#数据总线">数据总线</a></li>
<li><a href="#控制总线">控制总线</a></li>
<li><a href="#内存地址空间">内存地址空间</a>
<ul>
<li><a href="#大小">大小</a></li>
<li><a href="#内存地址空间分配">内存地址空间分配</a></li>
</ul></li>
</ul></li>
<li><a href="#第二章-寄存器">第二章：寄存器</a>
<ul>
<li><a href="#8086-cpu寄存器">8086 CPU寄存器</a></li>
<li><a href="#字在寄存器中的存储">字在寄存器中的存储</a></li>
<li><a href="#物理地址">物理地址</a></li>
<li><a href="#16位的cpu">16位的CPU</a></li>
<li><a href="#8086-cpu给出物理地址的方法">8086 CPU给出物理地址的方法</a></li>
<li><a href="#段地址-16-偏移地址-物理地址-的本质含义">段地址 * 16 + 偏移地址 = 物理地址 的本质含义</a></li>
<li><a href="#段寄存器">段寄存器</a></li>
<li><a href="#修改cs-ip的指令">修改CS，IP的指令</a></li>
<li><a href="#windows下的-debug-工具">Windows下的 Debug 工具</a></li>
</ul></li>
<li><a href="#第三章-寄存器-内存访问">第三章：寄存器（内存访问）</a>
<ul>
<li><a href="#内存中字的存储">内存中字的存储</a></li>
<li><a href="#ds和-address">DS和[address]</a></li>
<li><a href="#内存的读写">内存的读写</a>
<ul>
<li><a href="#读">读</a></li>
<li><a href="#写">写</a></li>
</ul></li>
<li><a href="#数据段">数据段</a></li>
<li><a href="#栈">栈</a></li>
<li><a href="#cpu提供的栈机制">CPU提供的栈机制</a>
<ul>
<li><a href="#栈顶">栈顶</a></li>
<li><a href="#push">PUSH</a></li>
<li><a href="#空栈">空栈</a></li>
<li><a href="#pop">POP</a></li>
<li><a href="#栈顶超界的问题">栈顶超界的问题</a></li>
<li><a href="#pop-和-push-指令">POP 和 PUSH 指令</a></li>
<li><a href="#栈段">栈段</a></li>
</ul></li>
</ul></li>
<li><a href="#第四章-第一个程序">第四章：第一个程序</a>
<ul>
<li><a href="#编译">编译</a></li>
<li><a href="#链接">链接</a></li>
<li><a href="#调试">调试</a></li>
<li><a href="#整个过程">整个过程</a>
<ul>
<li><a href="#dos-的加载过程">DOS 的加载过程</a></li>
</ul></li>
<li><a href="#单任务执行过程">单任务执行过程</a></li>
</ul></li>
<li><a href="#第五章-bx-和-loop指令">第五章：[BX] 和 loop指令</a>
<ul>
<li><a href="#loop-指令">loop 指令</a></li>
<li><a href="#debug-中的-g-命令">debug 中的 G 命令</a></li>
<li><a href="#debug-中的-p-命令">debug 中的 P 命令</a></li>
<li><a href="#debug-和汇编器-masm-对指令的不同处理">debug 和汇编器 masm 对指令的不同处理</a></li>
<li><a href="#一段安全的空间">一段安全的空间</a></li>
</ul></li>
<li><a href="#第六章-包含多个段的程序">第六章：包含多个段的程序</a>
<ul>
<li><a href="#程序第一条指令">程序第一条指令</a></li>
<li><a href="#只用一个段来写代码">只用一个段来写代码</a></li>
<li><a href="#多段">多段</a></li>
</ul></li>
<li><a href="#第七章-更灵活的定位内存地址的方法">第七章：更灵活的定位内存地址的方法</a>
<ul>
<li><a href="#and-和-or-指令">and 和 or 指令</a></li>
<li><a href="#bx-idata">[bx+idata]</a></li>
<li><a href="#si-和-di">SI 和 DI</a></li>
<li><a href="#bx-si-和-bx-di">[bx+si] 和 [bx+di]</a></li>
<li><a href="#bx-si-idata-和-bx-di-idata">[bx+si+idata] 和 [bx+di+idata]</a></li>
<li><a href="#寻址方式">寻址方式</a></li>
</ul></li>
<li><a href="#第八章-数据处理的两个基本问题">第八章：数据处理的两个基本问题</a>
<ul>
<li><a href="#bx-si-di-和-bp">bx, si, di 和 bp</a></li>
<li><a href="#机器指令处理的数据在什么地方">机器指令处理的数据在什么地方</a></li>
<li><a href="#数据位置的表达">数据位置的表达</a>
<ul>
<li><a href="#立即数">立即数</a></li>
<li><a href="#寄存器">寄存器</a></li>
<li><a href="#段地址-sa-和偏移地址-ea">段地址（SA）和偏移地址（EA）</a></li>
</ul></li>
<li><a href="#寻址方式-1">寻址方式</a>
<ul>
<li><a href="#直接寻址">直接寻址</a></li>
<li><a href="#寄存器间接寻址">寄存器间接寻址</a></li>
<li><a href="#寄存器相对寻址">寄存器相对寻址</a></li>
<li><a href="#基址变址寻址">基址变址寻址</a></li>
<li><a href="#相对基址变址寻址">相对基址变址寻址</a></li>
</ul></li>
<li><a href="#要处理数据的长度">要处理数据的长度</a></li>
<li><a href="#div-指令">div 指令</a></li>
<li><a href="#dup">dup</a></li>
</ul></li>
<li><a href="#第九章-转移指令的原理">第九章：转移指令的原理</a>
<ul>
<li><a href="#转移指令分类">转移指令分类</a></li>
<li><a href="#offset">offset</a></li>
<li><a href="#jmp-指令">jmp 指令</a></li>
<li><a href="#依据位移进行转移的-jmp-指令">依据位移进行转移的 jmp 指令</a></li>
<li><a href="#转移的目的地址在指令中的-jmp-指令">转移的目的地址在指令中的 jmp 指令</a></li>
<li><a href="#转移地址在寄存器中的-jmp-指令">转移地址在寄存器中的 jmp 指令</a></li>
<li><a href="#转移地址在内存中的-jmp-指令">转移地址在内存中的 jmp 指令</a></li>
<li><a href="#jcxz-指令">jcxz 指令</a></li>
<li><a href="#loop-指令-1">loop 指令</a></li>
</ul></li>
<li><a href="#第十章-call-和-ret-指令">第十章：CALL 和 RET 指令</a>
<ul>
<li><a href="#ret-和-retf">ret 和 retf</a></li>
<li><a href="#call-指令">call 指令</a></li>
<li><a href="#依据位移进行转移的-call-指令">依据位移进行转移的 call 指令</a></li>
<li><a href="#转移的目的地址在指令中的-call-指令">转移的目的地址在指令中的 call 指令</a></li>
<li><a href="#转移地址在寄存器中的-call-指令">转移地址在寄存器中的 call 指令</a></li>
<li><a href="#转移地址在内存中的-call-指令">转移地址在内存中的 call 指令</a></li>
<li><a href="#mul-指令">mul 指令</a></li>
</ul></li>
<li><a href="#第十一章-标志寄存器">第十一章：标志寄存器</a>
<ul>
<li><a href="#0-cf">0：CF</a></li>
<li><a href="#2-pf">2：PF</a></li>
<li><a href="#4-af">4：AF</a></li>
<li><a href="#6-zf">6：ZF</a></li>
<li><a href="#7-sf">7：SF</a></li>
<li><a href="#8-tf">8：TF</a></li>
<li><a href="#9-if">9：IF</a></li>
<li><a href="#10-df">10：DF</a></li>
<li><a href="#11-of">11：OF</a></li>
<li><a href="#adc-指令">adc 指令</a></li>
<li><a href="#sbb-指令">sbb 指令</a></li>
<li><a href="#cmp-指令">cmp 指令</a></li>
<li><a href="#检测比较结果的条件转移指令">检测比较结果的条件转移指令</a>
<ul>
<li><a href="#je">je</a></li>
<li><a href="#jne">jne</a></li>
<li><a href="#jb">jb</a></li>
<li><a href="#jnb">jnb</a></li>
<li><a href="#ja">ja</a></li>
<li><a href="#jna">jna</a></li>
</ul></li>
<li><a href="#pushf-和-popf">pushf 和 popf</a></li>
</ul></li>
<li><a href="#第十二章-内中断">第十二章：内中断</a>
<ul>
<li><a href="#中断的产生">中断的产生</a></li>
<li><a href="#中断向量表">中断向量表</a></li>
<li><a href="#中断过程">中断过程</a></li>
<li><a href="#中断处理程序和-iret-指令">中断处理程序和 iret 指令</a></li>
<li><a href="#响应中断的特殊情况">响应中断的特殊情况</a></li>
</ul></li>
<li><a href="#第十三章-int-指令">第十三章：int 指令</a>
<ul>
<li><a href="#bios-和-dos-中断例程的安装过程">BIOS 和 DOS 中断例程的安装过程</a></li>
</ul></li>
<li><a href="#第十四章-端口">第十四章：端口</a>
<ul>
<li><a href="#端口的读写">端口的读写</a></li>
<li><a href="#shl-和-shr-指令">SHL 和 SHR 指令</a></li>
</ul></li>
<li><a href="#第十五章-外中断">第十五章：外中断</a>
<ul>
<li><a href="#外中断源">外中断源</a>
<ul>
<li><a href="#可屏蔽中断">可屏蔽中断</a></li>
<li><a href="#不可屏蔽中断">不可屏蔽中断</a></li>
</ul></li>
<li><a href="#pc-机键盘的处理过程">PC 机键盘的处理过程</a></li>
</ul></li>
<li><a href="#杂项">杂项</a>
<ul>
<li><a href="#显存的物理地址">显存的物理地址</a></li>
<li><a href="#ascii-与-显卡文本模式显示">ASCII 与 显卡文本模式显示</a></li>
<li><a href="#mov">MOV</a></li>
<li><a href="#汇编地址">汇编地址</a></li>
<li><a href="#jmp-near-xxx">jmp near xxx</a></li>
<li><a href="#movsb-或-movsw">movsb 或 movsw</a></li>
<li><a href="#偏移地址">偏移地址</a></li>
<li><a href="#cbw-或-cwd">cbw 或 cwd</a></li>
<li><a href="#call-指令-1">call 指令</a>
<ul>
<li><a href="#相对近调用">相对近调用</a></li>
<li><a href="#绝对近调用">绝对近调用</a></li>
<li><a href="#绝对远调用">绝对远调用</a></li>
<li><a href="#间接绝对远调用">间接绝对远调用</a></li>
</ul></li>
<li><a href="#ret-和-retf-1">ret 和 retf</a></li>
<li><a href="#jmp">jmp</a>
<ul>
<li><a href="#相对短转移">相对短转移</a></li>
<li><a href="#16位相对近转移">16位相对近转移</a></li>
<li><a href="#16位间接绝对近转移">16位间接绝对近转移</a></li>
<li><a href="#16位直接绝对远转移">16位直接绝对远转移</a></li>
<li><a href="#16位间接绝对远转移">16位间接绝对远转移</a></li>
</ul></li>
<li><a href="#iret">iret</a></li>
<li><a href="#cmos-ram">CMOS RAM</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="第一章-基础知识">第一章：基础知识</h1>

<h2 id="汇编语言的组成">汇编语言的组成</h2>

<ol>
<li>汇编指令：机器码助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如 +, -, *, / 等，由编译器识别，没有对应的机器码</li>
</ol>

<h2 id="指令和数据">指令和数据</h2>

<p>指令和数据，是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</p>

<h2 id="存储单元">存储单元</h2>

<p>每个存储单元从0开始顺序编号，这些编号可以看作是存储单元在存储器中的地址。</p>

<p>一个存储单元可以存储一个 Byte(8 bit)</p>

<h2 id="cpu-对存储器的读写">CPU 对存储器的读写</h2>

<p>必须要进行下面3类信息的交互：</p>

<ul>
<li>存储单元的地址（地址信息）=&gt; 地址总线</li>
<li>器件的选择，读或写的命令（控制信息） =&gt; 控制总线</li>
<li>读或写的数据（数据信息）=&gt; 数据总线</li>
</ul>

<h2 id="数据的读写">数据的读写</h2>

<ul>
<li>读： CPU -&gt; 地址总线：3号地址 -&gt; 控制总线信息：读 -&gt; 内存则将3号地址上的数据通过数据总线返回给CPU</li>
<li>写： CPu -&gt; 地址总线：3号地址 -&gt; 控制总线信息：写 -&gt; CPU通过数据总线发送要写的数据给内存的3号单元</li>
</ul>

<h2 id="命令计算机读写">命令计算机读写</h2>

<p>即机器码就是驱动CPU来进行读写的，例如：</p>

<pre><code class="language-bash">MOV AX, [3]
</code></pre>

<p>表示传送3号单元的内容到AX</p>

<h2 id="地址总线">地址总线</h2>

<p>CPU是通过地址总线来指定存储单元的，可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。（即 CPU 的寻址单位是：一个存储单元，即一个字节）</p>

<p>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2^N次方个内存单元（即 2^N 个字节，注意，不是位）</p>

<h2 id="数据总线">数据总线</h2>

<p>数据总线的宽度，决定了CPU与外界的数据传送速度。</p>

<h2 id="控制总线">控制总线</h2>

<p>控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了外部器件的多少种控制。所以，控制总线的宽度，决定了CPU对外部器件的控制能力。</p>

<h2 id="内存地址空间">内存地址空间</h2>

<p>各类存储器，在物理上是独立的器件，但在以下两点上相同：</p>

<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读或写的时候，都通过控制线发出内存读写命令。也就是说，CPU在操控它们的时候，<em>把它们都当作内存对待</em> ，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的 <em>内存地址空间</em></li>
</ul>

<p>在汇编中，我们面对的是 <em>内存地址空间</em> 。CPU对这段内存地址空间中读写数据，实际上就是在相应的物理存储器中读写数据。</p>

<p>即，对于CPU来说，系统中所有存储器中的存储单元，都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的 <em>内存地址空间</em></p>

<h3 id="大小">大小</h3>

<p>内存地址空间的大小，受CPU地址总线宽度的限制。</p>

<h3 id="内存地址空间分配">内存地址空间分配</h3>

<p>基于一个计算机硬件系统编程时，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。</p>

<p>不同的计算机系统的内存地址空间的分配情况是不同的。</p>

<h1 id="第二章-寄存器">第二章：寄存器</h1>

<h2 id="8086-cpu寄存器">8086 CPU寄存器</h2>

<p>共14个（16位）</p>

<p>这四个是通用寄存器（存放一般性的数据），为了兼容性，可以分开使用两个独立的8位寄存器（H后缀表示高8位，L后缀表示低8位）
- AX（AH, AL）
- BX（BH，BL）
- CX（CH，CL）
- DX（DH，DL）</p>

<ul>
<li>SI</li>

<li><p>DI</p></li>

<li><p>SP</p></li>

<li><p>BP</p></li>

<li><p>IP</p></li>

<li><p>CS</p></li>

<li><p>SS</p></li>

<li><p>DS</p></li>

<li><p>ES</p></li>

<li><p>PSW</p></li>
</ul>

<h2 id="字在寄存器中的存储">字在寄存器中的存储</h2>

<p>出于兼容性的考虑，8086CPU一次性处理以下两种尺寸的数据：</p>

<ul>
<li>字节：byte, 即8 bit ，可以存在8位寄存器中</li>
<li>字：word，即2个byte，这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>

<h2 id="物理地址">物理地址</h2>

<p>所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为 <em>物理地址</em> 。</p>

<p>CPU通过地址总线送入存储器的，必须是一个内存单元的 <em>物理地址</em> 。</p>

<p>在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p>

<h2 id="16位的cpu">16位的CPU</h2>

<p>描述了CPU的结构特性：</p>

<ul>
<li>运算器一次最多可以处理16位的数据</li>
<li>寄存器的最大宽度为16位</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>

<h2 id="8086-cpu给出物理地址的方法">8086 CPU给出物理地址的方法</h2>

<p>8086 CPU有20位地址总线，达1MB寻址能力。但 8086CPU又是16位结构的，如果单纯地发出地址的话，那它只能送出16位的地址，表现出的寻址能力只有64KB。</p>

<p>所以，8086CPU 采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>

<p>过程：</p>

<ol>
<li>CPU中相关的部件提供两个16位的地址，一个称为 <em>段地址</em> ，另一个称为 <em>偏移地址</em></li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>
<li>输入输出控制电路将20位物理地址送上地址总线</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>

<p>地址加法器采用： *物理地址=段地址 * 16 + 偏移地址* (即段地址左移4位) 的方法来合成物理地址。</p>

<h2 id="段地址-16-偏移地址-物理地址-的本质含义">段地址 * 16 + 偏移地址 = 物理地址 的本质含义</h2>

<p>即：CPU在访问内存时，用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加，给出内存单元的 <em>物理地址</em> 。即：CPU在访问内存时</p>

<pre><code class="language-bash">基础地址 + 偏移地址 = 物理地址
</code></pre>

<p>为什么需要 *段地址 * 16* 呢？这是因为需要进一位，然后在此基础上再加上偏移地址，这才是正确的物理地址。（这是 8086 CPU 对地址计算的约定）</p>

<h2 id="段寄存器">段寄存器</h2>

<p>8086 CPU有四个段寄存器： CS, DS, SS, ES</p>

<p>段地址在 8086 CPU中由段寄存器存放</p>

<p>CS 和 IP 是8086 CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p>

<p>CS ：为代码段寄存器
IP ：为指令指针寄存器</p>

<p>在 8086 PC机中，任意时刻，假设 CS 中的内容为M， IP中的内容为N，8086CPU将从内存 M*16 + N 单元开始读取一条指令并执行。
即任意时刻，CPU将 CS:IP 指向的内容当作指令执行</p>

<p>即8086 CPU的工作过程简要如下：</p>

<ol>
<li>从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令</li>
<li>执行指令。转至步骤1，重复这个过程</li>
</ol>

<p>在8086CPU加电启动或复位位， CS和IP被设置为 CS=FFFFH， IP=0000H ，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>

<h2 id="修改cs-ip的指令">修改CS，IP的指令</h2>

<p>程序员能够用指令读写的部件只有寄存器，可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令，是由CS，IP中的内容决定的，程序员可以通过改变CS，IP中的内容来控制CPU执行目标指令。</p>

<p>能够改变 CS，IP 的内容的指令被统称为 <em>转移指令</em> ，比如 JMP 指令。</p>

<p>同时改变CS和IP：</p>

<pre><code class="language-bash">jmp 段地址:偏移地址
</code></pre>

<p>只改变IP：</p>

<pre><code class="language-bash">jmp 某一合法寄存器
</code></pre>

<p>对于CPU来说，它只认为 CS:IP 指向的内存单元中的内容为指令。</p>

<h2 id="windows下的-debug-工具">Windows下的 Debug 工具</h2>

<ul>
<li>R: 查看、改变CPU寄存器的内容. <em>r 寄存器</em> 回车，然后输入值，再回车即可修改 <em>寄存器</em> 的值</li>
<li>D: 查看内存中的内容. <em>d 段地址:偏移地址</em>  来查看内存内容。或 <em>d 段地址:偏移地址 结尾偏移地址</em> 或 <em>d 段寄存器:偏移地址</em></li>
<li>E: 改写内存中的内容. <em>e 起始地址 数据1 数据2 数据3 &hellip;</em></li>
<li>U: 将内存中的机器翻译为汇编指令。 <em>u 段地址:偏移地址 结尾偏移地址</em></li>
<li>T: 执行一条机器指令。直接 t 即可，它会执行 CS:IP 指向的指令。</li>
<li>A: 以汇编指令的格式在内存中写入一条机器指令。 <em>a 段地址:偏移地址</em> 后回车，就可以开始以汇编指令的形式，直接向内存写入数据。</li>
</ul>

<p>注意，要想让CPU执行我们的指令，向内存写好汇编指令后，要将 CS和IP 的值指向相应的内存地址。</p>

<h1 id="第三章-寄存器-内存访问">第三章：寄存器（内存访问）</h1>

<h2 id="内存中字的存储">内存中字的存储</h2>

<p>CPU中，用16位寄存器来存储一个字。高8位放在高位字节，低8位放在低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低字节放在低地址单元中，高位字节放在高位地址单元中。</p>

<h2 id="ds和-address">DS和[address]</h2>

<p>8086CPU中，内存地址=段地址+偏移地址 组成。 DS 寄存器通常用来存放要访问数据的段地址。[&hellip;] 表示一个内存单元、表示内存单元的偏移地址。</p>

<p>8086CPU中，自动取 DS 中的数据为内存单元的段地址。</p>

<p>MOV 指令中的 <em>[]</em> 说明操作对象是一个内存单元。<em>[]</em> 中的0，说明这个内存单元的偏移地址是0，它的段地址默认放在 DS 中。</p>

<h2 id="内存的读写">内存的读写</h2>

<h3 id="读">读</h3>

<pre><code class="language-bash">MOV 寄存器, [内存单元地址]
</code></pre>

<h3 id="写">写</h3>

<pre><code class="language-bash">MOV [内存单元地址]，寄存器
</code></pre>

<h2 id="数据段">数据段</h2>

<p>将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用 DS 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。</p>

<h2 id="栈">栈</h2>

<p>LIFO（Last In First Out ，后进先出）</p>

<h2 id="cpu提供的栈机制">CPU提供的栈机制</h2>

<p>8086CPU中提供了相关的指令来以栈的方式访问内存空间。</p>

<ul>
<li>PUSH（入栈）</li>
<li>POP（出栈）</li>
</ul>

<p>它们都是以 <em>字</em> 为单位进行的。</p>

<h3 id="栈顶">栈顶</h3>

<p>8086CPU中，有两个寄存器，段寄存器 SS 和 寄存器 SP，栈顶的段地址放在 SS 中，偏移地址放在 SP 中。</p>

<p>任意时刻， SS:SP 指向栈顶元素。 PUSH 和 POP 指令执行时，CPU从 SS 和 SP 中得到栈顶的地址。</p>

<p>8086CPU中，入栈时， <em>栈顶从高地址向低地址方向增长</em> .</p>

<h3 id="push">PUSH</h3>

<p>PUSH AX 步骤：</p>

<ol>
<li>SP=SP-2 ，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>
<li>将AX中的内容送入 SS:SP 指向的内存单元。SS:SSP 此时指向新栈顶</li>
</ol>

<h3 id="空栈">空栈</h3>

<p>以 10000H~1000FH 这段空间看作栈， 此时 SS=1000H，则SP=？</p>

<blockquote>
<p>换个角度看，任意时刻， SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为 1000:000E ，所以栈空时， SP=0010H</p>
</blockquote>

<h3 id="pop">POP</h3>

<p>pop ax 过程</p>

<ol>
<li>将 SS:SP 指向的内存单元处的数据送入 AX</li>
<li>SP=SP+2， SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>
</ol>

<p>注意，POP 之后，只是将 SP 偏移了而已，原数据仍然会在内存中的，但它已经不在栈中了。当再次 PUSH 后，将会写入新的数据。</p>

<h3 id="栈顶超界的问题">栈顶超界的问题</h3>

<p>8086CPU中，并不会保证我们对栈的操作不会超界。这也就是说，8086CPU，只知道栈顶在何处（由 SS:SP 指示），而不知道我们安排的栈空间有多大。这点好像CPU只知道当前要执行的指令在何处（由 CS:IP 指示），而不知道要执行的指令有多少。</p>

<p>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界；执行出栈的操作时也要注意，以防栈空的时候继续出栈而导致的超界。</p>

<h3 id="pop-和-push-指令">POP 和 PUSH 指令</h3>

<p>它们与 MOV 指令不同， CPU执行 MOV 指令只需要一步。而 PUSH，POP 指令却需要两步。</p>

<p>PUSH：先改变 SP，后向 SS:SP 处传送
POP：先读取 SS:SP 处的数据，后改变 SP</p>

<h3 id="栈段">栈段</h3>

<p>将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就在执行 PUSH 、POP 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。它只是简单地访问 SS:SP 指向的地址当作栈段。</p>

<p>这些完全是我们自己安排的：</p>

<p>我们可以用一个段存放数据，将它定义为 “数据段”；（CS:IP）
我们可以用一个段存放代码，将它定义为 “代码段”；（DS:[])
我们可以用一个段当作栈，将它定义为 “栈段”；(SS:SP)</p>

<p>我们可以这样子安排，但要让CPU按照我们的安排来访问这些段，就要：</p>

<p>对于数据段，将它的段地址放在 DS 中
对于代码段，将它的段地址放在 CS 中
对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP</p>

<blockquote>
<p>注意： Debug  中的 T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行。</p>
</blockquote>

<h1 id="第四章-第一个程序">第四章：第一个程序</h1>

<h2 id="编译">编译</h2>

<p>默认的源码后缀为 <em>.asm</em> ，非这个后缀的，则要写全文件名，包括后缀。</p>

<p>假设源文件为： <em>c:\hello.asm</em></p>

<pre><code class="language-bash">masm c:\hello;
</code></pre>

<h2 id="链接">链接</h2>

<pre><code class="language-bash">link hello;
</code></pre>

<h2 id="调试">调试</h2>

<pre><code class="language-bash">debug hello.exe
</code></pre>

<p>注意，要 <em>hello.exe</em> 是要全名的，不能省略 <em>.exe</em></p>

<h2 id="整个过程">整个过程</h2>

<pre><code class="language-bash">编程 -&gt; 1.asm -&gt; 编译（masm) -&gt; 1.obj -&gt; 链接(link) -&gt; 1.exe -&gt; 加载（command) -&gt; 内存中的程序 -&gt; 运行(CPU)
</code></pre>

<h3 id="dos-的加载过程">DOS 的加载过程</h3>

<ol>
<li>找到一段起始地址为： SA:0000（即起始地址的偏移地址为0）的容量足够的空闲内存区</li>
<li>在这段内存区的前 256 个字节中，创建一个称为程序段前缀（PSP）的数据区， DOS 要利用 PSP 来和被加载程序进行通信</li>
<li>从这段内存区的 256 字节处开始（在PSP后面），将程序装入，程序的地址被设置为 SA + 10H:0 （即 PSP的内容范围就是: SA:0 ~ SA+10H:0</li>
<li>将该内存的段地址存入 DS 中，初始化其他相关寄存器后，设置 CS:IP 指向程序的入口</li>
</ol>

<p>PSP的内容为：</p>

<p><img src="/img/assembly-00.png" alt="img" /></p>

<ol>
<li>程序加载后， DS 中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为 DS:0</li>
<li>这个内存区的前 256 个字节中存放的是 <em>PSP</em> ， DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序</li>
</ol>

<p>所以， 从 DS 中可以得到 PSP 的段地址 SA， PSP 的偏移地址为 0，则物理地址为 SA * 16 + 0
因为 PSP 占 256 （100H）字节，所以程序的物理地址为：</p>

<pre><code class="language-bash">SA * 16 + 0 + 256 = SA * 16 + 16 * 16 + 0 = (SA+16) * 16 + 0

用段地址和偏移地址表示为：
SA + 10H:0
</code></pre>

<h2 id="单任务执行过程">单任务执行过程</h2>

<ol>
<li>由其他程序（debug, command或其他程序），将可执行文件中的程序加载入内存</li>
<li>设置 CS:IP 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行</li>
<li>程序运行结束后，返回到加载者</li>
</ol>

<h1 id="第五章-bx-和-loop指令">第五章：[BX] 和 loop指令</h1>

<p>要完整地描述一个内存单元，需要两种信息</p>

<ol>
<li>内存单元的地址：DS 为段地址， [N] N 为偏移地址</li>
<li>内存单元的长度（类型）：可以由具体指令中其他操作对象（比如说寄存器）指出</li>
</ol>

<p>[BX] 同样也表示一个内存单元，它的偏移地址在 BX 中</p>

<h2 id="loop-指令">loop 指令</h2>

<p>下面2步是自动CPU处理的</p>

<ol>
<li>CX = CX - 1</li>
<li>CX 不为0，则转至标号处执行； 如果为0，则向下执行</li>
</ol>

<blockquote>
<p>汇编源程序中，数据不能以字母开头</p>
</blockquote>

<h2 id="debug-中的-g-命令">debug 中的 G 命令</h2>

<p>它可以让 CPU 一直执行到指定的地址中为止:</p>

<pre><code class="language-bash">G 0012
</code></pre>

<p>即将程序执行到 IP 地址为 0012H 的地方</p>

<h2 id="debug-中的-p-命令">debug 中的 P 命令</h2>

<p>它会自动重复执行循环中的指令，直到 CX = 0 为止 。即在 CS:IP 指向 <em>loop xxx</em> 时，输入 <em>p</em> 命令即可。</p>

<p>当然，也可以用 G 命令来间接实现这个目的</p>

<h2 id="debug-和汇编器-masm-对指令的不同处理">debug 和汇编器 masm 对指令的不同处理</h2>

<p>debug 中:</p>

<pre><code class="language-bash">mov ax, [0]

它表示将 ds:0 处的数据送入 ax 中
</code></pre>

<p>masm 源代码中：</p>

<pre><code class="language-bash">mov ax,[0]

编译后，生成的是 
mov ax, 0
</code></pre>

<p>所以，在 masm 这样子的要显式出给段地址:</p>

<pre><code class="language-bash">mov ax, ds:[0]

或

mov ax, [bx]
这样子它就会默认是 DS:[bx] 了
</code></pre>

<h2 id="一段安全的空间">一段安全的空间</h2>

<p>不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。</p>

<p>不要忘记，我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。如果我们需要向内存空间写入数据的话，要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元，向里面写入。</p>

<p>在CPU保护模式下的操作系统(Windows 2000, Unix)中，硬件已经被这些操作系统利用CPU保护模式所提供的功能全面而严格地管理了。</p>

<h1 id="第六章-包含多个段的程序">第六章：包含多个段的程序</h1>

<p>程序取得所需空间的方法有两种</p>

<ol>
<li>在加载程序的时候为程序分配</li>
<li>程序在执行的过程中向系统申请</li>
</ol>

<h2 id="程序第一条指令">程序第一条指令</h2>

<p>这是由可执行文件中描述信息指明的。</p>

<p>可执行文件由描述信息和程序组成
- 程序来自于源程序中的汇编指令和定义的数据
- 描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息</p>

<h2 id="只用一个段来写代码">只用一个段来写代码</h2>

<pre><code class="language-bash">assume cs:code

code segment
   ...
   数据
   ...

start:
   ...
   代码
   ...
code ends

end start
</code></pre>

<h2 id="多段">多段</h2>

<pre><code class="language-bash">assume cs:code, ds:data, ss:stack

data segment
    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0,0,0
stack ends


code segment

start:
    mov ax, stack
    mov ss, ax
    mov sp, 20h
    mov ax, data
    mov ds, ax
    mov bx, 0
    mov cx, 8

s:  
    push [bx]
    add bx, 2
    loop s

    mov bx,0
    mov cx,8

s0:
    pop [bx]
    add bx,2
    loop s0


    mov ax, 4c00
    int 21h

code ends

end start    
</code></pre>

<h1 id="第七章-更灵活的定位内存地址的方法">第七章：更灵活的定位内存地址的方法</h1>

<h2 id="and-和-or-指令">and 和 or 指令</h2>

<pre><code class="language-bash">mov al,01100011B
add al,00111011B

or al,00111011B
</code></pre>

<h2 id="bx-idata">[bx+idata]</h2>

<p>[bx+idata] 表示一个内存单元，它的偏移地址为 [bx] + idata 。也可以写成如下格式:</p>

<pre><code class="language-bash">mov ax, [200+bx]
或
mov ax, 200[bx]
或
mov ax, [bx].200
</code></pre>

<h2 id="si-和-di">SI 和 DI</h2>

<p>它们和 BX 功能相近。但 SI 和 DI 不能够分成两个8位寄存器来使用。</p>

<h2 id="bx-si-和-bx-di">[bx+si] 和 [bx+di]</h2>

<p>指明内存单元:</p>

<ul>
<li>[bx(si或di)]</li>
<li>[bx(si或di) + idata]</li>
</ul>

<p>也可以:</p>

<ul>
<li>[bx+si]</li>
<li>[bx+di]</li>
</ul>

<p>表示一个内存单元，它的偏移地址为 [bx] + [si] 或 [bx] + [di]</p>

<h2 id="bx-si-idata-和-bx-di-idata">[bx+si+idata] 和 [bx+di+idata]</h2>

<p>表示一个内存单元，它的偏移地址为： [bx] + [si] + idata</p>

<h2 id="寻址方式">寻址方式</h2>

<ul>
<li>[idata] : 用一个常量来表示地址，可用于直接定位一个内存单元</li>
<li>[bx] : 用一个变量来表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+idata] : 用一个变量和常量表示地址，可在一个起始地址的基础上，用变量间接定位一个内存单元</li>
<li>[bx+si或di] : 用两个变量表示地址</li>
<li>[bx+si或di+idata] : 用两个变量和一个常量表示地址</li>
</ul>

<h1 id="第八章-数据处理的两个基本问题">第八章：数据处理的两个基本问题</h1>

<ol>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ol>

<h2 id="bx-si-di-和-bp">bx, si, di 和 bp</h2>

<ol>
<li>只有这4个寄存器可以在 [..] 中进行内存单元的寻址</li>
<li>在 [..] 中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si， bx和di， bp和si, bp和di</li>
<li>在 [..] 中使用寄存器 bp, 而指令中没有显性地给出段地址，段地址默认就在 SS 中</li>
</ol>

<h2 id="机器指令处理的数据在什么地方">机器指令处理的数据在什么地方</h2>

<p>在机器指令这一层，并不关心数据的值是多少，而关心 <em>指令执行前一刻</em> ，它将要处理的数据所在的位置。可以在3个地方：</p>

<ol>
<li>CPU 内部</li>
<li>内存</li>
<li>端口</li>
</ol>

<h2 id="数据位置的表达">数据位置的表达</h2>

<h3 id="立即数">立即数</h3>

<pre><code class="language-bash">mov ax, 1
</code></pre>

<h3 id="寄存器">寄存器</h3>

<pre><code class="language-bash">mov ax, bx
</code></pre>

<h3 id="段地址-sa-和偏移地址-ea">段地址（SA）和偏移地址（EA）</h3>

<pre><code class="language-bash">mov ax, [0]
</code></pre>

<h2 id="寻址方式-1">寻址方式</h2>

<h3 id="直接寻址">直接寻址</h3>

<pre><code class="language-bash">[idata]
</code></pre>

<h3 id="寄存器间接寻址">寄存器间接寻址</h3>

<pre><code class="language-bash">[bx]
[si]
[di]
[bp]
</code></pre>

<h3 id="寄存器相对寻址">寄存器相对寻址</h3>

<pre><code class="language-bash">[bx+idata]
[si+idata]
[di+idata]
[bp+idata]
</code></pre>

<h3 id="基址变址寻址">基址变址寻址</h3>

<pre><code class="language-bash">[bx+si]
[bx+di]
[bp+si]
[bp+di]
</code></pre>

<h3 id="相对基址变址寻址">相对基址变址寻址</h3>

<pre><code class="language-bash">[bx+si+idata]
[bx+di+idata]
[bx+si+idata]
[bp+di+idata]
</code></pre>

<h2 id="要处理数据的长度">要处理数据的长度</h2>

<p>8086CPU 可以处理两种尺寸的数据： byte 和 word</p>

<ol>
<li>通过寄存器名指明处理的数据的尺寸</li>
<li>没有寄存器名存在的情况下， 用 <em>X ptr</em> 指明内存单元的长度，X 可以为 word 或 byte</li>
<li>其他方法。有些指令默认访问的是字单元，还是字节单元。比如 push 就只能进行字单元操作</li>
</ol>

<h2 id="div-指令">div 指令</h2>

<ol>
<li>除数：8位或16位，在一个寄存器或内存单元中</li>
<li>被除数：默认放在AX或DX和AX中。如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位</li>
<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</li>
</ol>

<h2 id="dup">dup</h2>

<pre><code class="language-bash">db 重复次数 dup (重复的字节型数据)
dw 重复次数 dup (重复的字型数据)
dd 重复次数 dup (重复的双字型数据)
</code></pre>

<h1 id="第九章-转移指令的原理">第九章：转移指令的原理</h1>

<p>可以修改 IP 或同时修改 CS 和 IP 的指令统称为 <em>转移指令</em></p>

<ul>
<li><p>只修改IP，称为段内转移，如: jmp ax</p>

<ul>
<li>短转移: IP 修改的范围为: -128 ~ 127</li>
<li>近转移：IP 修改的范围为: -32768 ~ 32767</li>
</ul></li>

<li><p>同时修改 CS 和 IP 称为段间转移，如: jmp 1000:0</p></li>
</ul>

<h2 id="转移指令分类">转移指令分类</h2>

<ul>
<li>无条件转移指令，如 jmp</li>
<li>条件转移指令</li>
<li>循环指令， 如 loop</li>
<li>过程</li>
<li>中断</li>
</ul>

<h2 id="offset">offset</h2>

<p>它是由编译器处理的符号，功能是： 取得标号的偏移地址</p>

<h2 id="jmp-指令">jmp 指令</h2>

<p>要出给两种信息：</p>

<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>

<h2 id="依据位移进行转移的-jmp-指令">依据位移进行转移的 jmp 指令</h2>

<pre><code class="language-bash">jmp short 标号
</code></pre>

<p>它对IP的修改范围为 -128 ~ 127 ，即向前最多 128 个字节， 向后最多 127 个字节。</p>

<p>注意：CPU 执行 JMP 指令的时候，并不需要转移的目的地址。</p>

<pre><code class="language-bash">jmp short 标号
</code></pre>

<p>并不包含转移的目的地址，而包含的是 <em>转移的位移</em> 。这个位移，是编译器根据汇编指令中的 <em>标号</em> 计算出来的。</p>

<h2 id="转移的目的地址在指令中的-jmp-指令">转移的目的地址在指令中的 jmp 指令</h2>

<pre><code class="language-bash">jmp far ptr 标号
</code></pre>

<p>它是段间转移，又称为远转移。它会同时修改 CS 和 IP</p>

<h2 id="转移地址在寄存器中的-jmp-指令">转移地址在寄存器中的 jmp 指令</h2>

<pre><code class="language-bash">jmp 16位寄存器
</code></pre>

<p>功能： IP = 16位寄存器的值</p>

<h2 id="转移地址在内存中的-jmp-指令">转移地址在内存中的 jmp 指令</h2>

<pre><code class="language-bash">jmp word ptr 内存单元地址（段内转移）

jmp dword prt 内存单元地址（段间转移）
</code></pre>

<h2 id="jcxz-指令">jcxz 指令</h2>

<p>它是条件转移指令。
所有的条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为： -128 ~ 127</p>

<p>如果 cx = 0 ，则转移到标号处执行，否则程序向下执行。</p>

<h2 id="loop-指令-1">loop 指令</h2>

<p>它是循环指令。
所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128 ~ 127</p>

<p>CX = CX-1，然后 CX != 0 ，则转移到标号处执行。</p>

<h1 id="第十章-call-和-ret-指令">第十章：CALL 和 RET 指令</h1>

<h2 id="ret-和-retf">ret 和 retf</h2>

<p>ret =&gt; 用栈中的数据，修改IP的内容，从而实现近转移</p>

<ol>
<li>IP = SS * 16 + SP</li>
<li>SP = SP + 2</li>
</ol>

<p>相当于:</p>

<p>pop IP</p>

<p>retf =&gt; 用栈中的数据，修改CS和IP，从而实现远转移</p>

<ol>
<li>IP = SS * 16 + SP</li>
<li>SP = SP + 2</li>
<li>CS = SS * 16 + SP</li>
<li>SP = SP + 2</li>
</ol>

<p>相当于:</p>

<p>pop IP
pop CS</p>

<h2 id="call-指令">call 指令</h2>

<ol>
<li>将当前 IP 或 CS 和 IP 压入栈</li>
<li>转移</li>
</ol>

<p>它不能实现短转移，除此之餐，它和 JMP 指令的原理相同。</p>

<h2 id="依据位移进行转移的-call-指令">依据位移进行转移的 call 指令</h2>

<pre><code class="language-bash">call 标号（将当前IP压入栈后，转移到标号处执行指令）
</code></pre>

<ol>
<li>SP = SP + 2; SS *16 + SP = IP</li>
<li>IP = IP + 16位位移</li>
</ol>

<h2 id="转移的目的地址在指令中的-call-指令">转移的目的地址在指令中的 call 指令</h2>

<pre><code class="language-bash">call far prt 标号
</code></pre>

<p>它是段间转移。</p>

<ol>
<li>SP = SP - 2; SS * 16 + SP = CS; SP = SP - 2; SS * 16 + SP = IP</li>
<li>CS = 标号所在段的段地址； IP = 标号所在段中的偏移地址</li>
</ol>

<p>相当于:</p>

<p>push CS
push IP
jmp far prt 标号</p>

<h2 id="转移地址在寄存器中的-call-指令">转移地址在寄存器中的 call 指令</h2>

<pre><code class="language-bash">call 16位寄存器
</code></pre>

<ol>
<li>SP = SP - 2</li>
<li>SS * 16 + SP = IP</li>
<li>IP = 16位寄存器的值</li>
</ol>

<h2 id="转移地址在内存中的-call-指令">转移地址在内存中的 call 指令</h2>

<p>两种格式：</p>

<ol>
<li>call word prt 内存单元地址</li>
</ol>

<p>push ip
jmp word ptr 内存单元地址</p>

<ol>
<li>call dword prt 内存单元地址</li>
</ol>

<p>push cs
push ip
jmp dword prt 内存单元地址</p>

<h2 id="mul-指令">mul 指令</h2>

<ul>
<li>两个相乘数：要么都是8位，要么都是16位。如果是8位，则一个默认在 AL 中，另一个在 8 位寄存器或内存字节单元中。要么是 16 位，一个默认在 AX 中，另一个在 16 位或内存字节单元中。</li>
<li>结果：8位的话，结果默认在 AX 中； 16 位，则默认高位在 DX 中，低位在 AX 中</li>
</ul>

<pre><code class="language-bash">mul 寄存器
mul 内存单元
</code></pre>

<h1 id="第十一章-标志寄存器">第十一章：标志寄存器</h1>

<p>特殊的寄存器作用：</p>

<ul>
<li>存储相关指令的某些执行结果</li>
<li>为CPU执行相关指令提供行为依据</li>
<li>控制CPU的相关工作方式</li>
</ul>

<p>其他寄存器是用来存放数据的，都是整个寄存具有一个含义。而标志寄存器，是按拉起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>

<h2 id="0-cf">0：CF</h2>

<p>进位标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>

<h2 id="2-pf">2：PF</h2>

<p>奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果1的个数为偶数，则 PF = 1， 如果为奇数，则 PF = 0</p>

<h2 id="4-af">4：AF</h2>

<h2 id="6-zf">6：ZF</h2>

<p>零标志位。它记录相关指令执行后，结果是否为0.如果为0，ZF=1，否则 ZF=0</p>

<h2 id="7-sf">7：SF</h2>

<p>符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，SF = 1， 如果非负， SF = 0</p>

<h2 id="8-tf">8：TF</h2>

<h2 id="9-if">9：IF</h2>

<p>IF = 0，在进入中断处理程序后，禁止其他的可屏蔽中断。
IF = 0，表示中断处理程序需要处理可屏蔽中断。</p>

<pre><code class="language-bash">sti ：设置 IF = 1
cli : 设置 IF = 0
</code></pre>

<h2 id="10-df">10：DF</h2>

<p>方向标志位。在串处理指令中，控制每次操作后 si, di 的增减。</p>

<p>DF = 0 ：每次操作后， si, di 递增
DF = 1 : 每次操作后， si，di 递减</p>

<pre><code class="language-bash">cld 指令：将标志寄存器的 DF 位置0
std 指令：将标志寄存器的 DF 位置1
</code></pre>

<h2 id="11-of">11：OF</h2>

<p>溢出标志位。一般情况下，OF 记录了 <em>有符号</em> 运算的结果是否发生了溢出。如果溢出了， OF = 1 ，如果没有， OF = 0</p>

<p>注意， OF 是对有符号的。CF 是对无符号的</p>

<h2 id="adc-指令">adc 指令</h2>

<p>adc 是带进位加法指令。它利用了 CF 位上记录的进位值。</p>

<pre><code class="language-bash">adc 操作对象1，操作对象2

结果为
操作对象1 = 操作对象1 + 操作对象2 + CF
</code></pre>

<p>利用它，可以对任意大的数据进行加法运算。</p>

<h2 id="sbb-指令">sbb 指令</h2>

<p>它是带借位减法指令，它利用了 CF 位上记录的借位值。</p>

<pre><code class="language-bash">sbb 操作对象1，操作对象2

功能
操作对象1 = 操作对象1 - 操作对象2 - CF
</code></pre>

<p>利用它，可以对任意大的数据进行减法运算。</p>

<h2 id="cmp-指令">cmp 指令</h2>

<p>它相当于减法，只是不保存结果。将对标志寄存器产生影响。</p>

<pre><code class="language-bash">cmp 操作对象1， 操作对象2

功能
操作对象1 - 操作对象2 ，但并不保存结果，仅仅是对标志寄存器进行设置
</code></pre>

<h2 id="检测比较结果的条件转移指令">检测比较结果的条件转移指令</h2>

<p>下面是常用的根据 <em>无符号</em> 数的比较结果进行转移的条件转移指令</p>

<h3 id="je">je</h3>

<p>equal</p>

<p>等于则转移。检测的是 ZF = 1</p>

<h3 id="jne">jne</h3>

<p>not equal</p>

<p>不等于则转移，检测的是 ZF = 0</p>

<h3 id="jb">jb</h3>

<p>below</p>

<p>低于则转移，检测的是 CF = 1</p>

<h3 id="jnb">jnb</h3>

<p>not below</p>

<p>不低于则转移，检测的是 CF = 0</p>

<h3 id="ja">ja</h3>

<p>above</p>

<p>高于则转移。 CF = 0 且 ZF = 0</p>

<h3 id="jna">jna</h3>

<p>not above</p>

<p>不高于则转移。 CF = 1 或 ZF = 1</p>

<h2 id="pushf-和-popf">pushf 和 popf</h2>

<p>pushf ：将标志寄存器的值压栈
popf : 从栈中弹出数据，送入标志寄存器</p>

<h1 id="第十二章-内中断">第十二章：内中断</h1>

<p>中断信息可以来自 CPU 的内部和外部。</p>

<h2 id="中断的产生">中断的产生</h2>

<ul>
<li>除法错误：中断类型码为0</li>
<li>单步执行：中断类型码为1</li>
<li>执行 into 指令：中断类型码为4</li>
<li>执行 int 指令： int N，N为字节型立即数，即提供给CPU的中断类型码</li>
</ul>

<p>8086CPU用称为中断类型码的数据来标识中断信息的来源。</p>

<p>中断类型码为一个字节型数据，可以表示 256 种中断信息的来源。</p>

<h2 id="中断向量表">中断向量表</h2>

<p>CPU用8位的中断类型码通过中断向量表，找到相应的中断处理程序的入口地址。</p>

<p>所谓中断向量，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序的入口地址的列表。</p>

<p>中断向量表在内存中存放。对于 8086CPU，中断向量表指定放在内存地址 0 处。从内存 0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表。</p>

<p>一个表项存放着一个中断向量，也就是一个中断处理程序的入口地址，对于 8086CPU， 这个入口地址包括段地址和偏移地址，所以，一个表项占两个字，高地址存放段地址，低地址存放偏移地址。</p>

<h2 id="中断过程">中断过程</h2>

<p>找到中断入口地址的最终目的是用它设置 CS 和 IP ，使CPU执行中断处理程序。</p>

<p>用中断类型码找到中断向量，并用它设置 CS 和 IP 这个工作是由 CPU 硬件自动完成的。CPU 硬件完成这个工作的过程，称为 中断过程</p>

<p>整个过程如下：</p>

<ol>
<li>取得中断类型码 N</li>
<li>pushf</li>
<li>TF = 0, IF = 0</li>
<li>push CS</li>
<li>push IP</li>
<li>IP = N * 4, CS = N * 4 + 2</li>
</ol>

<h2 id="中断处理程序和-iret-指令">中断处理程序和 iret 指令</h2>

<p>中断处理程序的常规步骤：</p>

<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用 iret 指令返回</li>
</ol>

<p>iret 指令用汇编语法表述为：</p>

<p>POP IP
POP CS
popf</p>

<h2 id="响应中断的特殊情况">响应中断的特殊情况</h2>

<p>举例：CPU在执行完 SS 指令后，不响应中断。</p>

<p>这给连续设置 SS 和 SP 指向正确的栈顶提供了一个时机。</p>

<h1 id="第十三章-int-指令">第十三章：int 指令</h1>

<pre><code class="language-bash">int n
</code></pre>

<p>它的功能是：引发中断号为 N 的中断过程</p>

<h2 id="bios-和-dos-中断例程的安装过程">BIOS 和 DOS 中断例程的安装过程</h2>

<ol>
<li>开机后， CPU一加电，初始化 CS = 0FFFFH， IP=0 ，自动从 FFFF:0 单元开始执行程序。FFFF:0 有一条转跳指令，CPU执行后，转去执行BIOS中的硬件系统检测和初始化程序。</li>
<li>初始化程序将建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到 ROM 中的程序，一直在系统内存中存在。</li>
<li>硬件系统检测和初始化完成后，调用 int 19H 进行操作系统的引导，从此将计算机交由操作系统控制</li>
<li>DOS 启动后，除完成其他工作以外，还将它提供的中断例程装入内存，并建立相应的中断向量</li>
</ol>

<p>BIOS 和 DOS 提供的中断例程，都是用 AH 来传递 <em>内部子程序的编号</em> 。</p>

<h1 id="第十四章-端口">第十四章：端口</h1>

<p>CPU可以直接读写以下3个地方的数据</p>

<ol>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ol>

<h2 id="端口的读写">端口的读写</h2>

<p>它和内存地址一样，通过地址总线来传送。在PC中，CPU最多可定位64KB个不同的端口。则端口地址的范围为 0 ~ 65535</p>

<p>它只有两个指令：</p>

<p>in ：读
out : 写</p>

<p>在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8位时，使用 AL， 16位时， 使用 AX</p>

<h2 id="shl-和-shr-指令">SHL 和 SHR 指令</h2>

<p>SHL 的功能：</p>

<ol>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入 CF 中</li>
<li>最低位用 0 补充</li>
</ol>

<p>SHR 与 SHR 的操作刚好相反</p>

<h1 id="第十五章-外中断">第十五章：外中断</h1>

<p>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。</p>

<h2 id="外中断源">外中断源</h2>

<h3 id="可屏蔽中断">可屏蔽中断</h3>

<p>如果 IF = 1，则CPU执行完当前指令后响应中断，引发中断过程；
如果 IF = 0，则不响应可屏蔽中断</p>

<h3 id="不可屏蔽中断">不可屏蔽中断</h3>

<p>是CPU必须响应的外中断。对于 8086CPU，不可屏蔽中断的中断类型码固定为 2 ，所以，中断过程中，不需要取中断类型码。</p>

<p>几乎所有由外设引发的外中为，都是 <em>可屏蔽中断</em> 。</p>

<h2 id="pc-机键盘的处理过程">PC 机键盘的处理过程</h2>

<p>按下一个键时产生的扫描码称为 <em>通码</em>
松开一个键时产生的扫描码称为 <em>断码</em></p>

<p>扫描码长度为：一个字节。通码的第7位为0，断码的第7位为1 。即：</p>

<p>断码 = 通码 + 80H</p>

<h1 id="杂项">杂项</h1>

<h2 id="显存的物理地址">显存的物理地址</h2>

<pre><code class="language-bash">B8000~BFFFF
</code></pre>

<h2 id="ascii-与-显卡文本模式显示">ASCII 与 显卡文本模式显示</h2>

<p>ASCII 是7位代码，只用了一个字节中的低7比特，最高位通常置0 。这意味着，ASCII只包含 128 个字符的编码。</p>

<p><code>屏幕上的每个字符，对应着显存中的两个连续字节。</code> 前一个字节是字符的ASCII代码，后一个字节是显示属性，包括字符颜色（前景色）和底色（背景色）。</p>

<p>显示属性分为两部分，低4位定义的是前景色，高4位是背景色。
RGBK（背景色），其中K是闪烁位，0为不闪烁，1为闪烁。
RGBL（前景色），其中L是亮度位，0为正常亮度，1为高亮。</p>

<h2 id="mov">MOV</h2>

<p>目的操作数不能为立即数，而且目的操作数和源操作数不允许同时为内存单元。</p>

<h2 id="汇编地址">汇编地址</h2>

<p>它是在源程序编译期间，编译器为每条指令确定的汇编位置，指示该指令相对于程序或段起始处的距离，以字节计算。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。</p>

<h2 id="jmp-near-xxx">jmp near xxx</h2>

<p>jmp near 的操作数并非目标位置的偏移地址，而是目标位置 <em>相对于当前指令处的偏移量（以字节为单位）</em></p>

<p>编译器对它的处理：
用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3)，就得到了 jmp near xxx 指令的实际操作数。</p>

<h2 id="movsb-或-movsw">movsb 或 movsw</h2>

<p>源数据：DS:SI
目的地：ES:DI</p>

<p>CX: 次数</p>

<p>DF标志位：
cld =&gt; 清0，表示传送的是正向（从内存低地址到高地址）
std =&gt; 置1，表示传送的是反向（从内存高地址到低地址）</p>

<p>MOVSB 或 MOVSW 通常与 rep (表示 repeat) 结合使用。</p>

<h2 id="偏移地址">偏移地址</h2>

<p>如果要用寄存器来提供偏移地址，只能使用：</p>

<p>bx, si, di, bp 不能使用其他寄存器。</p>

<h2 id="cbw-或-cwd">cbw 或 cwd</h2>

<p>cbw =&gt; (convert byte to word)，将 AL 中的有符号数扩展到整个AX。如果AL为 10001101，执行完这指令后，AX为 1111111110001101
cbd =&gt; (convert word to double word)，将AX中的有符号数扩展到 DX:AX 。</p>

<h2 id="call-指令-1">call 指令</h2>

<h3 id="相对近调用">相对近调用</h3>

<p>这个是通过符号或立即数（立即数也要减去当前指令的汇编地址）给出的。</p>

<p>计算过程：</p>

<p>用目标过程的汇编地址送去当前 call 指令的汇编地址，于减去当前 call 以字节为单位的长度（3），保留16位的结果。</p>

<pre><code class="language-bash">call near xxx
</code></pre>

<p>near 不是必须的，如果不提供任何关键字，则默认就是 near</p>

<h3 id="绝对近调用">绝对近调用</h3>

<p>这个是通过寄存器或内存单元给出目标地址的。</p>

<h3 id="绝对远调用">绝对远调用</h3>

<pre><code class="language-bash">call xxxx:yyyy
</code></pre>

<h3 id="间接绝对远调用">间接绝对远调用</h3>

<pre><code class="language-bash">call far [xxx]
</code></pre>

<p>它会使用 xxx 处的2个字（注意是字，第一个字是偏移地址，第二个字是段地址）来分别代替IP和CS的内容。</p>

<h2 id="ret-和-retf-1">ret 和 retf</h2>

<p>ret 和 retf 经常用做 call 和  call far 的配对指令。</p>

<p>ret 是近返回：它只做一件事，就是从栈中弹出一个字到指令指针寄存器IP中</p>

<p>retf 是远返回：处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中</p>

<p>call 和 ret , retf 不会影响任何的标志寄存器</p>

<h2 id="jmp">jmp</h2>

<h3 id="相对短转移">相对短转移</h3>

<p>jmp short 标号或数值</p>

<p>用目标地址减去当前指令的汇编地址，再减去当前指令的长度（2），保留一个 <em>字节</em> 的结果（结果是有符号数）</p>

<h3 id="16位相对近转移">16位相对近转移</h3>

<p>jmp near 标号或数值</p>

<p>用目标地址减去当前指令的汇编地址，再减去当前指令的长度（3），保留一个字（16位）的结果。（结果是有符号数）</p>

<h3 id="16位间接绝对近转移">16位间接绝对近转移</h3>

<p>jmp near bx</p>

<p>它也是近转移，即只是段内转移。但目标地址是通过寄存器或内存地址（该地址里的内存内容）给出的</p>

<h3 id="16位直接绝对远转移">16位直接绝对远转移</h3>

<p>jmp xxxx:yyyy</p>

<h3 id="16位间接绝对远转移">16位间接绝对远转移</h3>

<p>标号 dw yyyy, xxxx
jmp far [标号]</p>

<p>注意，第一个字是偏移地址，第二个才是段地址</p>

<p>即相当于转移到 jmp far xxxx:yyyy</p>

<h2 id="iret">iret</h2>

<p>这个是中断返回指令，它会导致处理器依次从栈中弹出（恢复）IP、CS 和 Flags 的原始内容。</p>

<h2 id="cmos-ram">CMOS RAM</h2>

<p>前14个字节分别为：</p>

<p>0x0：秒
0x1：闹钟秒
0x2：分
0x3：闹钟分
0x4：时
0x5：闹钟时
0x6：星期
0x7：日
0x8：月
0x9：年
0xa: 寄存器A
0xb: 寄存器B
0xc: 寄存器C
0xd: 寄存器D</p>

<p>访问需要通过两个端口：</p>

<p>0x70或0x74 =&gt; 它是索引端口，用于指定CMOS RAM的内存单元
0x71或0x75 =&gt; 它是数据端口，用来读写相应的内存单元</p>

<p>比如下面代码就是读取星期几：</p>

<p>MOV  al,0x06
OUT  0x70, al
IN    al, 0x71</p>

<p>我现在是星期四（因为我系统设置了每周第一天为星期天），所以下面的数值为05（实际是我们一般人理解的星期四，只是不同的起始计数不同）</p>

<p><img src="/img/asm-get-week.jpg" alt="img" /></p>

<p>执行完后，可以看到al值为 05 （它是以星期天为开始计数的，即星期一～星期天为， 01~07）</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2017-05-26</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2017/06/02/golang-%E6%B1%87%E7%BC%96%E6%9D%82%E9%A1%B9/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang 汇编杂项</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/2017/05/21/golang%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">
            <span class="next-text nav-default">Golang中遇到的[坑]</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2017-05-26 11:28:44 \x2b0000 UTC',
    title: '《汇编语言》学习笔记',
    link: decodeURI(location.href),
    desc: '第一章：基础知识 汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 \x2b, -, *,',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>








<script src="https://s13.cnzz.com/z_stat.php?id=1273926342&web_id=1273926342"></script>

</body>
</html>
