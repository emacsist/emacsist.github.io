<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>《Erlang/OTP 并发编程实战》读书笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="第一章：Erlang/OTP 平台 Erlang 中，并发的基本单位是进程。" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://emacsist.github.io/2017/04/30/erlang/otp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="《Erlang/OTP 并发编程实战》读书笔记" />
<meta property="og:description" content="第一章：Erlang/OTP 平台 Erlang 中，并发的基本单位是进程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2017/04/30/erlang/otp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2017-04-30T12:55:25+00:00" />
<meta property="article:modified_time" content="2017-04-30T12:55:25+00:00" />
<meta itemprop="name" content="《Erlang/OTP 并发编程实战》读书笔记">
<meta itemprop="description" content="第一章：Erlang/OTP 平台 Erlang 中，并发的基本单位是进程。">


<meta itemprop="datePublished" content="2017-04-30T12:55:25&#43;00:00" />
<meta itemprop="dateModified" content="2017-04-30T12:55:25&#43;00:00" />
<meta itemprop="wordCount" content="12891">



<meta itemprop="keywords" content="erlang," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《Erlang/OTP 并发编程实战》读书笔记"/>
<meta name="twitter:description" content="第一章：Erlang/OTP 平台 Erlang 中，并发的基本单位是进程。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">《Erlang/OTP 并发编程实战》读书笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-04-30 </span>
        <div class="post-category">
            
              <a href="/categories/erlang/"> erlang </a>
            
          </div>
        <span class="more-meta"> 12891 words </span>
        <span class="more-meta"> 26 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#第一章-erlang-otp-平台">第一章：Erlang/OTP 平台</a>
<ul>
<li><a href="#4-种进程通信范式">4 种进程通信范式</a></li>
<li><a href="#erlang-中的进程">Erlang 中的进程</a></li>
<li><a href="#erlang-中的容错架构">Erlang 中的容错架构</a>
<ul>
<li><a href="#进程链接">进程链接</a></li>
<li><a href="#监督与退出信号捕捉">监督与退出信号捕捉</a></li>
</ul></li>
<li><a href="#erlang-运行时系统和虚拟机">Erlang 运行时系统和虚拟机</a>
<ul>
<li><a href="#调度器">调度器</a></li>
<li><a href="#i-o-与调度">I/O 与调度</a></li>
<li><a href="#进程隔离与垃圾回收器">进程隔离与垃圾回收器</a></li>
</ul></li>
</ul></li>
<li><a href="#第二章-erlang-语言精要">第二章：Erlang 语言精要</a>
<ul>
<li><a href="#安装-erlang">安装 Erlang</a></li>
<li><a href="#启动-erlang-shell">启动 Erlang Shell</a>
<ul>
<li><a href="#以非交互式来启动">以非交互式来启动</a></li>
<li><a href="#表达式">表达式</a></li>
<li><a href="#shell-函数">Shell 函数</a></li>
<li><a href="#退出-shell">退出 shell</a>
<ul>
<li><a href="#调用-q-或-init-stop">调用 q() 或 init:stop()</a></li>
<li><a href="#break-菜单">BREAK 菜单</a></li>
<li><a href="#ctrl-g">Ctrl-G</a></li>
</ul></li>
</ul></li>
<li><a href="#erlang-的数据类型">Erlang 的数据类型</a>
<ul>
<li><a href="#数值">数值</a>
<ul>
<li><a href="#字符的数值编码">字符的数值编码</a></li>
<li><a href="#浮点数">浮点数</a></li>
<li><a href="#算术运算">算术运算</a></li>
</ul></li>
<li><a href="#二进制串与位串">二进制串与位串</a></li>
<li><a href="#原子">原子</a></li>
<li><a href="#元组">元组</a></li>
<li><a href="#列表">列表</a>
<ul>
<li><a href="#添加列表元素">添加列表元素</a></li>
</ul></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#标识符-pid-端口和引用">标识符（pid、端口和引用）</a></li>
<li><a href="#fun-函数">Fun 函数</a></li>
</ul></li>
<li><a href="#项式的比较">项式的比较</a>
<ul>
<li><a href="#小于或等于-大于或等于">小于或等于/大于或等于</a></li>
<li><a href="#相等比较">相等比较</a></li>
</ul></li>
<li><a href="#解读列表">解读列表</a>
<ul>
<li><a href="#非严格列表">非严格列表</a></li>
</ul></li>
<li><a href="#模块和函数">模块和函数</a>
<ul>
<li><a href="#调用其他模块中的函数-远程调用">调用其他模块中的函数(远程调用)</a></li>
<li><a href="#不同元数的函数">不同元数的函数</a></li>
<li><a href="#内置函数和标准库模块">内置函数和标准库模块</a></li>
<li><a href="#创建模块">创建模块</a>
<ul>
<li><a href="#编写源文件">编写源文件</a></li>
<li><a href="#模块的编译和加载">模块的编译和加载</a>
<ul>
<li><a href="#在-shell-中编译">在 Shell 中编译</a>
<ul>
<li><a href="#模块加载与代码路径">模块加载与代码路径</a></li>
</ul></li>
<li><a href="#独立编译器-erlc">独立编译器 erlc</a></li>
<li><a href="#效率">效率</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#变量与模式匹配">变量与模式匹配</a>
<ul>
<li><a href="#语法">语法</a></li>
<li><a href="#单次赋值">单次赋值</a>
<ul>
<li><a href="#匹配运算符">匹配运算符 =</a>
<ul>
<li><a href="#变量及其更新">变量及其更新</a></li>
<li><a href="#模式匹配">模式匹配</a>
<ul>
<li><a href="#省略模式">省略模式</a></li>
<li><a href="#匹配模式与子句">匹配模式与子句</a></li>
<li><a href="#case-与-if">case 与 if</a></li>
<li><a href="#if-then-else">if-then-else</a></li>
<li><a href="#if-表达式">if 表达式</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#fun-函数-1">fun 函数</a>
<ul>
<li><a href="#匿名-fun-函数">匿名 fun 函数</a></li>
<li><a href="#闭包">闭包</a></li>
</ul></li>
<li><a href="#异常与-try-catch">异常与 try/catch</a>
<ul>
<li><a href="#抛出异常">抛出异常</a></li>
<li><a href="#try-of-catch">try &hellip; of &hellip; catch</a></li>
<li><a href="#after">after</a></li>
<li><a href="#获取栈轨迹">获取栈轨迹</a></li>
</ul></li>
<li><a href="#列表速构">列表速构</a>
<ul>
<li><a href="#记法">记法</a></li>
<li><a href="#映射-过滤和模式匹配">映射、过滤和模式匹配</a></li>
</ul></li>
<li><a href="#比特位语法与位串速构">比特位语法与位串速构</a>
<ul>
<li><a href="#位串速构">位串速构</a></li>
</ul></li>
<li><a href="#记录语法">记录语法</a>
<ul>
<li><a href="#记录声明">记录声明</a></li>
<li><a href="#创建记录">创建记录</a></li>
<li><a href="#记录字段以及模式匹配">记录字段以及模式匹配</a></li>
</ul></li>
<li><a href="#预处理与文件包含">预处理与文件包含</a>
<ul>
<li><a href="#宏的定义和使用">宏的定义和使用</a></li>
<li><a href="#取消宏定义">取消宏定义</a></li>
<li><a href="#预定义宏">预定义宏</a></li>
<li><a href="#文件包含">文件包含</a>
<ul>
<li><a href="#include-lib-指令">include_lib 指令</a></li>
<li><a href="#条件编译">条件编译</a></li>
</ul></li>
</ul></li>
<li><a href="#进程">进程</a>
<ul>
<li><a href="#操纵进程">操纵进程</a>
<ul>
<li><a href="#派生和链接">派生和链接</a></li>
<li><a href="#进程监视">进程监视</a></li>
<li><a href="#靠抛异常来终结进程">靠抛异常来终结进程</a></li>
<li><a href="#直接向进程发送退出信号">直接向进程发送退出信号</a></li>
<li><a href="#设置-trap-exit-标志">设置 <em>trap_exit</em> 标志</a></li>
</ul></li>
<li><a href="#消息接收与选择性接收">消息接收与选择性接收</a></li>
<li><a href="#注册进程">注册进程</a></li>
<li><a href="#消息投递与信号">消息投递与信号</a></li>
<li><a href="#进程字典">进程字典</a></li>
<li><a href="#ets表">ETS表</a>
<ul>
<li><a href="#ets表的基本用法">ETS表的基本用法</a></li>
</ul></li>
</ul></li>
<li><a href="#以递归代替循环">以递归代替循环</a>
<ul>
<li><a href="#理解尾递归">理解尾递归</a></li>
</ul></li>
</ul></li>
<li><a href="#第三章-开发基于tcp的rpc服务">第三章：开发基于TCP的RPC服务</a>
<ul>
<li><a href="#行为模式">行为模式</a></li>
<li><a href="#测试">测试</a></li>
</ul></li>
<li><a href="#第四章-otp应用与监督机制">第四章：OTP应用与监督机制</a>
<ul>
<li><a href="#otp应用的组织形式">OTP应用的组织形式</a>
<ul>
<li><a href="#为应用添加元数据">为应用添加元数据</a></li>
<li><a href="#application-行为模式">application 行为模式</a></li>
<li><a href="#监督者-行为模式">监督者 行为模式</a></li>
</ul></li>
<li><a href="#生成edoc文档">生成Edoc文档</a></li>
</ul></li>
<li><a href="#第五章-主要图形化监测工具的使用">第五章：主要图形化监测工具的使用</a>
<ul>
<li><a href="#appmon-已经废弃">Appmon（已经废弃）</a></li>
<li><a href="#webtool版appmon">WebTool版Appmon</a></li>
<li><a href="#pman">pman</a></li>
<li><a href="#调试器">调试器</a></li>
<li><a href="#表查看器">表查看器</a></li>
<li><a href="#工具栏">工具栏</a></li>
</ul></li>
<li><a href="#第八章-分布式erlang-otp简介">第八章：分布式Erlang/OTP简介</a>
<ul>
<li><a href="#位置透明性">位置透明性</a></li>
<li><a href="#节点">节点</a></li>
<li><a href="#集群">集群</a>
<ul>
<li><a href="#节点的启动">节点的启动</a></li>
<li><a href="#节点的互联">节点的互联</a></li>
<li><a href="#erlang节点如何定位其他节点并建立通信">Erlang节点如何定位其他节点并建立通信</a></li>
<li><a href="#magic-cookie">magic cookie</a></li>
<li><a href="#远程-shell">远程 shell</a>
<ul>
<li><a href="#退出远程-shell-千万要小心">退出远程 shell 千万要小心</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#第九章-用-mnesia为cache增加分布工支持">第九章：用 Mnesia为cache增加分布工支持</a>
<ul>
<li><a href="#初始化数据库">初始化数据库</a>
<ul>
<li><a href="#启动节点">启动节点</a></li>
<li><a href="#建立数据库模式">建立数据库模式</a></li>
<li><a href="#启动-mnesia">启动 Mnesia</a></li>
<li><a href="#建表">建表</a>
<ul>
<li><a href="#mnesia-表的类型">Mnesia 表的类型</a></li>
<li><a href="#表的存储类型">表的存储类型</a></li>
</ul></li>
<li><a href="#向表录入数据">向表录入数据</a>
<ul>
<li><a href="#事务">事务</a></li>
<li><a href="#脏操作">脏操作</a></li>
</ul></li>
<li><a href="#执行基本查询">执行基本查询</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="第一章-erlang-otp-平台">第一章：Erlang/OTP 平台</h1>

<blockquote>
<p>Erlang 中，并发的基本单位是进程。每个进程代表一个持续的活动，它是某段程序代码的执行代理，与其他按各自的节奏执行自身代码的进程一起并发运行。
进程有自己的工作内存空间和自己的信箱，其中信箱用于存放外来消息。</p>
</blockquote>

<h2 id="4-种进程通信范式">4 种进程通信范式</h2>

<ol>
<li><p>持锁共享内存</p></li>

<li><p>软件事务性内存（STM）</p></li>

<li><p>Future、Promise 以及同类机制</p></li>

<li><p>消息传递</p></li>
</ol>

<h2 id="erlang-中的进程">Erlang 中的进程</h2>

<p>Erlang 进程并不是操作系统线程。它们由 Erlang 运行时系统实现，比线程要轻量得多。运行时系统所有进程之间相互隔离；单个进程的内存不与其他进程共享，也不会被其他濒死或跑疯的进程破坏。</p>

<h2 id="erlang-中的容错架构">Erlang 中的容错架构</h2>

<h3 id="进程链接">进程链接</h3>

<p>Erlang 进程意外退出时，会产生一个 <em>退出信号</em> 。所有与濒死进程链接的进程都会收到这个信号。默认情况下，接收方会一并退出并将信号传播给与它链接的其他进程，直到所有直接或间接链接在一起的进程统统退出为止。这种联级行为，可以使一组进程像单个应用一样退出，因此系统整体重启时你不必担心是否还有残存下来未能完全关闭的进程。</p>

<h3 id="监督与退出信号捕捉">监督与退出信号捕捉</h3>

<p>OTP 实现容错的主要途径之一就是改写退出信号默认的传播行为。通过设置 <em>trap_exit</em> 进程标记，你可以令进程不再服从外来的退出信号，而是捕捉。这类会捕捉信号的进程有时被称为 <em>系统进程</em> （称为监督者） ，其他的进程称为 <em>工作进程</em> 。</p>

<p>Erlang 的进程链接与监督者共同提供了一种细粒度的 <em>重启</em> 机制。OTP 允许监督者按预设的方式和次序来启动进程。我们还可以告知监督者如何在单个进程故障时重启其他进程、一段时间内尝试重启多次后放弃重启等。</p>

<p>而且监督者可以存在多层的 <em>监督树</em> 。</p>

<h2 id="erlang-运行时系统和虚拟机">Erlang 运行时系统和虚拟机</h2>

<p>Erlang 运行时系统（ERTS)，它有一个特别重要的部分就是 Erlang 的虚拟机模拟器：执行 Erlang 程序编译后产出的字节码。这个虚拟机，也就是 Bogdan Erlang 抽象机（BEAM），虽然我们也可以将 Erlang 程序编译为本地机器码，但一般没那个必要，因为 BEAM 模拟器已经够快了。</p>

<h3 id="调度器">调度器</h3>

<p>ERTS 运行的时候通常就是单个操作系统进程（一般名为 beam 或 werl)。这个进程中，就跑着管理所有 Erlang 进程的调度器。</p>

<h3 id="i-o-与调度">I/O 与调度</h3>

<p>调度器还替系统优雅地处理了 I/O 问题，在系统的最底层，Erlang 以事件驱动的方式处理所有 I/O，当数据进出系统时，程序可以以非阻塞方式完成数据处理。这降低了连接建立和断开的频次，还避免了 OS 层面上的加锁开销和上下文切换。</p>

<h3 id="进程隔离与垃圾回收器">进程隔离与垃圾回收器</h3>

<p>它使用了 <em>分代复制式垃圾回收器</em> ，它不会像其他开发的系统那样在 GC 时遭受停顿。这主要因为 Erlang 进程之间的隔离：每个进程所使用的内存都是自己的，随进程的创建和结束而分配和释放。</p>

<p>这首先意味着垃圾回收器可以在不影响其他进程运行的前提下单独暂停目标进程。其次，单个进程占用的内存通常较小，遍历可以快速完成。（也有占用内存量大的进程，但这些进程一般不用做出快速响应）。再次，调度器知道每个进程最后一次运行的时间，如果某个进程自上次垃圾回收后什么也没干，调度器会跳过它。</p>

<p>正是这些因素，让 Erlang 既可轻松使用垃圾回收器，又可以保证较短停顿时间。</p>

<h1 id="第二章-erlang-语言精要">第二章：Erlang 语言精要</h1>

<h2 id="安装-erlang">安装 Erlang</h2>

<pre><code class="language-bash">brew install erlang
</code></pre>

<h2 id="启动-erlang-shell">启动 Erlang Shell</h2>

<p>安装完成后，打开终端， 然后输入 <em>erl</em> 即可:</p>

<pre><code class="language-bash">[15:15:07] emacsist:~ $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt;
</code></pre>

<h3 id="以非交互式来启动">以非交互式来启动</h3>

<pre><code class="language-bash">erl -noshell
</code></pre>

<p>要执行批处理任务或要将 Erlang 作为守护进程运行时可以采用这个方法。</p>

<h3 id="表达式">表达式</h3>

<p>在 shell 中输入的，并不是什么命令，而是 <em>表达式</em> ，它们的区别在于，表达式一定会返回一个求值结果。表达式是以 <em>句号</em> 结束的。比如 <em>42.</em> 。</p>

<p>可以通过 <em>v(N)</em> 来引用第 N 个表达式的结果。</p>

<h3 id="shell-函数">Shell 函数</h3>

<p><em>help()</em> 可以列出所有 shell 函数列表。</p>

<h3 id="退出-shell">退出 shell</h3>

<h4 id="调用-q-或-init-stop">调用 q() 或 init:stop()</h4>

<p>这是最安全的退出方法。</p>

<p><em>q()</em> 是 <em>init:stop()</em> 函数的一个简写形式。</p>

<h4 id="break-菜单">BREAK 菜单</h4>

<p>Unix 系统中按下 <em>Ctrl-C</em> （Windows 下在 werl 终端用 Ctrl-Break)来唤出该菜单:</p>

<pre><code class="language-bash">[15:27:01] emacsist:~ $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt;
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution

</code></pre>

<p>a: 退出系统。
c: 返回shell
p: 显示所有进程信息
i: 显示当前 erlang 系统消息
v: 显示当前运行的 erlang 版本信息
k: 显示所有 Erlang 内部活动进程，以及关闭任何故障进程（前提是你明确知道自己在做什么）</p>

<h4 id="ctrl-g">Ctrl-G</h4>

<p>它会唤出用户开关菜单。</p>

<pre><code class="language-bash">[15:37:56] emacsist:~ $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt;
User switch command
 --&gt; h
  c [nn]            - connect to job
  i [nn]            - interrupt job
  k [nn]            - kill job
  j                 - list all jobs
  s [shell]         - start local shell
  r [node [shell]]  - start remote shell
  q                 - quit erlang
  ? | h             - this message
 --&gt; q
[15:38:10] emacsist:~ $
</code></pre>

<h2 id="erlang-的数据类型">Erlang 的数据类型</h2>

<ol>
<li>数值（整数和浮点数）</li>
<li>二进制串/位串</li>
<li>原子</li>
<li>元组</li>
<li>列表（和字符串）</li>
<li>唯一标识符（pid、端口、引用）</li>
<li>Fun 函数</li>
</ol>

<h3 id="数值">数值</h3>

<p>你可以使用从 2 进制到 36 进制的整数（0～9 加上字符 A~Z/a~z），如:</p>

<pre><code class="language-bash">16#FFFFfF
2#10101
36#ZZ
</code></pre>

<h4 id="字符的数值编码">字符的数值编码</h4>

<p><em>$字符</em> 的格式，可以得到它们的数值编码(ASCII/Latin-1/Unicode 皆可)，如:</p>

<pre><code class="language-bash">4&gt; $a.
97
5&gt; $我.
25105
6&gt;
</code></pre>

<h4 id="浮点数">浮点数</h4>

<p>它是64位双精度浮点数（IEEE 754-1985 格式）。不能仅以小数点开头，如 <em>.01</em> ，必须是以数字开头，如 <em>0.01</em></p>

<h4 id="算术运算">算术运算</h4>

<p>Erlang 采用常见的中缀表示法。如果运算符中有一个是浮点数，则运算将被转化为浮点运算。</p>

<p>除法分两种</p>

<ol>
<li><em>/</em> ，它总是返回浮点数。如 <em>4 / 2</em> 结果为 2.0</li>
<li><em>div</em> ，整除运算（即运算结果会被截断），如 <em>7 div 2</em> 结果为 3</li>
</ol>

<p>取余: rem 。如 <em>15 rem 4</em> 的结果为 3 。</p>

<h3 id="二进制串与位串">二进制串与位串</h3>

<p>二进制串: 无符号 8 位字节的序列
位串：广义的二进制串，其长度不必是 8 的整数倍</p>

<p>语法如下:</p>

<pre><code class="language-bash">&lt;&lt;0,1,2,..., 255&gt;&gt;
</code></pre>

<p>也就是包含在 <em>&lt;&lt;&hellip;&gt;&gt;</em> 内逗号分隔的整数序列，整数取值范围为 0～255 .</p>

<p>还可以用字符串来构造二进制串:</p>

<pre><code class="language-bash">&lt;&lt;&quot;hello&quot;, 32, &quot;dude&quot;&gt;&gt;
</code></pre>

<h3 id="原子">原子</h3>

<p>它是一种仅由字符序列来标识的特殊字符串常量。因此，两个原子只要具有相同的字符表示，就完全等同。</p>

<p>在系统内部，这些字符串放在某张表内，并由表的下标定位，因此在运行时只要比较两个小整数就可以判断两个原子是否相等。每个原子也仅占一个字长的内存。</p>

<p>它的作用类似于 Java 或 C 中的 enum 常量。</p>

<p>你应该把原子当作一类特殊的标签，而不是普通的字符串。它们的长度上限是 255 个字符，在单个系统中原子的总数也有一个上限，目前是一百多万（准确来说是 1048576)。一般来说这个上限已经足够大了，但对于长期运行（数天、数月、数年）的系统，你应该避免动态生成诸如 <em>&lsquo;x_4711&rsquo;</em> 、<em>&lsquo;x_4712&rsquo;</em> 这类全局唯一的原子。</p>

<p>原子一经创建，即便不再使用，也永远不会被清除，除非系统重启。</p>

<h3 id="元组">元组</h3>

<p>它是 <em>定长序列</em> ，用大括号来表示，如:</p>

<pre><code class="language-bash">{1,2,3}
{one, two, three, four}
{}
{from, &quot;Russa&quot;}
</code></pre>

<p>元素可以是同一类型，也可以是不同的数据类型：元素本身也可以是元组或其他数据类型。</p>

<p>Erlang 的一个标准约定是，用原子作为第一个元素来标记元组数据的类别，如:</p>

<pre><code class="language-bash">{size, 42}
{position, 5, 2}
</code></pre>

<p>元组的元素项没有名称，只有编号（从 1到 N）。访问元组中的元素是常数时间复杂度的操作，跟 Java 中访问数组元素一样快速和安全。</p>

<p>标准库中实现了一些更为复杂的数据类型：数组、集合、字典等，但在底层，它们大都是采用各种手段基于元组实现的。</p>

<h3 id="列表">列表</h3>

<p>列表用方括号表示，如:</p>

<pre><code class="language-bash">[]
[1,2,3]
[[1,2,3], [4,5,6]]
[{&quot;hello&quot;}, {&quot;world&quot;}]
</code></pre>

<p>空表 <em>[]</em> 也被称为 <em>nil</em></p>

<h4 id="添加列表元素">添加列表元素</h4>

<p><em>|</em> 管道符，它将右侧的与左侧的合并。如:</p>

<pre><code class="language-bash">[2 | [1]]
</code></pre>

<p>得到列表 <em>[2，1]</em> .注意顺序，新元素是从左侧添加的。</p>

<p>也可以用 <em>++</em> 运算符向列表追加任意长度的列表。如:</p>

<pre><code class="language-bash">[1,2,3,4] ++ [5,6,7,8]
</code></pre>

<p>可以得到列表 [1,2,3,4,5,6,7,8] 。其过程还是一样: 先是 [4 | [5,6,7,8]]，再是 [3|[4,5,6,7,8]]，以此类推。</p>

<p>注意，<em>++</em> 右侧的列表不会被修改——Erlang 不允许这类破坏性修改——它只是借由一个指针成为了一个新列表的一部分。
左侧列表就不一样了。左侧列表的长度决定了 <em>++</em> 运算符的耗时。</p>

<h3 id="字符串">字符串</h3>

<p>Erlang 中双引号字符串实际上就是列表，其元素就是该字符串中各字符的数值编码所对应的整数。比如:</p>

<pre><code class="language-bash">&quot;abcd&quot;
&quot;Hello!&quot;
</code></pre>

<p>它们与以下列表等价:</p>

<pre><code class="language-bash">[97,98,99,100]
[72,101,108,108,111,33]
</code></pre>

<p>还可以写作:</p>

<pre><code class="language-bash">[$a, $b, $c, $d]
[$H, $e, $l, $l, $o, $!]
</code></pre>

<p>字符串就是列表，也就是说你先前学到的所有处理列表的方法，同样也适用于字符串。</p>

<h3 id="标识符-pid-端口和引用">标识符（pid、端口和引用）</h3>

<p>在 Erlang 中任何代码都需要一个 Erlang 进程作为载体才能执行。每个进程都有一个唯一标识符，通常称为 pid 。它是一种特殊的 Erlang 数据类型，应被视为一种不透明对象。<em>self()</em> 函数能告诉你当前进程（即调用 <em>self()</em> 的那个进程）的 pid 。</p>

<pre><code class="language-bash">Eshell V8.3  (abort with ^G)
1&gt; self().
&lt;0.57.0&gt;
2&gt;
</code></pre>

<h3 id="fun-函数">Fun 函数</h3>

<p>函数式语言的一个显著特征就是可以像处理数据一样处理函数——也就是说，函数可以成为别的函数的输入，也可以成为别的函数的求值结果，还可以把函数存在数据结构中供后续使用，诸如此类。在 Erlang 中，将这种函数包装成数据的对象称为 <em>fun 函数</em> （也称为 Lamdba 表达式或闭包）</p>

<h2 id="项式的比较">项式的比较</h2>

<p>Erlang 的各种数据类型有一个共同点：它们都可以通过内置的 &lt;, &gt; 和 == 运算符进行比较和排序。</p>

<p>原子、字符串（以及其他各种列表）和元组：按字典序排序。</p>

<p>不同类型间的排序规则：</p>

<ul>
<li>数值小于原子</li>
<li>元组小于列表</li>
<li>原子既小于元组，也小于列表（注意，字符串也是列表）</li>
</ul>

<p>例如:</p>

<pre><code class="language-bash">3&gt; lists:sort([b,3,a,&quot;z&quot;,1,c,&quot;x&quot;,2.5,&quot;y&quot;]).
[1,2.5,3,a,b,c,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]
4&gt;
</code></pre>

<h3 id="小于或等于-大于或等于">小于或等于/大于或等于</h3>

<p>与其他语言不同的是，小于或等于，它不写作 <em>&lt;=</em> ，而是 <em>=&lt;</em> 。大于或等于同同其他语言一样，都是 <em>&gt;=</em> 。即，比较运算符看起来绝不像箭头就行了。</p>

<h3 id="相等比较">相等比较</h3>

<p>Erlang 有两种比较运算符。</p>

<ol>
<li><p>完全相等，写作 <em>=:=</em> ，仅当运算两侧完全等同（值和类型必须相同）时才返回 true。其否定式为 <em>=/=</em> . 一般来说，判断两个项式是否相等时更倾向于采用完全相等运算符。但这会导致看似相等的整数与浮点数会被判断为不相等，如 2 =:= 2.0 ，它的结果就是 false</p></li>

<li><p>算数相等，写作 <em>==</em> ，按数学法则对数值进行比较时，一般使用它。其否定式为 <em>/=</em> 。例如: 2 == 2.0 返回的就是 true。但请记住，针对浮点做相等判断总是有风险的，浮点数的机器表示法伴有微小的舍入误差，这可能会在本应相等的数值间引入些偏差，使 <em>==</em> 返回 false 。涉及浮点数时，最好只用 &lt;, &gt;, =&lt; 或 &gt;= 进行比较。</p></li>
</ol>

<h2 id="解读列表">解读列表</h2>

<p>列表一般是由空表(nil) 和所谓的列表单元共同构成。这些单元各自携带一个元素挨个儿挂接到现有列表的顶部，从而在内存中形成一个单链表。每个单元仅占两个字长的内存空间：一个用于存放元素值（或指向元素值的指针），称为首部(head)，另一个是指向列表其余部分的指针，称为尾部（tail）（与 Lisp 的非常类似）</p>

<h3 id="非严格列表">非严格列表</h3>

<p>严格列表：最内层都以一个空表作为尾部。</p>

<p>非严格列表：在非列表数据之上堆叠列表单元而成的列表，如:</p>

<pre><code class="language-bash">[1 | oops]
</code></pre>

<p>这就构成了一个尾部不是列表的列表单元（这里 &lsquo;oops&rsquo; 作为尾部）。Erlang 并不禁止这样子做，也不会在运行时对这种情况进行检查。但一般来说，要是看到这样的东西，那多半是程序的某些地方写错了。</p>

<p>非严格列表的主要问题在于，很多函数要求输入参数必须是严格列表。</p>

<h2 id="模块和函数">模块和函数</h2>

<p>Erlang 将模块用作代码的容器。每个模块的名字，都是一个全局唯一的原子。</p>

<h3 id="调用其他模块中的函数-远程调用">调用其他模块中的函数(远程调用)</h3>

<p>如:</p>

<pre><code class="language-bash">lists:reverse([1,2,3])
</code></pre>

<p>与此相对应的是 <em>本地调用</em> （调用同一模块中的函数）。</p>

<p>不要将这里的远程调用与远程过程调用（remote procedure call, RPC) 混淆了。</p>

<h3 id="不同元数的函数">不同元数的函数</h3>

<p>函数参数的个数被称为 <em>元数</em> .没有参数时称为 <em>空元函数</em> ，一个参数的，称为 <em>一元函数</em> , 以此类推。</p>

<p>两个函数使用同一原子作为函数名，只要它们的元数不同，Erlang 就会将它们视作两个完全不同的函数。因此函数的全名必须包含元数（以斜杠作为分隔符）。比如上面的列表反转函数的全名为 <em>reverse/1</em> 。如果还要强调函数所在的模块，则应该为 <em>lists:reverse/1</em> ，不过，这种语法仅用于需要函数名的位置。</p>

<h3 id="内置函数和标准库模块">内置函数和标准库模块</h3>

<p>内置函数（BIF），它们都是用 C 语言实现的。 <em>erlang</em> 模块中的所有函数，都是 BIF。<em>erlang</em> 模块，会被自动导入。即 <em>self()</em> 的全写为 <em>erlang:self()</em></p>

<h3 id="创建模块">创建模块</h3>

<ol>
<li>编写源文件</li>
<li>编译</li>
<li>加载已经编译的模块，或将它放到加载路径中，以便自动加载。</li>
</ol>

<h4 id="编写源文件">编写源文件</h4>

<p><em>my_module.erl</em></p>

<pre><code class="language-bash">%% This is a simple Erlang module

-module(my_module).
-export([pie/0]).

pie() -&gt;
    3.14.
</code></pre>

<p><em>pie() -&gt; 3.14.</em> 它为函数定义。注意，这里并不需要 return ：函数的返回值就是函数体中表达式的值。注意末尾必须要有句号<em>.</em> 。</p>

<p>第一行的 <em>%</em> 表示注释。根据规范，与代码同处一行的注释，以一个 <em>%</em> 开头。独占一行的注释，以两个 <em>%%</em> 开头。</p>

<p>除注释外，第一行一定是模块声明，格式为 <em>-module(&hellip;)</em> 。 Erlang 中不是函数也不是注释的，都是声明。声明以连字符开头（-）, 必须以句号结尾。模块声明是不可或缺的，且它指定的名字，必须与文件名相符（即除去 <em>.erl</em> 后缀以外的部分）</p>

<p><em>-export([&hellip;])</em> 这个是导出声明，它会告知编译器哪些函数是外部可见的。此处没有列出的函数，都是模块的内部函数。</p>

<h4 id="模块的编译和加载">模块的编译和加载</h4>

<p>编译模块时，会产生一个和模块对应的扩展名为 <em>.beam</em> 而非 <em>.erl</em> 的文件，其中包含可被 Erlang 系统加载执行的指令。</p>

<h5 id="在-shell-中编译">在 Shell 中编译</h5>

<p>在 Shell 中，调用函数 <em>c(&hellip;)</em> 来进行自动编译和加载（前提是编译通过）。该函数以 Erlang shell 的当前目录(可以用 <em>ls()</em> 函数列出当前目录列表)为相对路径来寻找源码文件，你甚至可以省略模块末尾的 <em>.erl</em> 。例如:</p>

<pre><code class="language-bash">[17:44:44] emacsist:erlang $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt; ls().
my_module.erl
ok
2&gt; c(my_module).
{ok,my_module}
3&gt; my_module:pie().
3.14
4&gt;
</code></pre>

<h6 id="模块加载与代码路径">模块加载与代码路径</h6>

<p>当 Erlang 尝试调用某个尚未加载到系统中的模块时，只要能找到与模块名对应的 <em>.beam</em> 文件，它就会自动尝试加载。查找 <em>.beam</em> 文件的目录由代码路径指定，默认情况下，当前目录也包括在内。可以调用 <em>code:get_path()</em> 函数查看当前代码路径的设置。</p>

<h5 id="独立编译器-erlc">独立编译器 erlc</h5>

<pre><code class="language-bash">erlc my_module.erl
或
erlc -o ./ebin my_module.erl
</code></pre>

<p>按惯例，存放 <em>.beam</em> 文件的目录应命名为 <em>ebin</em> 。</p>

<h5 id="效率">效率</h5>

<p>注意，不要在 shell 中评估代码的执行效率，一切应该以编译版本为黄金准则。</p>

<h2 id="变量与模式匹配">变量与模式匹配</h2>

<h3 id="语法">语法</h3>

<p>变量名必须以大写字母开头！（小写字母开头的已经被用于原子了），变量中的单词以驼峰体隔开。这种命名的变量在赋值之后一直未被使用的话，会触发编译警告。</p>

<p>变量名也可以以下划线开头，这种情况下，按常规第二个字符通常应该为大写字母。 这种命名的变量，即使不被使用，编译器也不会报警。同时，所有未被使用的变量都会被优化掉。</p>

<blockquote>
<p>不过，好像新版的 Erlang，对这两种情况都会报警，如下：</p>
</blockquote>

<pre><code class="language-bash">[18:02:21] emacsist:erlang $ erlc my_module.erl
my_module.erl:8: syntax error before: _HelloWrold
my_module.erl:9: syntax error before: 3.14
my_module.erl:7: variable 'Helloworld' is unbound
[18:02:34] emacsist:erlang $ vim my_module.erl
Waiting for Emacs...
[18:06:16] emacsist:erlang $ erlc my_module.erl
my_module.erl:9: syntax error before: 3.14
my_module.erl:8: variable '_HelloWrold' is unbound
</code></pre>

<h3 id="单次赋值">单次赋值</h3>

<p>Erlang 的变量被严格地限定为只能接受单次赋值。</p>

<p>在大多数其他编程语言中，变量就像是起了名字的盒子，在程序中你随时可以随性盒子里的内容。Erlang 的变量却与对应的数学概念相符：它就是指代某个值的一个名字，且这种指代关系不会背地里悄悄地改变（否则方程就解不出来了）。</p>

<h4 id="匹配运算符">匹配运算符 =</h4>

<p>它的能力可不止是简单的赋值。</p>

<p>如:</p>

<pre><code class="language-bash">X = 42.
</code></pre>

<p>在 shell 中，可以调用函数 <em>f()</em> 来让 shell 遗忘先前绑定的所有变量，或遗忘指定的变量: <em>f(变量名)</em></p>

<p><em>匹配</em> 的含义：如果 X 已经被绑定到某个值，匹配运算符会检查右侧的值是否与之相等（比较时使用的是 *完全相等运算符*）</p>

<h5 id="变量及其更新">变量及其更新</h5>

<p>要想追踪其他值，就给它另起一个名字。例如:</p>

<pre><code class="language-bash">X = 17.
X1 = X + 1.
</code></pre>

<h5 id="模式匹配">模式匹配</h5>

<p><em>=</em> 就是匹配运算符，因为它的功能就是模式匹配，而不是赋值。</p>

<p>运算符的左侧，是一个模式；右侧，是一个普通表达式。做匹配运算时，首先计算右侧的表达式，得到一个值。接着拿该值去匹配左侧的模式。若模式匹配不上，比如: 17 = 42或 true = false ，则匹配宣告失败并抛出一个原因代码(reason code) 为 <em>badmatch</em> 的异常。若成功，在左侧模式中出现的所有变量都会与右侧值中的相应组成部分绑定，然后程序将继续计算紧随其后的表达式。如:</p>

<pre><code class="language-bash">{A, B, C} = {1970, &quot;Richard&quot;, male}.
</code></pre>

<p>另一种常见的模式为:</p>

<pre><code class="language-bash">{rectangle, Width, Height} = {rectangle, 200, 100}.
</code></pre>

<p>再多几个例子：</p>

<pre><code class="language-bash">[1,2,3 | Rest] = [1,2,3,4,5,6,7]
</code></pre>

<p>这样子, Rest 就为 [4，5，7，7] 了。</p>

<pre><code class="language-bash">[$h, $t, $t, $p, $: | Rest] = &quot;http://www.erlang.org&quot;
</code></pre>

<p>这时，Rest 绑定到了字符串 <em>//www.erlang.org</em> 了。</p>

<h6 id="省略模式">省略模式</h6>

<p>单下划线：<em>_</em> 表示省略模式，也就是说，在模式的某处用上 <em>_</em> 的话就表示你不关心右侧相应位置上的值。它们也被称为 <em>匿名变量</em> 。</p>

<h6 id="匹配模式与子句">匹配模式与子句</h6>

<p>子句由分号(;)分隔，且最后一个子句由句号结尾。如:</p>

<pre><code class="language-bash">either_or_both(true, _) -&gt;
    true;
either_or_both(_, true) -&gt;
    true;
either_or_both(false,false) -&gt;
    false.
</code></pre>

<h6 id="case-与-if">case 与 if</h6>

<pre><code class="language-bash">area(Shape) -&gt;
    case Shape of 
        {circle, Radius} -&gt;
            Radius * Radius * math:pi();
        {square, Side} -&gt;
            Side * Side;
        {rectangle, Height, Width} -&gt;
            Height * Width
    end.
</code></pre>

<p>注意，最后一个子句后没有分号——分号是分隔符，而不是结束符。</p>

<h6 id="if-then-else">if-then-else</h6>

<p>根本没这玩意。你可用 case 表达式来替代：</p>

<pre><code class="language-bash">case either_or_both(X,Y) of
    true -&gt; io:format(&quot;yes~n&quot;);
    false -&gt; io:format(&quot;no~n&quot;)
end.    
</code></pre>

<h6 id="if-表达式">if 表达式</h6>

<pre><code class="language-bash">sign(N) when is_number(N) -&gt;
    if
        N &gt; 0 -&gt; positive;
        N &lt; 0 -&gt; negative;
        true -&gt; zero
    end.
</code></pre>

<p>或</p>

<pre><code class="language-bash">sign(N) when is_number(N) -&gt;
    case dummy of
        _ when N &gt; 0 -&gt; positive;
        _ when N &lt; 0 -&gt; negative;
        _ when true -&gt; zero
    end.
</code></pre>

<h2 id="fun-函数-1">fun 函数</h2>

<p>作为现有函数别名的 fun 函数：</p>

<pre><code class="language-bash">fun either_or_both/2
</code></pre>

<p>和各种其他类型的值一样，你可以将之与变量绑定:</p>

<pre><code class="language-bash">F = fun either_or_both/2
</code></pre>

<p>或传递给别的函数:</p>

<pre><code class="language-bash">yesno(fun either_or_both/2)

yesno(F) -&gt;
    case F(true, false) of
        true -&gt; io:format(&quot;yes~n&quot;);
        false -&gt; io:format(&quot;no~n&quot;)
    end.
</code></pre>

<h3 id="匿名-fun-函数">匿名 fun 函数</h3>

<p>也称为 Lamdba 表达式。它们以 <em>fun</em> 关键字开头，并且以 <em>end</em> 关键字结束。例如:</p>

<pre><code class="language-bash">fun () -&gt; 0 end
</code></pre>

<h3 id="闭包">闭包</h3>

<p>一般特指: <em>fun&hellip;end</em> 的内部引用了在 fun 函数外部绑定的变量的情况。fun 函数能将那些变量当前的值封存起来。</p>

<h2 id="异常与-try-catch">异常与 try/catch</h2>

<blockquote>
<p>异常是什么呢？你可以将之认为是函数的另一种返回形式，区别在于它不仅会返回至调用者，还会返回至调用者的调用者，并一路向上，直至被捕获或抵达进程调用的起点（这时进程便会崩溃）为止。</p>
</blockquote>

<p>异常的类别:</p>

<ul>
<li>error ：运行时异常，除零错误、匹配运算失败、找不到匹配的函数子句等情况时触发。一旦它们导致某个进程崩溃，Erlang 错误日志管理器便会将之记录。</li>
<li>exit ：用于通报：“进程即将停止”。它们会在迫使进程崩溃的同时将进程退出的原因告知其他进程，因此一般不捕获这类异常。它不会被汇报至错误日志管理器。</li>
<li>throw ：用于处理用户自定义的情况。如果不捕获 throw 异常，它便会转变为一个原因为 nocatch 的 error 异常，迫使进程终止并记录日志。</li>
</ul>

<h3 id="抛出异常">抛出异常</h3>

<pre><code class="language-bash">throw(SomeTerm)
exit(Reason)
erlang:error(Reason)
</code></pre>

<p>特例：<em>exit(normal)</em> 所抛出的异常不会被捕获。这意味着其他与之链接的进程不会将之视为反常的终止行为。（其余的所有退出原因都会被视作反常）</p>

<h3 id="try-of-catch">try &hellip; of &hellip; catch</h3>

<pre><code class="language-bash">try
    some_unsafe_function(...)
of
    0 -&gt; io:format(&quot;nothing to do ~n&quot;);
    N -&gt; do_something_with(N)
catch
    _:_ -&gt; io:format(&quot;some problem~n&quot;)
end
</code></pre>

<h3 id="after">after</h3>

<blockquote>
<p>类似Java中的finally</p>
</blockquote>

<pre><code class="language-bash">{ok, FileHandle} = file:open(&quot;foo.txt&quot;, [read]),
try
    do_something_with_file(FileHandle)
after
    file:close(FileHandle)
end    
</code></pre>

<h3 id="获取栈轨迹">获取栈轨迹</h3>

<p><em>erlang:get_stackrace()</em> ： 是异常发生那一刻位于栈顶部的那些调用的逆序列表（最后一个位于最前）。如果它返回的是一个空表，表示直至目前为止该进程尚未捕获任何异常。</p>

<h2 id="列表速构">列表速构</h2>

<h3 id="记法">记法</h3>

<p>如:</p>

<pre><code class="language-bash">[X || X &lt;- ListOfIntegers, X &gt; 0]
</code></pre>

<p>此处必须用双竖线 <em>||</em> ,因为单竖线已经被用在普通列表单元上了。 用 <em>&lt;-</em> 来表示生成器， <em>||</em> 右侧除了生成器，便是约束条件，如 X &gt; 0</p>

<h3 id="映射-过滤和模式匹配">映射、过滤和模式匹配</h3>

<pre><code class="language-bash">[ math:pow(X,2) || X &lt;- ListOfIntegers, X &gt; 0, X rem 2 == 0]
</code></pre>

<h2 id="比特位语法与位串速构">比特位语法与位串速构</h2>

<p>位串可以写作: &lt;<Segment1, ..., Segment_N>&gt; ，区段指示符可以为以下形式之一:</p>

<pre><code class="language-bash">Data
Data:Size
Data/TypeSpecifiers
Data:Size/TypeSpecifiers
</code></pre>

<h3 id="位串速构">位串速构</h3>

<pre><code class="language-bash">3&gt; &lt;&lt; &lt;&lt;X:3&gt;&gt; || X &lt;- [1,2,3,4,5,6,7] &gt;&gt;.
&lt;&lt;41,203,23:5&gt;&gt;
4&gt;
</code></pre>

<h2 id="记录语法">记录语法</h2>

<h3 id="记录声明">记录声明</h3>

<pre><code class="language-bash">-record(customer, {name=&quot;&lt;anonymous&gt;&quot;, address, phone}).
</code></pre>

<h3 id="创建记录">创建记录</h3>

<pre><code class="language-bash">#customer{}
#customer{phone=&quot;12341234&quot;}
</code></pre>

<h3 id="记录字段以及模式匹配">记录字段以及模式匹配</h3>

<p>假设R变量绑定了一个 customer  记录，你可以使用点分记法来访问各个字段：</p>

<pre><code class="language-bash">R#customer.name
R#customer.address
</code></pre>

<h2 id="预处理与文件包含">预处理与文件包含</h2>

<h3 id="宏的定义和使用">宏的定义和使用</h3>

<p>宏由 <em>define</em> 指令定义，既可带参数，也可以不带参数。如：</p>

<pre><code class="language-bash">-define(PI, 3.14).
-define(pair(X,Y), {X, Y}).
</code></pre>

<p>习惯上常量名为大写，其余大部分宏为小写。在代码中使用宏时，必须加一个问号作为前缀：</p>

<pre><code class="language-bash">circumference(Radius) -&gt; Radius * 2 * ?PI.
</code></pre>

<h3 id="取消宏定义">取消宏定义</h3>

<p><em>undef</em> 可用于移除宏定义（前提是该宏定义存在）如:</p>

<pre><code class="language-bash">-define(foo, false).
-undef(foo).
-define(foo, true).
</code></pre>

<h3 id="预定义宏">预定义宏</h3>

<p>为了方便，预处理器先定义了一些宏。如:</p>

<p><em>MODULE</em> 宏（表示当前正在编译的模块的名称）， <em>FILE</em> 宏（当前正在哪个文件中）和 <em>LINE</em> 宏（当前正身处哪个源文件的哪一行）</p>

<h3 id="文件包含">文件包含</h3>

<pre><code class="language-bash">-include(&quot;filename.hrl&quot;).
</code></pre>

<p>这类文件通常只有声明，没有函数；一般出现在模块源文件的头部，因此这些文件被称为 <em>头文件</em> ，以 <em>.hrl</em> 为扩展名。查找这类文件时，Erlang 编译器会同时在当前目录中以及列于 <em>包含路径</em> 内的目录中查找名为 <em>some_file.hrl</em> 的文件。</p>

<p>利用 <em>erlc</em> 的 <em>-I</em> 标志，或shell函数 <em>c(&hellip;)</em> 的 <em>{i, Directory}</em> 选项可以向包含路径中添加新目录。如:</p>

<pre><code class="language-bash">1&gt; c(&quot;src/my_module&quot;, [{i, &quot;../include&quot;}]).
</code></pre>

<h4 id="include-lib-指令">include_lib 指令</h4>

<pre><code class="language-bash">-include_lib(&quot;kernel/inclue/file.hrl&quot;).
</code></pre>

<p>该指令会相对于Erlang系统现有应用的安装位置来查找文件。比如 kernel 应用可能被安装在 C:\Program Files\erl5.6.5\lib\kernel-2.12.5 。于是 include_lib 指令会将文件起始处的 kernel/ 匹配至这个路径（除去版本号）并在此目录下寻找含有 file.hrl 的子目录 include 。即便Erlang升级，你的程序也不用做任何修改。</p>

<h4 id="条件编译">条件编译</h4>

<pre><code class="language-bash">-ifdef(MacroName).
-ifndef(MacroName).
-else.
-endif.
</code></pre>

<p>例如:</p>

<pre><code class="language-bash">-ifdef(DEBUG)
-export([foo/1]).
-endif.
</code></pre>

<p>你可以通过shell函数c的 {d, MacroName, Value} 选项或 erlc 命令的 -Dname=value 选项来进行控制。</p>

<h2 id="进程">进程</h2>

<h3 id="操纵进程">操纵进程</h3>

<h4 id="派生和链接">派生和链接</h4>

<p>它有两个函数。第一个函数仅有一个参数，就是作用新进程入口的（空元）fun函数。另一个则需要模块名、函数名、和参数列表3个参数：</p>

<pre><code class="language-bash">Pid = spawn(fun() -&gt; do_something() end)
Pid = spawn(Module, Function, ListOfArgs)
</code></pre>

<p>还有一个名为 <em>spawn_opt(&hellip;)</em> 的版本，如:</p>

<pre><code class="language-bash">Pid = spawn_opt(fun() -&gt; do_something() end, [monitor])
</code></pre>

<p>以及：</p>

<pre><code class="language-bash">Pid = spawn_link(...)
</code></pre>

<p>所有这些派生函数都会返回新进程的进程标识符，通过该标识符，父进程可以与新进程通信。但新进程对父进程却不无所知，只能通过其他方式来获取相关信息。</p>

<h4 id="进程监视">进程监视</h4>

<pre><code class="language-bash">Ref = monitor(process, Pid)
</code></pre>

<p>由Pid标识的进程一旦退出，实现监视的进程将会收到一条含有引用Ref的消息。</p>

<h4 id="靠抛异常来终结进程">靠抛异常来终结进程</h4>

<pre><code class="language-bash">exit(Reason)
</code></pre>

<p>除非被进程捕获，否则该调用将令进程终止，并将Reason作为退出信号的一部分发送给所有与该进程链接的进程。</p>

<h4 id="直接向进程发送退出信号">直接向进程发送退出信号</h4>

<pre><code class="language-bash">exit(Pid, Reason)
</code></pre>

<h4 id="设置-trap-exit-标志">设置 <em>trap_exit</em> 标志</h4>

<p>默认情况下，一旦接收来自相互链接的其他进程的退出信号，进程就会退出。为了避免这种行为并捕捉退出信号，进程可设置 <em>trap_exit</em> 标志：</p>

<pre><code class="language-bash">process_flag(trap_exit, true)
</code></pre>

<p>这样除了无法捕捉的信号(kill)，外来的退出信号都会被转换为无害的消息。</p>

<h3 id="消息接收与选择性接收">消息接收与选择性接收</h3>

<p>可以用 <em>receive</em> 表达式从信箱中提取消息。尽管接收到的消息严格按照抵达顺序排列，接收方仍然可以自行决定要提取哪条消息。</p>

<pre><code class="language-bash">receive
    Pattern1 when Guard1 -&gt; Body1;
    ...
    PatternN when GuardN -&gt; BodyN
after Time -&gt;
    TimeoutBody
end
</code></pre>

<p><em>after&hellip;</em> 为可选，如果省略，表示永不超时。否则 Time 必须是表示 <em>毫秒</em> 的整数或原子 <em>infinity</em> 。如果 Time 为 0，表示永不阻塞。</p>

<h3 id="注册进程">注册进程</h3>

<p>每个Erlang系统都有一个本地进程注册表——这是一个用于注册进程的简单命名服务。一个名称一次只能用于一个进程。换言之，该机制仅适用于单例进程：一般都是些系统服务，这些服务在每个运行时系统中，同一时刻最多只能有一个实例。在 Erlang shell中调用内置函数 <em>registered()</em> 可以列出它们。</p>

<pre><code class="language-bash">4&gt; registered().
[erts_code_purger,init,error_logger,erl_prim_loader,
 kernel_safe_sup,standard_error_sup,inet_db,rex,user_drv,
 kernel_sup,global_name_server,global_group,user,
 file_server_2,code_server,application_controller,
 standard_error]
5&gt;
</code></pre>

<p>用内置函数 <em>whereis</em> 可以查找当前与指定注册名对应的 pid:</p>

<pre><code class="language-bash">4&gt; registered().
[erts_code_purger,init,error_logger,erl_prim_loader,
 kernel_safe_sup,standard_error_sup,inet_db,rex,user_drv,
 kernel_sup,global_name_server,global_group,user,
 file_server_2,code_server,application_controller,
 standard_error]
5&gt; whereis(user).
&lt;0.49.0&gt;
6&gt;
</code></pre>

<p>你甚至可以直接用注册名向进程发送消息：</p>

<pre><code class="language-bash">6&gt; init ! {stop, stop}.
{stop,stop}
7&gt; %                                                                                                                                                                             [22:59:14] emacsist:erlang $
</code></pre>

<p>你也可以用 <em>register</em> 函数注册自己启动的进程:</p>

<pre><code class="language-bash">[23:02:18] emacsist:erlang $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt; Pid = spawn(timer, sleep, [30000]).
&lt;0.59.0&gt;
2&gt; register(fred, Pid).
true
3&gt; whereis(fred).
&lt;0.59.0&gt;
4&gt; whereis(fred).
undefined
5&gt;
</code></pre>

<p>进程退出后，之前注册的名称将自动回归到未定义状态。如果你想跟位于另一个Erlang 节点上的注册进程通信，可以这样子做:</p>

<pre><code class="language-bash">{some_node_name, some_registered_name} ! Message
</code></pre>

<h3 id="消息投递与信号">消息投递与信号</h3>

<p>Erlang进程互相用 <em>!</em> 运算符发送的消息只是Erlang通用信号系统的一种特殊形式。另一大类信号就是濒死进程向与之链接的相邻进程发送的退出信号；还有一小部分对程序员不可见，诸如尝试链接两个进程时发送的链接请求。投递信号时，以下的基本投递保障对所有信号都成立：</p>

<ul>
<li>如果进程P1向目标进程P2先后发送了两个信号S1和S2，这两个信号将按发送顺序到达P2（如果都能到达的话）。</li>
<li>尽力投递所有信号。同一Erlang运行时系统内，进程之间不存在消息丢失的危险。但，两个依靠网络互联的Erlang系统之间，一旦网络连接断开，消息就有可能丢失。连接恢复后，有可能出现上例的S2最终抵达，但S1却丢失的情况。</li>
</ul>

<h3 id="进程字典">进程字典</h3>

<p>每一个进程都有一个私有的进程字典。通过内置函数 put(Key, Value) 和 get(Key, Value) 可以从中存取项式。无论进程字典看上去多么诱人都不要去碰它。</p>

<h3 id="ets表">ETS表</h3>

<p>ETS(Erlang Term Storage)，用于存储Erlang项式（即任意Erlang数据）且可以在 <em>进程间共享</em> 的表。它作为Erlang运行时系统的一部分，用C实现的。原因在于ETS是Erlang中很多东西的基础。</p>

<h4 id="ets表的基本用法">ETS表的基本用法</h4>

<p>创建新表: <em>ets:new(Name, Options)</em> .Name必须是原子，Options必须是列表。除非设置 named_table 选项，否则名称不起实际作用。ets:new/2 会返回一个标识符，用于完成针对新创建的表的各种操作，如:</p>

<pre><code class="language-bash">T = ets:new(mytable, []),
ets:insert(T, {17, hello}),
ets:insert(T, {42, goodbye})
</code></pre>

<p>ETS表和数据库的另一个相似点在于，它同样只存储数据行——也就是元组。存储任何Erlang数据之前，都要先将之放入元组。原因在于, ETS会将元组中的一个字段用作表索引，默认采用第一个字段（可通过建表参数调整）</p>

<h2 id="以递归代替循环">以递归代替循环</h2>

<p>比如从0到N的累加和：</p>

<pre><code class="language-bash">sum(0) -&gt; 0;
sum(N) -&gt; sum(N-1) + N.
</code></pre>

<p>Erlang与其他语言不同，它仅靠递归就可以创建循环，而且没有效率问题。</p>

<pre><code class="language-bash">[13:05:30] emacsist:erlang $ cat hello.erl
-module(hello).
-export([start/0]).

start() -&gt;
    io:format(&quot;~p~n&quot;, [sum(100000000)]).

sum(0) -&gt; 0;
sum(N) -&gt; sum(N-1) + N.



[12:55:27] emacsist:erlang $ time erl -noshell -run hello start -s init stop
5000000050000000
erl -noshell -run hello start -s init stop  14.58s user 20.07s system 83% cpu 41.598 total
</code></pre>

<h3 id="理解尾递归">理解尾递归</h3>

<p>上面那个就是 <em>非尾递归</em> （因为含有非尾递归调用）。
<em>尾递归</em> ：所有递归调用都是 <em>尾调用</em> ，编译器总能从代码中准确地定位尾调用，并做出一些相应的特殊处理。</p>

<p>Erlang 是怎么仅靠递归来实现循环的呢？每次调用不是都要往栈上写入新的内容吗？答案是否定的，因为Erlang采用了 <em>尾调用优化</em> .正是基于这个原因，尾递归函数即使不停地运行也不会将栈空间耗尽，同时还能达到和 while 循环一样高效。</p>

<h1 id="第三章-开发基于tcp的rpc服务">第三章：开发基于TCP的RPC服务</h1>

<h2 id="行为模式">行为模式</h2>

<p>使用 OTP 行为模式。</p>

<ul>
<li>行为模式接口， 是一组特定函数和相关的调用规范。</li>
<li>行为模式实现， 指的是由程序员提供具体应用相关的代码。是一个导出了接口所需要的全部函数的回调模块。实现模块中，还应包含一项属性 <em>-behaviour(&hellip;)</em> 用以说明该模块所实现的行为模式的名称。</li>
<li>行为模式容器， 它执行的是某个库模块中的代码，并且会调用与行为模式实现相对应的回调模块来处理应用相关的逻辑。</li>
</ul>

<h2 id="测试">测试</h2>

<p><em>EUnit</em> （单元测试）和 <em>Common Test</em> （OTP Test Server) 比较重型。</p>

<p>EUnit使用：</p>

<pre><code class="language-bash">-include_lib(&quot;eunit/include/eunit.hrl&quot;).


%写你的测试代码:

start_test() -&gt;
    {ok, _} = tr_server:start_link(1005).
</code></pre>

<p>然后在 erlang shell中输入:</p>

<pre><code class="language-bash">eunit:test(tr_server).
或
tr_server:test().
</code></pre>

<p><em>test()</em> 函数是由Eunit 自动生成的，同时Eunit会自动导出你编写的所有测试函数。</p>

<h1 id="第四章-otp应用与监督机制">第四章：OTP应用与监督机制</h1>

<h2 id="otp应用的组织形式">OTP应用的组织形式</h2>

<pre><code class="language-bash">[12:51:01] emacsist:erlang $ tree my-otp-app-1.0.0
my-otp-app-1.0.0
├── doc
├── ebin
├── include
├── priv
└── src

5 directories, 0 files
[12:51:05] emacsist:erlang $
</code></pre>

<p>其中，只有 <em>ebin</em> 是必需的。</p>

<h3 id="为应用添加元数据">为应用添加元数据</h3>

<p>在 <em>ebin</em> 目录，建立一个名为 <em><application-name>.app</em> 的文本文件，它用来描述你的应用。</p>

<p>它的作用在于告诉OTP如何启动应用，以及该应用如何与系统中的其他应用相融合。即组装更大的可启动、停止、监督和升级的功能单元。</p>

<h3 id="application-行为模式">application 行为模式</h3>

<p>该模块通常命名为 <em><application-name>_app</em></p>

<h3 id="监督者-行为模式">监督者 行为模式</h3>

<p>根监督者行为模式，该模块通常命名为 <em><application-name>_sup</em></p>

<h2 id="生成edoc文档">生成Edoc文档</h2>

<p>打开 erlang shell</p>

<pre><code class="language-bash">edoc:application(your-server-name, &quot;目录 .表示当前目录&quot;, []).
</code></pre>

<p>它会将生成的文档，放到 doc 目录下.</p>

<h1 id="第五章-主要图形化监测工具的使用">第五章：主要图形化监测工具的使用</h1>

<h2 id="appmon-已经废弃">Appmon（已经废弃）</h2>

<p>打开 erlang shell ，输入:</p>

<pre><code class="language-bash">appmon:start().
</code></pre>

<p>注：如果上面的命令执行不了，请用 <em>observer:start().</em> ，这个是新版 erlang 的替代者。</p>

<h2 id="webtool版appmon">WebTool版Appmon</h2>

<pre><code class="language-bash">webtool:start().
</code></pre>

<p>我在mac上打不开。这个暂时查资料也没有见什么原因。到时再看看&hellip;</p>

<pre><code class="language-bash">[13:35:03] emacsist:lib $
[13:35:03] emacsist:lib $ erl
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
1&gt; webtool:start().
** exception error: undefined function webtool:start/0
2&gt;
</code></pre>

<h2 id="pman">pman</h2>

<pre><code class="language-bash">pman:start().
</code></pre>

<p>好像这个也没有用了。我的erlang版本为</p>

<pre><code class="language-bah">Erlang (BEAM) emulator version 8.3
Compiled on Wed Mar 15 18:06:57 2017
</code></pre>

<h2 id="调试器">调试器</h2>

<pre><code class="language-bash">debugger:start().
</code></pre>

<p>要调试时，在编译时要加上调试信息选项:</p>

<pre><code class="language-bash">erlc +debug_info -o ebin src/*.erl
</code></pre>

<p>然后在上面 <em>debugger:start().</em> 弹出的窗口中，选择 <em>Module-Interpret</em> ，选择要调试的源文件，然后打上断点（在要进行断点的地方，双击即可）。这时，启动应用，然后触发要调试的函数即可。</p>

<h2 id="表查看器">表查看器</h2>

<pre><code class="language-bash">tv:start().
</code></pre>

<p>好像这个也没有用了。</p>

<h2 id="工具栏">工具栏</h2>

<pre><code class="language-bash">toolbar:start().
</code></pre>

<p>好像这个也没有用了。</p>

<h1 id="第八章-分布式erlang-otp简介">第八章：分布式Erlang/OTP简介</h1>

<h2 id="位置透明性">位置透明性</h2>

<p>在Erlang中，进程间的通信方式与接收方在本地机器还是在远程机器上无关。这点在语法层面上仍然成立。</p>

<h2 id="节点">节点</h2>

<p>被配置成按分布式模式运行的 Erlang VM 就叫做节点。每一个节点都有一个节点名，其他节点中以通过这个名字来找到该节点并与之通信。当前本地节点的节点名可以通过内置函数 <em>node()</em> 获取，节点名是一个原子，格式为 <em>nodename@hostname</em> （不以分布式模式运行的VM的节点，永远为 <em>nonode@nohost</em>)。在单台主机上可以同时运行多个节点。</p>

<p>调用 <em>nodes()</em> 可以查看互联的节点。</p>

<h2 id="集群">集群</h2>

<p>一旦两个或两个以上的 Erlang 节点能够相互感知，我们就说它们形成了一个集群。</p>

<p>默认情况下，Erlang集群是一个全联通网络，即集群中的每个节点，都能感知其他所有节点，任意两个节点都可以直接通信。</p>

<h3 id="节点的启动">节点的启动</h3>

<pre><code class="language-bash">erl -name your_node_name
</code></pre>

<p>这样子就可以以分布式模式启动Erlang节点。（该形式适用于配有 DNS 的普通网络环境，你需要给出节点的完全限定名。</p>

<p>还有一种启动方式:</p>

<pre><code class="language-bash">erl -sname your_node_name
</code></pre>

<p>这种适用于完全限定名不可用的情况（只要所有节点在同一子网，你就可以使用短节点名）</p>

<blockquote>
<p>注意，采用短节点和长节点的节点所处的通信模式是不同的，它们之间无法形式集群。只有采用相同模式的节点，才能互联。</p>
</blockquote>

<p>在我的Mac上，它们两种启动的提示符如下:</p>

<pre><code class="language-bash">[15:18:01] emacsist:~ $ erl -sname hello1
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(hello1@yangzhiyongs-MacBook-Pro)1&gt;






[15:16:50] emacsist:~ $ erl -name hello
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(hello@yangzhiyongs-MacBook-Pro.local)1&gt;
</code></pre>

<h3 id="节点的互联">节点的互联</h3>

<p>同一集群内启动几十个节点没什么问题，但跑上几百个就比较悬了。原因在于维系机器之间的联络是需要一定通信开销的，而Erlang集群又是一个全联通网络，这部分的开销会随节点数的增加按平方规模增长。</p>

<p>比如 a,b 两个节点组成一个集群， c,d两个节点组成一个集群。如果a与c节点互联了的话，则 b与 c,d 也会自动进行互联。</p>

<p>假设，你启动了3个节点: a, b , c</p>

<p>然后在 a 节点上调用:</p>

<pre><code class="language-bash">net_adm:ping('节点').
</code></pre>

<p>如果成功的话，就会返回  <em>pong</em> ，否则返回 <em>pang</em> 。比如:</p>

<p>节点a:</p>

<pre><code class="language-bash">[15:22:29] emacsist:~ $ erl -sname a
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(a@yangzhiyongs-MacBook-Pro)1&gt; net_adm:ping('b@yangzhiyongs-MacBook-Pro').
pong
(a@yangzhiyongs-MacBook-Pro)2&gt; nodes().
['b@yangzhiyongs-MacBook-Pro']
(a@yangzhiyongs-MacBook-Pro)3&gt;
</code></pre>

<p>节点b:</p>

<pre><code class="language-bash">[15:22:25] emacsist:~ $ erl -sname b
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(b@yangzhiyongs-MacBook-Pro)1&gt; nodes().
['a@yangzhiyongs-MacBook-Pro']
(b@yangzhiyongs-MacBook-Pro)2&gt;
</code></pre>

<p>节点c:</p>

<pre><code class="language-bash">Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(c@yangzhiyongs-MacBook-Pro)1&gt;
</code></pre>

<h3 id="erlang节点如何定位其他节点并建立通信">Erlang节点如何定位其他节点并建立通信</h3>

<p><em>EPMD</em> 进程（Erlang Port Mapper Daemon）：</p>

<pre><code class="language-bash">[15:35:18] emacsist:~ $ ps aux | grep epmd
emacsist         29193   0.0  0.0  2461456    596   ??  S     3:16下午   0:00.02 /usr/local/Cellar/erlang/19.3/lib/erlang/erts-8.3/bin/epmd -daemon
</code></pre>

<p>你每启动一个节点，它都会检查本地机器上是否运行着EPMD，如果没有，节点就会自动启动EPMD。它会跟踪在本地机器上运行的每个节点，并记录分配给它们的端口。</p>

<p>当Erlang节点试图与某远程节点通信时，本地的EPMD就会联络远程机器上的EPMD（默认使用 TCP/IP，端口为 4369），询问在远程机器上有没有叫相应名字的节点。如果有，远程的EPMD就会回复一个端口号，通过该端口便可以直接与远程节点通信 。</p>

<p>不过EPMD不会自动搜寻其他EPMD——只有在某个节点主动搜寻其他节点时通信才能建立。</p>

<blockquote>
<p>注意，Erlang默认的分布式模型基于这样一个假设：集群中所有节点都运行在一个受信任的网络内。如果这个假设不成立，或者其中某些机器需要与外界通信，那么你应该直接在TCP（或UDP等）之上配合恰当的应用层协议来实现非受信任网络上的通信。</p>
</blockquote>

<h3 id="magic-cookie">magic cookie</h3>

<p>如果成功启动过一次节点的话，可以在 <em>用户主目录</em> （Windows上一般为 C:/Documents and Settings/<username> 或 C:/Users/<username> 目录）下会有一个 <em>.erlang.cookie</em> 文件。</p>

<p>你也可以在shell中，获取当前节点的cookie：</p>

<pre><code class="language-bash">[15:31:54] emacsist:~ $ erl -sname b
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(b@yangzhiyongs-MacBook-Pro)1&gt; auth:get_cookie().
'YVCOJVPHXHCVZYICUVIJ'
(b@yangzhiyongs-MacBook-Pro)2&gt;
</code></pre>

<p>从shell中获取的字符串与你在 <em>.erlang.cookie</em> 文件看到的应该相同。Erlang节点只有在知晓其他节点的 magic cookie的情况下才能与它们通信。</p>

<p>节点在启动的时候，会读取 <em>.erlang.cookie</em> 文件，如果存在，则以它为自己的 magic cookie，如果找不到，则节点会新建一个 cookie 文件并写入一个随机字符串。</p>

<p>默认情况下，每个节点都会假定所有与自己打交道的节点都拥有和自己一样的 cookie 。</p>

<p>要让运行于两台不同机器上的节点相互通信，最简单的办法就是将其中一台机器随机生成的 cookie 文件复制到另一台机器上即可。</p>

<p>对于更为复杂的配置，你可以用内置函数 <em>set_cookie(Node, Cookie)</em> 来设置 cookie ,这样，节点可以用不同的 cookie 与不同的节点通信。原则上说，集群中每个节点的 cookie 都可以不上，但在实践中，整个系统往往会共用一个 cookie .</p>

<h3 id="远程-shell">远程 shell</h3>

<p>其实shell进程并不关心与自己连接的终端是否和自己处在同一节点。下面演示了，如何在节点a里，通过 erlang shell连接节点b:</p>

<pre><code class="language-bash">[16:10:04] emacsist:~ $ erl -sname a
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.3  (abort with ^G)
(a@yangzhiyongs-MacBook-Pro)1&gt;
User switch command
 --&gt; r 'b@yangzhiyongs-MacBook-Pro'
 --&gt; j
   1  {shell,start,[init]}
   2* {'b@yangzhiyongs-MacBook-Pro',shell,start,[]}
 --&gt; c
Eshell V8.3  (abort with ^G)
(b@yangzhiyongs-MacBook-Pro)1&gt;
</code></pre>

<h4 id="退出远程-shell-千万要小心">退出远程 shell 千万要小心</h4>

<p>在使用完远程shell后，你可能会打入: <em>q().</em> ，这时千万不要回车。这个是 <em>init:stop().</em> 的简写，用于关闭执行该命令的节点，也就是你的远程节点。</p>

<p>要想安全地退出，请使用 <em>Ctrl-G</em> 和 <em>Ctrl-C</em> ，这两个组合只对本地节点有效。</p>

<h1 id="第九章-用-mnesia为cache增加分布工支持">第九章：用 Mnesia为cache增加分布工支持</h1>

<p><em>Mnesia</em> 是一套轻量级的软实时分布式数据存储系统，支持冗余复制和事务，特别适合于存储离散的Erlang数据块，尤其擅长RAM中的数据存储。</p>

<p>使用步骤:</p>

<ol>
<li>初始化 Mnesia</li>
<li>启动节点</li>
<li>建立数据库模式</li>
<li>启动 Mnesia</li>
<li>建立数据库表</li>
<li>向新建的表中插入数据</li>
<li>对数据做一些基本查询</li>
</ol>

<h2 id="初始化数据库">初始化数据库</h2>

<h3 id="启动节点">启动节点</h3>

<pre><code class="language-bash">erl -mnesia dir '&quot;/tmp/mnsia_store&quot;' -name mynode
</code></pre>

<p>注意，dir 后面的参数格式（单引号用于保留字符串两端的双引号）。</p>

<p>节点启动后，还需要在即将参与冗余复制的所有节点上建立一套空的初始数据模式。</p>

<h3 id="建立数据库模式">建立数据库模式</h3>

<p>它是一些描述信息，其中记录着当前数据库中存有哪些表，表的详细情况又如何。一般来说不用关注它，它只是 Mnesia 用于跟踪自身数据的一种手段。</p>

<pre><code class="language-bash">mnsia:create_schema([node()]).
</code></pre>

<h3 id="启动-mnesia">启动 Mnesia</h3>

<pre><code class="language-bash">mnsia:start().

mnsia:info().
</code></pre>

<h3 id="建表">建表</h3>

<pre><code class="language-bash">mnsia:create_table(Name, Options)
</code></pre>

<p>Options 是一张 {Name, Value} 选项列表。所在选项中，最重要的是 <em>attributes</em> 。如果没有它，Mnesia 会假定记录仅有两个字段，分别名为 key 和 val 。</p>

<p><em>表的主键永远都是记录的第一个字段</em></p>

<h4 id="mnesia-表的类型">Mnesia 表的类型</h4>

<ul>
<li><em>set</em> ：表中的键是唯一的，如果插入的记录与现存某个表项的主键相同，则新的记录会覆盖旧的。</li>
<li><em>bag</em> ：可以容纳多个具有相同主键的记录，但这些记录至少要有一个字段的值不相等。</li>

<li><p><em>ordered_set</em> ：上面两个都是是哈希表实现。<em>ordered_set</em> 则可以按主键的顺序保存记录。</p>

<pre><code class="language-bash">mnesia:create_table(table_name, [{type, bag},...])
</code></pre></li>
</ul>

<h4 id="表的存储类型">表的存储类型</h4>

<pre><code class="language-bash">(hello@yangzhiyongs-MacBook-Pro.local)3&gt; mnesia:info().
---&gt; Processes holding locks &lt;---
---&gt; Processes waiting for locks &lt;---
---&gt; Participant transactions &lt;---
---&gt; Coordinator transactions &lt;---
---&gt; Uncertain transactions &lt;---
---&gt; Active tables &lt;---
schema         : with 1        records occupying 413      words of mem
===&gt; System info in version &quot;4.14.3&quot;, debug level = none &lt;===
opt_disc. Directory &quot;/tmp/mnesia_store&quot; is used.
use fallback at restart = false
running db nodes   = ['hello@yangzhiyongs-MacBook-Pro.local']
stopped db nodes   = []
master node tables = []
remote             = []
ram_copies         = []
disc_copies        = [schema]
disc_only_copies   = []
[{'hello@yangzhiyongs-MacBook-Pro.local',disc_copies}] = [schema]
2 transactions committed, 0 aborted, 0 restarted, 0 logged to disc
0 held locks, 0 in queue; 0 local transactions, 0 remote
0 transactions waits for other nodes: []
ok
</code></pre>

<p><em>ram_copies</em> ：仅驻留于内存
<em>disc_copies</em> ：表示它会被写入磁盘；为了提高读取速度，这些表会被会部加载进内存
<em>disc_only_copyies</em> ： 仅存储在磁盘，所以比上面两种要表许多。这种存储类型还不支持 <em>ordered_set</em> 表。</p>

<blockquote>
<p>注意：不同节点上的表，可以有不同的存储类型。比如，有一个节点是写磁盘，其他的是RAM的。</p>
</blockquote>

<h3 id="向表录入数据">向表录入数据</h3>

<pre><code class="language-bash">mnesia:write(...)
mnsia:dirty_write(...)
</code></pre>

<h4 id="事务">事务</h4>

<p>Mnesia 具有通常所说的ACID性质。要进行事务非常简单：</p>

<p>将逻辑写入到一个（不含参数）的fun表达式，然后将它传递给 <em>mnesia:transaction/1</em> 即可。</p>

<h4 id="脏操作">脏操作</h4>

<p>以 <em>dirty_</em> 为前缀的 Mnesia 函数都是脏操作，它不会考虑事务或数据库锁。</p>

<h3 id="执行基本查询">执行基本查询</h3>

<pre><code class="language-bash">mnesia:dirty_read(table_name, key)
mnesia:read(...)
</code></pre>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2017-04-30</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/erlang/">erlang</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2017/05/07/erlang%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">《Erlang程序设计》学习笔记</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2017/04/29/%E7%BF%BB%E8%AF%91%E6%B8%85%E6%A5%9A%E5%9C%B0%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84this%E5%B9%B6%E4%B8%94%E6%8E%8C%E6%8F%A1%E5%AE%83/">
            <span class="next-text nav-default">[翻译]清楚地理解JavaScript中的this并且掌握它</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2017-04-30 12:55:25 \x2b0000 UTC',
    title: '《Erlang\/OTP 并发编程实战》读书笔记',
    link: decodeURI(location.href),
    desc: '第一章：Erlang\/OTP 平台 Erlang 中，并发的基本单位是进程。',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
