<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Rust 学习笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="安装 curl https://sh.rustup.rs -sSf | sh 成功后, 将下面代码加到 ~/.bash_profile export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot; 更新: rustup update 卸载 rustup self" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://emacsist.github.io/2018/03/12/rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="Rust 学习笔记" />
<meta property="og:description" content="安装 curl https://sh.rustup.rs -sSf | sh 成功后, 将下面代码加到 ~/.bash_profile export PATH=&quot;$HOME/.cargo/bin:$PATH&quot; 更新: rustup update 卸载 rustup self" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2018/03/12/rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2018-03-12T18:59:38+00:00" />
<meta property="article:modified_time" content="2018-03-12T18:59:38+00:00" />
<meta itemprop="name" content="Rust 学习笔记">
<meta itemprop="description" content="安装 curl https://sh.rustup.rs -sSf | sh 成功后, 将下面代码加到 ~/.bash_profile export PATH=&quot;$HOME/.cargo/bin:$PATH&quot; 更新: rustup update 卸载 rustup self">


<meta itemprop="datePublished" content="2018-03-12T18:59:38&#43;00:00" />
<meta itemprop="dateModified" content="2018-03-12T18:59:38&#43;00:00" />
<meta itemprop="wordCount" content="5406">



<meta itemprop="keywords" content="rust," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust 学习笔记"/>
<meta name="twitter:description" content="安装 curl https://sh.rustup.rs -sSf | sh 成功后, 将下面代码加到 ~/.bash_profile export PATH=&quot;$HOME/.cargo/bin:$PATH&quot; 更新: rustup update 卸载 rustup self"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Rust 学习笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-03-12 </span>
        
        <span class="more-meta"> 5406 words </span>
        <span class="more-meta"> 11 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#创建项目">创建项目</a>
<ul>
<li><a href="#可执行项目">可执行项目</a>
<ul>
<li><a href="#构建项目">构建项目</a></li>
<li><a href="#构建并运行项目">构建并运行项目</a></li>
<li><a href="#发布项目">发布项目</a></li>
<li><a href="#更新依赖包版本">更新依赖包版本</a></li>
</ul></li>
</ul></li>
<li><a href="#默认导入的包">默认导入的包</a></li>
<li><a href="#crate">crate</a></li>
<li><a href="#变量">变量</a>
<ul>
<li><a href="#常量和不可变的变量">常量和不可变的变量</a></li>
<li><a href="#隐藏">隐藏</a></li>
</ul></li>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#函数">函数</a>
<ul>
<li><a href="#参数">参数</a></li>
<li><a href="#语句和表达式">语句和表达式</a></li>
<li><a href="#返回值">返回值</a></li>
</ul></li>
<li><a href="#if-表达式">if 表达式</a></li>
<li><a href="#循环">循环</a>
<ul>
<li><a href="#loop">loop</a></li>
<li><a href="#while">while</a></li>
<li><a href="#for">for</a></li>
</ul></li>
<li><a href="#所有权-ownership">所有权 ownership</a>
<ul>
<li><a href="#所有权规则">所有权规则</a>
<ul>
<li><a href="#数据的交互方式">数据的交互方式</a>
<ul>
<li><a href="#移动">移动</a></li>
<li><a href="#克隆">克隆</a>
<ul>
<li><a href="#只在栈上的数据-拷贝">只在栈上的数据: 拷贝</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#引用与借用">引用与借用</a>
<ul>
<li><a href="#可变引用">可变引用</a></li>
<li><a href="#悬垂指针">悬垂指针</a></li>
<li><a href="#引用规则">引用规则</a></li>
</ul></li>
<li><a href="#slices">slices</a>
<ul>
<li><a href="#字符串-slice">字符串 slice</a></li>
</ul></li>
</ul></li>
<li><a href="#结构体">结构体</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#使用">使用</a>
<ul>
<li><a href="#变量与字段同名时的初始化简写法">变量与字段同名时的初始化简写法</a></li>
<li><a href="#使用结构体更新语法从其他对象创建">使用结构体更新语法从其他对象创建</a></li>
<li><a href="#没有字段名的结构体">没有字段名的结构体</a></li>
</ul></li>
<li><a href="#方法">方法</a></li>
<li><a href="#关联函数">关联函数</a></li>
<li><a href="#多个-impl-块">多个 impl 块</a></li>
</ul></li>
<li><a href="#枚举">枚举</a>
<ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#使用-1">使用</a></li>
<li><a href="#空值与-option-枚举">空值与 Option 枚举</a></li>
<li><a href="#match-控制流运算符">match 控制流运算符</a>
<ul>
<li><a href="#匹配-option">匹配 Option</a></li>
<li><a href="#通配符"><code>_</code> 通配符</a></li>
<li><a href="#if-let">if let</a></li>
</ul></li>
</ul></li>
<li><a href="#模块">模块</a>
<ul>
<li><a href="#创建库模块">创建库模块</a></li>
<li><a href="#模块与文件系统的规则">模块与文件系统的规则</a></li>
<li><a href="#私有性规则">私有性规则</a></li>
<li><a href="#使用-super-访问父模块">使用 super 访问父模块</a></li>
</ul></li>
<li><a href="#cargo-使用本地-crate">cargo 使用本地 crate</a></li>
<li><a href="#集合">集合</a>
<ul>
<li><a href="#vector">vector</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#hash-map">hash map</a></li>
</ul></li>
<li><a href="#错误处理">错误处理</a>
<ul>
<li><a href="#可恢复错误-result-t-e">可恢复错误: <code>Result&lt;T, E&gt;</code></a></li>
<li><a href="#不可恢复错误-panic">不可恢复错误: <code>panic!</code></a>
<ul>
<li><a href="#简写-unwrap-和-expect">简写 unwrap 和 expect</a></li>
</ul></li>
<li><a href="#传播错误">传播错误</a>
<ul>
<li><a href="#简写-问号运算符">简写 <code>?</code> 问号运算符</a></li>
</ul></li>
</ul></li>
<li><a href="#泛型">泛型</a></li>
<li><a href="#trait">trait</a>
<ul>
<li><a href="#定义-2">定义</a></li>
<li><a href="#实现">实现</a></li>
<li><a href="#默认实现">默认实现</a></li>
<li><a href="#trait-bounds">trait bounds</a></li>
</ul></li>
<li><a href="#生命周期">生命周期</a>
<ul>
<li><a href="#何时不需要生命周期注解的规则">何时不需要生命周期注解的规则</a></li>
</ul></li>
<li><a href="#测试">测试</a>
<ul>
<li><a href="#执行-test">执行 test</a></li>
<li><a href="#assert-宏检测-bool-结果"><code>assert!</code> 宏检测 bool 结果</a></li>
<li><a href="#相等或不相等测试">相等或不相等测试</a></li>
<li><a href="#并行或串行测试">并行或串行测试</a></li>
<li><a href="#测试通过时也打印输出">测试通过时也打印输出</a></li>
<li><a href="#单元测试">单元测试</a></li>
<li><a href="#忽略测试">忽略测试</a></li>
<li><a href="#只运行那些忽略的测试函数">只运行那些忽略的测试函数</a></li>
<li><a href="#组织结构">组织结构</a>
<ul>
<li><a href="#单元测试-1">单元测试</a></li>
<li><a href="#cfg-test"><code>#[cfg(test)]</code></a></li>
<li><a href="#集成测试">集成测试</a></li>
</ul></li>
</ul></li>
<li><a href="#命令行程序">命令行程序</a>
<ul>
<li><a href="#获取参数">获取参数</a></li>
<li><a href="#读取和输出文件内容">读取和输出文件内容</a></li>
</ul></li>
<li><a href="#闭包-可以捕获环境的匿名函数">闭包: 可以捕获环境的匿名函数</a>
<ul>
<li><a href="#闭包类型推断和注解">闭包类型推断和注解</a></li>
<li><a href="#多次调用闭包注意">多次调用闭包注意</a></li>
</ul></li>
<li><a href="#迭代器">迭代器</a>
<ul>
<li><a href="#消费迭代器">消费迭代器</a></li>
<li><a href="#产生其他迭代器">产生其他迭代器</a></li>
</ul></li>
<li><a href="#cargo">Cargo</a>
<ul>
<li><a href="#发布配置">发布配置</a></li>
<li><a href="#工作空间">工作空间</a></li>
<li><a href="#安装依赖">安装依赖</a></li>
</ul></li>
<li><a href="#智能指针">智能指针</a>
<ul>
<li><a href="#box-t-在堆上存储数据-并且可确定大小">Box<T> : 在堆上存储数据，并且可确定大小</a></li>
<li><a href="#deref-trait-将智能指针当作常规引用处理">Deref trait : 将智能指针当作常规引用处理</a></li>
<li><a href="#drop-trait-运行清理代码">Drop trait: 运行清理代码</a></li>
<li><a href="#rc-t-引用计数智能指针">Rc<T>: 引用计数智能指针</a></li>
</ul></li>
<li><a href="#并发">并发</a>
<ul>
<li><a href="#线程">线程</a>
<ul>
<li><a href="#创建线程">创建线程</a></li>
<li><a href="#join-等待线程结束">join 等待线程结束</a></li>
<li><a href="#move-闭包">move 闭包</a></li>
</ul></li>
<li><a href="#消息传递">消息传递</a></li>
<li><a href="#共享状态">共享状态</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="安装">安装</h1>

<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh

成功后, 将下面代码加到 ~/.bash_profile
export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>

<p>更新:</p>

<pre><code class="language-bash">rustup update
</code></pre>

<p>卸载</p>

<pre><code class="language-bash">rustup self uninstall
</code></pre>

<h1 id="创建项目">创建项目</h1>

<h2 id="可执行项目">可执行项目</h2>

<pre><code class="language-bash">cargo new project_name --bin
</code></pre>

<h3 id="构建项目">构建项目</h3>

<pre><code class="language-bash">cargo build
</code></pre>

<p>它会打包到 <code>target/debug</code></p>

<h3 id="构建并运行项目">构建并运行项目</h3>

<pre><code class="language-bash">cargo run
</code></pre>

<h3 id="发布项目">发布项目</h3>

<pre><code class="language-bash">cargo build --release
</code></pre>

<p>它会打包到 <code>target/release</code></p>

<h3 id="更新依赖包版本">更新依赖包版本</h3>

<pre><code class="language-bash">cargo update
</code></pre>

<h1 id="默认导入的包">默认导入的包</h1>

<p><a href="https://doc.rust-lang.org/std/prelude/index.html">doc</a></p>

<h1 id="crate">crate</h1>

<blockquote>
<p>它是一个 Rust 代码的包.</p>
</blockquote>

<p>可执行的项目, 称为 <code>二进制 crate</code>, 库项目(即可以被其他程序调用的代码) 称为 <code>库 crate</code></p>

<h1 id="变量">变量</h1>

<p>在 rust 中, 变量默认的情况下是 <code>不可变的 immutable</code></p>

<h2 id="常量和不可变的变量">常量和不可变的变量</h2>

<p>在 rust 中, 常量是不能用 <code>mut</code> 来修饰的, 它不光默认不能变, 它总是不能变的.</p>

<p>常量声明使用 <code>const</code> 而不是 <code>let</code>, 并且必须注明值的类型.</p>

<p>常量只能用于常量表达式, 而不能作为函数调用的结果, 或任何其他只在运行时计算的值.</p>

<pre><code class="language-bash">const MAX_POINTS: u32 = 100_000;
</code></pre>

<h2 id="隐藏">隐藏</h2>

<ul>
<li>除非再次使用 <code>let</code> 关键字, 否则默认情况下对变量重新赋值会导致编译错误</li>
<li>多次使用 <code>let</code> 时, 实际上创建了一个新的变量, 我们<code>可以改变值的类型</code>, 从而复用这个名字. 但一个 <code>mut</code> 的变量, 则不能修改它的类型, 否则会导致一个编译错误</li>
</ul>

<h1 id="数据类型">数据类型</h1>

<blockquote>
<p>Rust 是一种静态类型语言, 也就是说在编译时就必须知道所有变量的类型.</p>
</blockquote>

<ul>
<li>scalar : 标量

<ul>
<li>整型(有符号的, 以 <code>i</code> 开头, 无符号的以 <code>u</code> 开头, 默认为 <code>i32</code>, 无论是在32位, 还是64位系统上, 默认都是 <code>i32</code>). 十六进制(0x开头), 八进制(0o开头), 二进制(0b开头), 字节(<code>b'A'</code>)</li>
<li>浮点型(<code>f32</code>, <code>f64</code>, 默认为<code>f64</code>, 因为在现代CPU中, 它与 <code>f32</code>速度几乎一样快)</li>
<li>布尔类型(<code>bool</code>, 它只有 <code>true</code> 或 <code>false</code>)</li>
<li>字符类型(<code>char</code>, 它使用单引号指定. 不同与字符串使用双引号)</li>
</ul></li>
<li>compound : 复合

<ul>
<li>元组(<code>tuple</code>), 它使用一个括号中的逗号分隔的值列表来创建一个元组.<code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code>, 这元素的类型是不必相同的.可以使用模式匹配来解构元组. <code>let (x, y, z) = tup;</code></li>
<li>数组(<code>array</code>), 元素类型必须相同. 而且数组长度是固定的.索引从0开始.</li>
</ul></li>
</ul>

<h1 id="函数">函数</h1>

<p>Rust 使用 <code>snake case</code> 风格来命名函数的. 即所有字母都是小写, 并使用下划线分隔单词.</p>

<p>Rust 可以调用定义过了的函数来调用(不管是在调用者之前还是之后定义, 都可以)</p>

<h2 id="参数">参数</h2>

<pre><code class="language-bash">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>

<h2 id="语句和表达式">语句和表达式</h2>

<p>语句: 执行一些操作但不返回值(如 <code>let</code> 语句)
表达式: 计算并产生一个值.它可以是语句的一部分. 例如函数调用, 宏调用.注意 <code>{}</code> 也是一个表达式.所以可以这样子:</p>

<pre><code class="language-bash">let y = {
        let x = 3;
        x + 1
    };
</code></pre>

<p>这里的<code>{}</code>表达式的值为4.所以 <code>y</code> 为 4</p>

<h2 id="返回值">返回值</h2>

<blockquote>
<p>函数的返回值, 等同于函数体最后一个表达式的值.</p>
</blockquote>

<pre><code class="language-bash">fn five() -&gt; i32 {
    5
}
</code></pre>

<p>注意, 如果是有分号的话, 则它是语句, 而不是表达式了.</p>

<h1 id="if-表达式">if 表达式</h1>

<pre><code class="language-bash">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre>

<blockquote>
<p>因为它是一个表达式, 所以它是有返回值的, 所以可以这样子:</p>
</blockquote>

<pre><code class="language-bash">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>

<h1 id="循环">循环</h1>

<h2 id="loop">loop</h2>

<pre><code class="language-bash">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>

<h2 id="while">while</h2>

<pre><code class="language-bash">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>

<h2 id="for">for</h2>

<pre><code class="language-bash">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre>

<pre><code class="language-bash">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>

<p><code>rev()</code> 用来反转.</p>

<h1 id="所有权-ownership">所有权 ownership</h1>

<p>一般程序管理内存的方式</p>

<ol>
<li>使用GC</li>
<li>手工处理</li>
</ol>

<p>而 Rust 则使用第三种: 内存被一个所有权系统管理, 它拥有一系列的规则使编译器在编译时进行检查.并且不会导致运行时开销.</p>

<h2 id="所有权规则">所有权规则</h2>

<ul>
<li>Rust 中每一个值都有一个称之为其 <code>所有者 owner</code> 的变量</li>
<li>值有且只能有一个所有者</li>
<li>当所有者(变量)离开作用域, 这个值将被丢弃.(当变量离开作用域时, Rust 为其调用一个特殊的函数, 这个函数叫 <code>drop</code>)</li>
</ul>

<p>之前提到的 <code>数据类型</code> 部分都是储存在 <code>栈</code> 上的并且离开作用域时被移出栈.</p>

<p>注意, <code>Rust 永远也不会自动创建数据的 深拷贝</code>, 因此任何自动的复制可以被认为对运行时性能影响较小.</p>

<h3 id="数据的交互方式">数据的交互方式</h3>

<h4 id="移动">移动</h4>

<pre><code class="language-bash">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
</code></pre>

<h4 id="克隆">克隆</h4>

<p><code>String</code> 有个 <code>clone</code> 函数, 它会深度复制堆上的数据.</p>

<pre><code class="language-bash">let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
</code></pre>

<h5 id="只在栈上的数据-拷贝">只在栈上的数据: 拷贝</h5>

<pre><code class="language-bash">let x = 5;
let y = x;
</code></pre>

<p>Rust 有一个 <code>Copy</code> trait 的特殊注解, 可以用在类似整型这样的储存在栈上的类型. 如果一个类型拥有 <code>Copy</code> trait, 一个旧的变量在将其赋值给其他变量后仍然可用.</p>

<p>Rust 不允许自身或任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait . 以下是一些 <code>Copy</code> trait 的建议规则</p>

<ul>
<li>所有整数类型</li>
<li>布尔类型</li>
<li>浮点类型</li>
<li>元组, 当且仅当其包含的类型也是 <code>Copy</code> 的时候.</li>
</ul>

<h2 id="引用与借用">引用与借用</h2>

<blockquote>
<p>&amp;s1 语法允许我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。</p>
</blockquote>

<p>获取引用作为函数参数称为借用. 默认情况下, 引用也同样是不可变的.</p>

<h3 id="可变引用">可变引用</h3>

<blockquote>
<p>限制: 在特定作用域中的特定数据, 有且只有一个可变引用.
也不能在拥有不可变引用的同时拥有可变引用.</p>
</blockquote>

<p><code>&amp;mut</code></p>

<pre><code class="language-bash">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>

<p>这使用 Rust 在编译时就避免了数据竞争.</p>

<h3 id="悬垂指针">悬垂指针</h3>

<blockquote>
<p>是其指向的内存可能已经被分配给其它持有者</p>
</blockquote>

<p>在 Rust 中, 编译器确保引用永远也不会变成悬垂指针.</p>

<p>比如这代码在 Rust 中是编译不了的:</p>

<pre><code class="language-bash">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>

<p>解决的办法是返回 String 而不是 <code>&amp;String</code> . 返回 String 就表示所有权被转移出去了, 所以值还没有释放.</p>

<h3 id="引用规则">引用规则</h3>

<ul>
<li>在任意给定时间, 只能拥有以下中的一个

<ul>
<li>一个可变引用</li>
<li>任意数量的不可变引用</li>
</ul></li>
<li>引用必须总是有效的</li>
</ul>

<h2 id="slices">slices</h2>

<p>这也是一个没有所有权的类型.</p>

<blockquote>
<p>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p>
</blockquote>

<h3 id="字符串-slice">字符串 slice</h3>

<pre><code class="language-bash">let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
</code></pre>

<p>字符串字面值就是 slice, 即 <code>let s = &quot;Hello, world!&quot;;</code> 的类型是 <code>&amp;str</code>, 这是一个不可变的引用.</p>

<h1 id="结构体">结构体</h1>

<h2 id="定义">定义</h2>

<pre><code class="language-bash">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre>

<h2 id="使用">使用</h2>

<pre><code class="language-bash">let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
</code></pre>

<p>如果想改变 <code>user1</code> 的字段值, 则要声明为 <code>let mut user1 = xxx</code>. Rust 并不允许只将特定字段标记为可变.</p>

<h3 id="变量与字段同名时的初始化简写法">变量与字段同名时的初始化简写法</h3>

<pre><code class="language-bash">fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>

<h3 id="使用结构体更新语法从其他对象创建">使用结构体更新语法从其他对象创建</h3>

<pre><code class="language-bash">let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
</code></pre>

<h3 id="没有字段名的结构体">没有字段名的结构体</h3>

<pre><code class="language-bash">struct Color(i32, i32, i32);

let black = Color(0, 0, 0);
</code></pre>

<h2 id="方法">方法</h2>

<p>它的第一个参数总是 <code>self</code></p>

<pre><code class="language-bash">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre>

<h2 id="关联函数">关联函数</h2>

<p>在 <code>impl</code> 块中定义不以 <code>self</code> 作为参数的函数. 它们是函数, 而不是方法. 例如</p>

<pre><code class="language-bash">impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
</code></pre>

<h2 id="多个-impl-块">多个 impl 块</h2>

<pre><code class="language-bash">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>

<h1 id="枚举">枚举</h1>

<h2 id="定义-1">定义</h2>

<pre><code class="language-bash">enum IpAddrKind {
    V4,
    V6,
}
</code></pre>

<p>注意, 枚举也可以是这样子的:</p>

<pre><code class="language-bash">enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>

<p>这与Java那种枚举不太一样..</p>

<h2 id="使用-1">使用</h2>

<pre><code class="language-bash">let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre>

<h2 id="空值与-option-枚举">空值与 Option 枚举</h2>

<p>标准库的定义</p>

<pre><code class="language-bash">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>

<h2 id="match-控制流运算符">match 控制流运算符</h2>

<blockquote>
<p>遇到第一个符合时就会执行相应的代码.</p>
</blockquote>

<pre><code class="language-bash">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>

<h3 id="匹配-option">匹配 Option</h3>

<pre><code class="language-bash">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>

<h3 id="通配符"><code>_</code> 通配符</h3>

<pre><code class="language-bash">let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
</code></pre>

<p>它会匹配所有的值.</p>

<h3 id="if-let">if let</h3>

<p>用来处理只匹配一个模式的值, 而忽略其他模式的情况.</p>

<pre><code class="language-bash">let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
</code></pre>

<p>如果我们只想处理 <code>Some(3)</code> 时, 可以这样子简写</p>

<pre><code class="language-bash"># let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
</code></pre>

<h1 id="模块">模块</h1>

<h2 id="创建库模块">创建库模块</h2>

<p>默认情况下 , cargo 就是创建库项目的, <code>--bin</code> 参数才是可执行项目.</p>

<pre><code class="language-bash">cargo new lib_name
</code></pre>

<p>比较好的建议是:</p>

<p>在 <code>src/lib.rs</code> 文件中声明模块:</p>

<pre><code class="language-bash">mod client;

mod network;
</code></pre>

<p>然后在其他的文件中, 提供模块的内容:</p>

<p><code>src/network.rs</code> 的内容:</p>

<pre><code class="language-bash">fn connect() {
}

mod server {
    fn connect() {
    }
}
</code></pre>

<p>注意, 这里不需要在 <code>src/network.rs</code> 文件中声明 <code>mod network</code> 了!</p>

<h2 id="模块与文件系统的规则">模块与文件系统的规则</h2>

<ul>
<li>如果一个叫 <code>foo</code> 的模块没有子模块, 应该将 <code>foo</code> 的声明放入叫做 <code>foo.rs</code> 的文件中</li>
<li>如果一个叫 <code>foo</code> 的模块有子模块, 应该将 <code>foo</code> 的声明放入叫做 <code>foo/mod.rs</code> 的文件中</li>
</ul>

<h2 id="私有性规则">私有性规则</h2>

<ul>
<li>如果一个项是公有的, 它能被任何父模块访问</li>
<li>如果一个项是私有的, 它能被其直接父模块及其子模块访问</li>
</ul>

<h2 id="使用-super-访问父模块">使用 super 访问父模块</h2>

<pre><code class="language-bash">super::client::connect();
</code></pre>

<h1 id="cargo-使用本地-crate">cargo 使用本地 crate</h1>

<p>假设项目名为 <code>rust-demo</code>,</p>

<p>项目目录结构</p>

<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
├── rust-demo.iml
├── src
│   ├── lib
│   │   ├── hello.rs
│   │   └── mod.rs
│   ├── main
│   └── main.rs
</code></pre>

<p><code>mod.rs</code> 文件内容:</p>

<pre><code class="language-bash">pub mod hello;
</code></pre>

<p><code>hello.rs</code> 文件内容:</p>

<pre><code class="language-bash">pub fn say_hello() {
    println!(&quot;hello world&quot;)
}
</code></pre>

<p><code>main.rs</code> 文件内容:</p>

<pre><code class="language-bash">extern crate hello;


fn main() {
    hello::say_hello()
}
</code></pre>

<p><code>Cargo.toml</code> 文件内容</p>

<pre><code class="language-bash">[package]
name = &quot;rust-demo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;emacsist &lt;emacsist@qq.com&gt;&quot;]

[lib]
name = &quot;hello&quot;
path = &quot;src/lib/hello.rs&quot;

[[bin]]
name = &quot;main&quot;
path = &quot;src/main.rs&quot;

[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>

<h1 id="集合">集合</h1>

<h2 id="vector">vector</h2>

<pre><code class="language-bash">let v: Vec&lt;i32&gt; = Vec::new();

或

let v = vec![1, 2, 3];
</code></pre>

<p>更新</p>

<pre><code class="language-bash">v.push(5);
</code></pre>

<p>获取</p>

<pre><code class="language-bash">let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
</code></pre>

<p>遍历</p>

<pre><code class="language-bash">只读:
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}


修改:
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
</code></pre>

<h2 id="字符串">字符串</h2>

<p>创建</p>

<pre><code class="language-bash">let mut s = String::new();

let s = String::from(&quot;initial contents&quot;);
</code></pre>

<p>更新</p>

<pre><code class="language-bash">let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
</code></pre>

<p>拼接</p>

<pre><code class="language-bash">let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2;

或
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
</code></pre>

<p>不支持索引字符串, 如 <code>s[0]</code></p>

<p>字符串 slice</p>

<pre><code class="language-bash">let hello = &quot;Здравствуйте&quot;;
let s = &amp;hello[0..4];
</code></pre>

<p>遍历</p>

<pre><code class="language-bash">for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
</code></pre>

<h2 id="hash-map">hash map</h2>

<p>创建</p>

<pre><code class="language-bash">use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
</code></pre>

<p>访问</p>

<pre><code class="language-bash">use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
</code></pre>

<p>更新</p>

<pre><code class="language-bash">插入一个相同的 key 名时, 会覆盖前一个值

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);
</code></pre>

<p>只在键没有数据时插入</p>

<pre><code class="language-bash">use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);
</code></pre>

<p>根据旧值更新一个值</p>

<pre><code class="language-bash">use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
</code></pre>

<h1 id="错误处理">错误处理</h1>

<h2 id="可恢复错误-result-t-e">可恢复错误: <code>Result&lt;T, E&gt;</code></h2>

<h2 id="不可恢复错误-panic">不可恢复错误: <code>panic!</code></h2>

<p>默认下, <code>panic!</code> 宏会 unwinding 程序, 这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据. 另一种选择是终止 <code>abort</code>(这会使二进制文件更小). 可以在 <code>Cargo.toml</code> 文件中配置:</p>

<pre><code class="language-bash">[profile.release]
panic = 'abort'
</code></pre>

<pre><code class="language-bash">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre>

<h3 id="简写-unwrap-和-expect">简写 unwrap 和 expect</h3>

<p><code>unwrap</code> , 如果 Result 是 Ok, 则返回 Ok 中的值, 如果是 Err, 则会调用 <code>panic!</code></p>

<pre><code class="language-bash">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre>

<p><code>expect</code> , 类似 <code>unwrap</code> , 但提供一个好的错误信息.</p>

<h2 id="传播错误">传播错误</h2>

<p>返回 <code>Result&lt;T, E&gt;</code></p>

<pre><code class="language-bash">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
</code></pre>

<h3 id="简写-问号运算符">简写 <code>?</code> 问号运算符</h3>

<blockquote>
<p>向调用者返回错误的函数</p>
</blockquote>

<p>并且要注意, 它只能被用于返回 Result 的函数</p>

<pre><code class="language-bash">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
</code></pre>

<h1 id="泛型">泛型</h1>

<p>泛型的函数签名:</p>

<pre><code class="language-bash">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>

<p>结构体中的泛型:</p>

<pre><code class="language-bash">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}
</code></pre>

<h1 id="trait">trait</h1>

<blockquote>
<p>定义共享的行为</p>
</blockquote>

<h2 id="定义-2">定义</h2>

<pre><code class="language-bash">pub trait Summarizable {
    fn summary(&amp;self) -&gt; String;
}
</code></pre>

<p>一个 trait 可以有多个方法签名定义.</p>

<h2 id="实现">实现</h2>

<pre><code class="language-bash">pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}
</code></pre>

<h2 id="默认实现">默认实现</h2>

<pre><code class="language-bash">pub trait Summarizable {
    fn summary(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}

impl Summarizable for NewsArticle {}
</code></pre>

<h2 id="trait-bounds">trait bounds</h2>

<pre><code class="language-bash">pub fn notify&lt;T: Summarizable&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summary());
}
</code></pre>

<h1 id="生命周期">生命周期</h1>

<blockquote>
<p>单个的生命周期注解本身没有多少意义：生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系</p>
</blockquote>

<p>注解法 : <code>'a</code> , 这表示 有一个名为 <code>'a</code> 的生命周期参数.</p>

<p><em>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域</em></p>

<p>结构体的生命周期:</p>

<pre><code class="language-bash">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}
</code></pre>

<h2 id="何时不需要生命周期注解的规则">何时不需要生命周期注解的规则</h2>

<ul>
<li>每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;&lsquo;a, &lsquo;b&gt;(x: &amp;&lsquo;a i32, y: &amp;&lsquo;b i32)，依此类推</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></li>
<li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。这使得方法编写起来更简洁。</li>
</ul>

<h1 id="测试">测试</h1>

<p>在 <code>fn</code> 行之前加上 <code>#[test]</code> 就会将当前的函数变成测试函数.</p>

<h2 id="执行-test">执行 test</h2>

<pre><code class="language-bash">cargo test
</code></pre>

<h2 id="assert-宏检测-bool-结果"><code>assert!</code> 宏检测 bool 结果</h2>

<pre><code class="language-bash">assert!(larger.can_hold(&amp;smaller));
</code></pre>

<h2 id="相等或不相等测试">相等或不相等测试</h2>

<pre><code class="language-bash">assert_eq!(4, add_two(2));

assert_ne!(4, add_two(2));
</code></pre>

<h2 id="并行或串行测试">并行或串行测试</h2>

<p>默认会使用线程来并行的运行测试. 也可以指定线程数:</p>

<pre><code class="language-bash">cargo test -- --test-threads=1
</code></pre>

<h2 id="测试通过时也打印输出">测试通过时也打印输出</h2>

<pre><code class="language-bash">cargo test -- --nocapture
</code></pre>

<h2 id="单元测试">单元测试</h2>

<p>通过测试函数名来进行测试</p>

<pre><code class="language-bash">cargo test one_hundred
</code></pre>

<p>注意, 这种情况下, 默认会执行所有以 <code>one_hundred</code> 名字开头的函数的.</p>

<h2 id="忽略测试">忽略测试</h2>

<pre><code class="language-bash">#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre>

<h2 id="只运行那些忽略的测试函数">只运行那些忽略的测试函数</h2>

<pre><code class="language-bash">cargo test -- --ignored
</code></pre>

<h2 id="组织结构">组织结构</h2>

<h3 id="单元测试-1">单元测试</h3>

<p>传统做法是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</p>

<h3 id="cfg-test"><code>#[cfg(test)]</code></h3>

<p>告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做.</p>

<h3 id="集成测试">集成测试</h3>

<p>在 <code>src</code> 目录下创建一个 <code>tests</code>  目录.</p>

<p><code>tests/integration_test.rs</code>:</p>

<pre><code class="language-bash">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>

<h1 id="命令行程序">命令行程序</h1>

<h2 id="获取参数">获取参数</h2>

<pre><code class="language-bash">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);

    let query = &amp;args[1];
    let filename = &amp;args[2];
}
</code></pre>

<p>注意. 第0个参数是程序路径和程序名.</p>

<h2 id="读取和输出文件内容">读取和输出文件内容</h2>

<pre><code class="language-bash">    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
</code></pre>

<h1 id="闭包-可以捕获环境的匿名函数">闭包: 可以捕获环境的匿名函数</h1>

<blockquote>
<p>可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值.</p>
</blockquote>

<h2 id="闭包类型推断和注解">闭包类型推断和注解</h2>

<blockquote>
<p>闭包不要求像 fn 函数那样在参数和返回值上注明类型.</p>
</blockquote>

<pre><code class="language-bash">let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
</code></pre>

<p>当然, 你也可以显式注明:</p>

<pre><code class="language-bash">let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
</code></pre>

<h2 id="多次调用闭包注意">多次调用闭包注意</h2>

<blockquote>
<p>可以创建一个存放闭包和调用闭包结果的结构体。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 memoization 或 lazy evaluation。</p>
</blockquote>

<p>可以使用带有 <code>Fn</code> 系列 trait 由标准库提供的闭包.这些都实现了 trait <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 中的一个.</p>

<h1 id="迭代器">迭代器</h1>

<blockquote>
<p>它是惰性的.</p>
</blockquote>

<pre><code class="language-bash">let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
</code></pre>

<h2 id="消费迭代器">消费迭代器</h2>

<pre><code class="language-bash">	let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

</code></pre>

<h2 id="产生其他迭代器">产生其他迭代器</h2>

<pre><code class="language-bash">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();
</code></pre>

<h1 id="cargo">Cargo</h1>

<h2 id="发布配置">发布配置</h2>

<p>默认情况下下, 使用的是 <code>dev</code> 配置.即 (cargo build) 时, 使用的是 <code>dev</code> 配置.</p>

<p>也可以使用 <code>release</code> :</p>

<pre><code class="language-bash">cargo build --release
</code></pre>

<p><code>Cargo.toml</code> 中默认的配置:</p>

<pre><code class="language-bash">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>

<h2 id="工作空间">工作空间</h2>

<pre><code class="language-bash">$ mkdir add
$ cd add
$ vim Cargo.toml

[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>

<p>然后在 add 目录下执行命令创建一个二进制 crate. 然后在 <code>add</code> 中执行命令: <code>cargo build</code></p>

<pre><code class="language-bash">cargo new --bin adder

├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>

<p>可以这样子创建多个 crate.</p>

<p>然后编译指定的 project:</p>

<pre><code class="language-bash">cargo build -p adder
</code></pre>

<h2 id="安装依赖">安装依赖</h2>

<pre><code class="language-bash">cargo install ripgrep
</code></pre>

<h1 id="智能指针">智能指针</h1>

<blockquote>
<p>在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反大部分情况，智能指针 拥有 他们指向的数据。 智能指针通常使用结构体实现.</p>
</blockquote>

<h2 id="box-t-在堆上存储数据-并且可确定大小">Box<T> : 在堆上存储数据，并且可确定大小</h2>

<h2 id="deref-trait-将智能指针当作常规引用处理">Deref trait : 将智能指针当作常规引用处理</h2>

<h2 id="drop-trait-运行清理代码">Drop trait: 运行清理代码</h2>

<h2 id="rc-t-引用计数智能指针">Rc<T>: 引用计数智能指针</h2>

<h1 id="并发">并发</h1>

<h2 id="线程">线程</h2>

<h3 id="创建线程">创建线程</h3>

<blockquote>
<p>thread::spawn</p>
</blockquote>

<pre><code class="language-bash">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre>

<h3 id="join-等待线程结束">join 等待线程结束</h3>

<pre><code class="language-bash">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre>

<h3 id="move-闭包">move 闭包</h3>

<p>强制闭包获取其使用的环境值的所有权</p>

<pre><code class="language-bash">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>

<h2 id="消息传递">消息传递</h2>

<p>创建通道</p>

<pre><code class="language-bash">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre>

<blockquote>
<p>mpsc 是 多个生产者，单个消费者</p>
</blockquote>

<p>生产者和消费者:</p>

<pre><code class="language-bash">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre>

<pre><code class="language-bash">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre>

<h2 id="共享状态">共享状态</h2>

<p>互斥器: <code>Mutex&lt;T&gt;</code></p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-03-12</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/rust/">rust</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2018/03/19/%E7%BF%BB%E8%AF%91jackson-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%8F%E8%BF%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[翻译]Jackson 的性能描述</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2018/03/01/kotlin-lang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">Kotlin lang 学习笔记</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2018-03-12 18:59:38 \x2b0000 UTC',
    title: 'Rust 学习笔记',
    link: decodeURI(location.href),
    desc: '安装 curl https:\/\/sh.rustup.rs -sSf | sh 成功后, 将下面代码加到 ~\/.bash_profile export PATH=\x26quot;$HOME\/.cargo\/bin:$PATH\x26quot; 更新: rustup update 卸载 rustup self',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
