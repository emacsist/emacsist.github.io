<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Kotlin lang 学习笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.67.1" />


<link rel="canonical" href="https://emacsist.github.io/2018/03/01/kotlin-lang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="Kotlin lang 学习笔记" />
<meta property="og:description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2018/03/01/kotlin-lang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2018-03-01T11:25:40+00:00" />
<meta property="article:modified_time" content="2018-03-01T11:25:40+00:00" />
<meta itemprop="name" content="Kotlin lang 学习笔记">
<meta itemprop="description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统">
<meta itemprop="datePublished" content="2018-03-01T11:25:40&#43;00:00" />
<meta itemprop="dateModified" content="2018-03-01T11:25:40&#43;00:00" />
<meta itemprop="wordCount" content="8779">



<meta itemprop="keywords" content="kotlin,java," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin lang 学习笔记"/>
<meta name="twitter:description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Kotlin lang 学习笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-03-01 </span>
        
        <span class="more-meta"> 8779 words </span>
        <span class="more-meta"> 18 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#定义-package">定义 package</a>
      <ul>
        <li><a href="#默认导入的包">默认导入的包</a></li>
      </ul>
    </li>
    <li><a href="#import-导入包">import, 导入包</a></li>
    <li><a href="#定义函数">定义函数</a>
      <ul>
        <li><a href="#语法">语法</a></li>
        <li><a href="#例子">例子</a></li>
      </ul>
    </li>
    <li><a href="#定义变量">定义变量</a>
      <ul>
        <li><a href="#定义属性">定义属性</a></li>
      </ul>
    </li>
    <li><a href="#注释">注释</a></li>
    <li><a href="#使用字符串模板">使用字符串模板</a>
      <ul>
        <li><a href="#例子-1">例子</a></li>
      </ul>
    </li>
    <li><a href="#null-安全的">Null 安全的</a>
      <ul>
        <li><a href="#调用">调用</a></li>
        <li><a href="#elvis-操作符">elvis 操作符</a></li>
        <li><a href="#-操作符">!! 操作符</a></li>
        <li><a href="#安全转换">安全转换</a></li>
        <li><a href="#nullable-类型的集合">nullable 类型的集合</a></li>
      </ul>
    </li>
    <li><a href="#使用类型检查和自动转换">使用类型检查和自动转换</a></li>
    <li><a href="#使用-for-循环">使用 for 循环</a></li>
    <li><a href="#使用-while-循环">使用 while 循环</a></li>
    <li><a href="#when-表达式">when 表达式</a></li>
    <li><a href="#使用-range">使用 range</a></li>
    <li><a href="#使用集合">使用集合</a></li>
    <li><a href="#创建基本类和它们的实例">创建基本类和它们的实例</a></li>
  </ul>

  <ul>
    <li><a href="#目录结构">目录结构</a></li>
    <li><a href="#源码文件名">源码文件名</a></li>
    <li><a href="#源文件的组织">源文件的组织</a></li>
    <li><a href="#类层次">类层次</a></li>
    <li><a href="#接口实现层">接口实现层</a></li>
    <li><a href="#重载层">重载层</a></li>
  </ul>

  <ul>
    <li><a href="#函数名">函数名</a>
      <ul>
        <li><a href="#测试方法的命名">测试方法的命名</a></li>
      </ul>
    </li>
    <li><a href="#属性名">属性名</a></li>
  </ul>

  <ul>
    <li><a href="#return-中使用-label">return 中使用 label</a></li>
  </ul>

  <ul>
    <li><a href="#class">class</a>
      <ul>
        <li><a href="#主构造器">主构造器</a></li>
        <li><a href="#次构造器">次构造器</a></li>
        <li><a href="#初始化块">初始化块</a></li>
        <li><a href="#创建实例">创建实例</a></li>
        <li><a href="#class-成员">class 成员</a></li>
        <li><a href="#继承">继承</a></li>
        <li><a href="#重写方法">重写方法</a></li>
        <li><a href="#重写属性">重写属性</a></li>
        <li><a href="#子类初始化顺序">子类初始化顺序</a></li>
        <li><a href="#调用父类的实现">调用父类的实现</a></li>
        <li><a href="#abstract-class">abstract class</a></li>
        <li><a href="#companion-objects">Companion Objects</a></li>
        <li><a href="#object-declaration">Object Declaration</a></li>
        <li><a href="#companion-object">companion object</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#声明属性">声明属性</a></li>
    <li><a href="#setter-和-getter">setter 和 getter</a></li>
  </ul>

  <ul>
    <li><a href="#接口中的属性">接口中的属性</a></li>
    <li><a href="#重写时的冲突解决">重写时的冲突解决</a></li>
  </ul>

  <ul>
    <li><a href="#module">module</a></li>
  </ul>

  <ul>
    <li><a href="#extension-function-1">extension function</a></li>
    <li><a href="#extension-是静态解析的">extension 是静态解析的</a></li>
    <li><a href="#nullable-接收者">nullable 接收者</a></li>
    <li><a href="#extension-属性">extension 属性</a></li>
    <li><a href="#companion-object-extensions">Companion Object Extensions</a></li>
    <li><a href="#定义-extension-作为成员">定义 extension 作为成员</a></li>
  </ul>

  <ul>
    <li><a href="#在-body-里声明属性">在 body 里声明属性</a></li>
    <li><a href="#copying">copying</a></li>
  </ul>

  <ul>
    <li><a href="#标准的-delegates">标准的 delegates</a></li>
    <li><a href="#storing-properties-in-a-map">Storing Properties in a Map</a></li>
  </ul>

  <ul>
    <li><a href="#it--隐式的单一的参数名字"><code>it</code> : 隐式的单一的参数名字</a></li>
    <li><a href="#_--忽略参数11-版本开始"><code>_</code> : 忽略参数:(1.1 版本开始)</a></li>
    <li><a href="#inline-function-1">inline function</a></li>
    <li><a href="#lambda-expression-和-匿名函数">lambda expression 和 匿名函数</a>
      <ul>
        <li><a href="#匿名函数">匿名函数</a></li>
      </ul>
    </li>
    <li><a href="#closures">closures</a></li>
    <li><a href="#function-literal-与-receiver">function literal 与 receiver</a></li>
  </ul>

  <ul>
    <li><a href="#开启-inline">开启 <code>inline</code></a></li>
    <li><a href="#noinline">noinline</a></li>
    <li><a href="#inline-properties">inline properties</a></li>
  </ul>

  <ul>
    <li><a href="#从一个函数中返回2个值">从一个函数中返回2个值</a></li>
    <li><a href="#在-map-中使用">在 map 中使用</a></li>
    <li><a href="#在-lambda-中使用">在 lambda 中使用</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="基本语法">基本语法</h1>
<h2 id="定义-package">定义 package</h2>
<blockquote>
<p>不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置</p>
</blockquote>
<p>源文件中的所有内容, 都是通过包声明来包含的. 即: <code>名包.方法名</code> 等</p>
<blockquote>
<p>特别地, 如果没指定包, 则该文件属于 <code>default</code> 包.(没有显式的名称的包)</p>
</blockquote>
<h3 id="默认导入的包">默认导入的包</h3>
<p>所有 kotlin 文件默认情况下, 都会导入以下包</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kotlin.*
kotlin.annotation.*
kotlin.collections.*
kotlin.comparisons.* <span style="color:#f92672">(</span>since 1.1<span style="color:#f92672">)</span>
kotlin.io.*
kotlin.ranges.*
kotlin.sequences.*
kotlin.text.*
</code></pre></div><p>根据不同的目标平台, 还会导入一些额外的包:</p>
<ul>
<li>JVM 平台</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">java.lang.*
kotlin.jvm.*
</code></pre></div><ul>
<li>JS 平台</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kotlin.js.*
</code></pre></div><h2 id="import-导入包">import, 导入包</h2>
<blockquote>
<p>import 指令不必限制于 classes 的, 你可以用它来导入其他的声明:</p>
</blockquote>
<ul>
<li>顶层的 方法和属性</li>
<li>声明在对象声明里的 方法和属性</li>
<li>枚举常量</li>
</ul>
<blockquote>
<p>不同于Java, Kotlin 没有单独的 <code>import static</code> 语法. 所有的导入, 都是通过 <code>import</code> 来声明的</p>
</blockquote>
<p>例子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">import foo.Bar

import foo.*

import bar.Bar as bBar
</code></pre></div><h2 id="定义函数">定义函数</h2>
<h3 id="语法">语法</h3>
<p>函数是通过 <code>fun</code> 关键字来定义的</p>
<h4 id="参数定义">参数定义</h4>
<p>它是使用 <code>Pascal</code> 风格来定义的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">name: type
</code></pre></div><p>即, <code>名称: 类型</code></p>
<h4 id="默认参数">默认参数</h4>
<p>即在 <code>type</code> 后使用 <code> = defaultValue</code> 来定义. 如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun read<span style="color:#f92672">(</span>b: Array&lt;Byte&gt;, off: Int <span style="color:#f92672">=</span> 0, len: Int <span style="color:#f92672">=</span> b.size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
...
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="override-method">override method</h5>
<p><code>override method</code> 总是与 <code>base method</code> 使用相同的默认值的!(注意, <code>总是</code>, always)~</p>
<p>当 <code>override method</code> 时, 要注意在方法签名里, 不能带有默认值! 否则会报如下错:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">An overriding <span style="color:#66d9ef">function</span> is not allowed to specify default values <span style="color:#66d9ef">for</span> its parameters
</code></pre></div><blockquote>
<p>如果一个方法中, 前面带有默认参数, 后面参数没有时, 这时如果想利用默认参数值的话, 则只能通过命名参数的方式来调用方法:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun foo<span style="color:#f92672">(</span>bar: Int <span style="color:#f92672">=</span> 0, baz: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> /* ... */ <span style="color:#f92672">}</span>

foo<span style="color:#f92672">(</span>baz <span style="color:#f92672">=</span> 1<span style="color:#f92672">)</span> // The default value bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> is used
</code></pre></div><p>但, 如果最后一个参数是 <code>lambda</code> 时, 则允许只直接传递最后一个没有默认值的 <code>lambda</code> 参数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun foo<span style="color:#f92672">(</span>bar: Int <span style="color:#f92672">=</span> 0, baz: Int <span style="color:#f92672">=</span> 1, qux: <span style="color:#f92672">()</span> -&gt; Unit<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> /* ... */ <span style="color:#f92672">}</span>

foo<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span> // Uses the default value baz <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> 
foo <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>    // Uses both default values bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> and baz <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h4 id="命名参数">命名参数</h4>
<p>当调用方法时, 允许通过命名参数的方式来调用.</p>
<h5 id="命名参数与位置参数混合调用时">命名参数与位置参数混合调用时</h5>
<p>规则为: 所有的位置参数必须在第一个命名参数的前面.即:</p>
<p>允许:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">f<span style="color:#f92672">(</span>1, y <span style="color:#f92672">=</span> 2<span style="color:#f92672">)</span>
</code></pre></div><p>但不允许:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">f<span style="color:#f92672">(</span>x <span style="color:#f92672">=</span> 1, 2<span style="color:#f92672">)</span>
</code></pre></div><h4 id="可变参数">可变参数</h4>
<p><code>vararg</code> 来声明</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun foo<span style="color:#f92672">(</span>vararg strings: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> /* ... */ <span style="color:#f92672">}</span>

foo<span style="color:#f92672">(</span>strings <span style="color:#f92672">=</span> *arrayOf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">))</span>
</code></pre></div><h4 id="unit-返回类型">Unit 返回类型</h4>
<p>如果一个方法没有返回值, 则它的返回类型为 <code>Unit</code>, 它是一种仅有唯一值 <code>Unit</code> 的类型.(可以忽略显式写法)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun printHello<span style="color:#f92672">(</span>name: String?<span style="color:#f92672">)</span>: Unit <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>name !<span style="color:#f92672">=</span> null<span style="color:#f92672">)</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">else</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hi there!&#34;</span><span style="color:#f92672">)</span>
    // <span style="color:#e6db74">`</span><span style="color:#66d9ef">return</span> Unit<span style="color:#e6db74">`</span> or <span style="color:#e6db74">`</span><span style="color:#66d9ef">return</span><span style="color:#e6db74">`</span> is optional
<span style="color:#f92672">}</span>
</code></pre></div><p>或</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun printHello<span style="color:#f92672">(</span>name: String?<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    ...
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="单一表达式-函数-single-expression-function">单一表达式 函数 (Single-Expression function)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun double<span style="color:#f92672">(</span>x: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">=</span> x * <span style="color:#ae81ff">2</span>
</code></pre></div><h4 id="infix-符号">infix 符号</h4>
<p>通过 <code>infix</code> 关键字的 <code>function</code> 也被称为使用 <code>infix</code> 符号记法(即, 允许忽略点和括号来调用). 它必须满足以下条件:</p>
<ul>
<li>它们必须是成员函数(member function)或扩展函数(extension function)</li>
<li>它们必须有一个参数</li>
<li>参数一定不能为可变参数, 也不能有默认值</li>
</ul>
<p>如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">infix fun Int.shl<span style="color:#f92672">(</span>x: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>

// calling the <span style="color:#66d9ef">function</span> using the infix notation
<span style="color:#ae81ff">1</span> shl <span style="color:#ae81ff">2</span>

// is the same as
1.shl<span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>
</code></pre></div><blockquote>
<p>注意, infix 函数 比 算术操作符, 类型转换换以入 rangeTo 操作符的优先级更低!</p>
</blockquote>
<p>注意, infix 函数总是要求指定 <code>receiver</code> 和 <code>parameter</code> 的!</p>
<ul>
<li>当你在一个方法里调用 infix 函数时, 你需要显式使用 <code>this</code> 作为 <code>receiver</code>, 其他的方法允许忽略它, 但 infix 方法不能忽略 <code>this</code>.</li>
</ul>
<p>这种要求用来确保解释时没有歧义!</p>
<h4 id="函数作用域">函数作用域</h4>
<h5 id="local-function">local function</h5>
<p>本地函数. 即一个函数在另一个函数里面.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun dfs<span style="color:#f92672">(</span>graph: Graph<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    fun dfs<span style="color:#f92672">(</span>current: Vertex, visited: Set&lt;Vertex&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!visited.add<span style="color:#f92672">(</span>current<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>v in current.neighbors<span style="color:#f92672">)</span>
            dfs<span style="color:#f92672">(</span>v, visited<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>

    dfs<span style="color:#f92672">(</span>graph.vertices<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>, HashSet<span style="color:#f92672">())</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>local function</code> 可以访问外部函数的 <code>local variable</code>. 如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun dfs<span style="color:#f92672">(</span>graph: Graph<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val visited <span style="color:#f92672">=</span> HashSet&lt;Vertex&gt;<span style="color:#f92672">()</span>
    fun dfs<span style="color:#f92672">(</span>current: Vertex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!visited.add<span style="color:#f92672">(</span>current<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>v in current.neighbors<span style="color:#f92672">)</span>
            dfs<span style="color:#f92672">(</span>v<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>

    dfs<span style="color:#f92672">(</span>graph.vertices<span style="color:#f92672">[</span>0<span style="color:#f92672">])</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="member-function">member function</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Sample<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Foo&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Sample<span style="color:#f92672">()</span>.foo<span style="color:#f92672">()</span> // creates instance of class Sample and calls foo
</code></pre></div><h5 id="generic-function">generic function</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun &lt;T&gt; singletonList<span style="color:#f92672">(</span>item: T<span style="color:#f92672">)</span>: List&lt;T&gt; <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="inline-function">inline function</h5>
<h5 id="extension-function">extension function</h5>
<h5 id="higher-order-function-和-lambda">higher-order function 和 lambda</h5>
<h5 id="tail-recursive-function">tail recursive function</h5>
<h3 id="例子">例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun sum<span style="color:#f92672">(</span>a: Int, b: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> a + b
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun sum<span style="color:#f92672">(</span>a: Int, b: Int<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> a + b
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun printSum<span style="color:#f92672">(</span>a: Int, b: Int<span style="color:#f92672">)</span>: Unit <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;sum of </span>$a<span style="color:#e6db74"> and </span>$b<span style="color:#e6db74"> is </span><span style="color:#e6db74">${</span>a + b<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun printSum<span style="color:#f92672">(</span>a: Int, b: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;sum of </span>$a<span style="color:#e6db74"> and </span>$b<span style="color:#e6db74"> is </span><span style="color:#e6db74">${</span>a + b<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="定义变量">定义变量</h2>
<p>一次性声明 local variable(read only):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val a: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>  // immediate assignment
val b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>   // <span style="color:#e6db74">`</span>Int<span style="color:#e6db74">`</span> type is inferred
val c: Int  // Type required when no initializer is provided
c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>       // deferred assignment
</code></pre></div><p>可变变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> // <span style="color:#e6db74">`</span>Int<span style="color:#e6db74">`</span> type is inferred
x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>顶层变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val PI <span style="color:#f92672">=</span> 3.14
var x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

fun incrementX<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> 
    x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> 
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="定义属性">定义属性</h3>
<p>在 kotlin 中, classes 可以有属性. 它们可通过使用 <code>var</code> 关键字来声明为可变的(mutable), 或 通过 <code>val</code> 关键字来声明为不可变的.</p>
<p>完整的语法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var &lt;propertyName&gt;<span style="color:#f92672">[</span>: &lt;PropertyType&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[=</span> &lt;property_initializer&gt;<span style="color:#f92672">]</span>
    <span style="color:#f92672">[</span>&lt;getter&gt;<span style="color:#f92672">]</span>
    <span style="color:#f92672">[</span>&lt;setter&gt;<span style="color:#f92672">]</span>
</code></pre></div><p>当声明为 <code>var</code> (可变) 的属性时, 它默认会有 <code>getter</code> 和 <code>setter</code> 方法.</p>
<p>当声明为 <code>val</code> (不可变) 的属性时, 它只有 <code>getter</code> 而没有 <code>setter</code> 方法</p>
<p>自定义访问方法: (1.1及之后版本, 可以忽略 属性的类型, 由 getter 方法来推断)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val isEmpty: Boolean
    get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> this.size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>自定义setter 方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var stringRepresentation: String
    get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> this.toString<span style="color:#f92672">()</span>
    set<span style="color:#f92672">(</span>value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        setDataFromString<span style="color:#f92672">(</span>value<span style="color:#f92672">)</span> // parses the string and assigns values to other properties
    <span style="color:#f92672">}</span>
</code></pre></div><p>如果你想修改 <code>getter 和 setter</code> 的访问权限或想注入它, 但又不想修改默认实现, 则可以这样子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var setterVisibility: String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span>
    private set // the setter is private and has the default implementation

var setterWithAnnotation: Any? <span style="color:#f92672">=</span> null
    @Inject set // annotate the setter with Inject
</code></pre></div><h4 id="compile-time-constant">compile time constant</h4>
<p>如果属性的值可以在编译时就可以确定的话, 则它可以标记为编译时常量. 通过 <code>const</code> 修饰符来设置.这样子的属性, 要完全满足以下要求:</p>
<ul>
<li>顶层或者是一个 object 的成员.</li>
<li>初始值的类型为 <code>String</code> 或为 基本数据类型 (primitive type)</li>
<li>没有自定义的 <code>setter</code> 方法</li>
</ul>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">const val SUBSYSTEM_DEPRECATED: String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;This subsystem is deprecated&#34;</span>
</code></pre></div><h4 id="late-initialized-属性和变量延迟初始化">late initialized 属性和变量(延迟初始化)</h4>
<p>通过 <code>lateinit</code> 修饰符来修饰.</p>
<p>条件为</p>
<ul>
<li>var 声明的变量</li>
<li>必须是 non null</li>
<li>没有自定义的 getter 和 setter</li>
<li>1.2及之后版本, 则为 顶层的属性 以及 local variable</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">public class MyTest <span style="color:#f92672">{</span>
    lateinit var subject: TestSubject

    @SetUp fun setup<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        subject <span style="color:#f92672">=</span> TestSubject<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>

    @Test fun test<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        subject.method<span style="color:#f92672">()</span>  // dereference directly
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>检测 <code>lateinit</code> 修改的变量是否初始化(1.2版本开始)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>foo::bar.isInitialized<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span>foo.bar<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="注释">注释</h2>
<p>行注释</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">//
</code></pre></div><p>块注释</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/*
*/
</code></pre></div><p>不同于Java, 在 kotlin 中, 块注释可以嵌套的~</p>
<h2 id="使用字符串模板">使用字符串模板</h2>
<p>字符串可以包含 <code>template expression</code>, 它是以一个 <code>$</code> 开头以及一个简单的变量或表达式组成的.</p>
<p>它在在 <code>raw string</code> 中也支持.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val price <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74"></span><span style="color:#e6db74">${</span><span style="color:#e6db74">&#39;$&#39;</span><span style="color:#e6db74">}</span><span style="color:#e6db74">9.99
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><h3 id="例子-1">例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
// simple name in template:
val s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;a is </span>$a<span style="color:#e6db74">&#34;</span> 

a <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
// arbitrary expression in template:
val s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>s1.replace(<span style="color:#e6db74">&#34;is&#34;</span>, <span style="color:#e6db74">&#34;was&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">, but now is </span>$a<span style="color:#e6db74">&#34;</span>
</code></pre></div><h2 id="null-安全的">Null 安全的</h2>
<p>Kotlin 的类型系统被设计于消除 null 引用的危险性的. 它可以区分是否一个引用能否为 <code>null</code> 的:</p>
<p>允许为 null:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var b: String? <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span>
b <span style="color:#f92672">=</span> null // ok
</code></pre></div><p>不允许为 null:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var a: String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span>
a <span style="color:#f92672">=</span> null // compilation error
</code></pre></div><h3 id="调用">调用</h3>
<h4 id="检查-null-条件">检查 null 条件</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>b !<span style="color:#f92672">=</span> null<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    //do something
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="安全调用">安全调用</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">b?.length
</code></pre></div><p>这种也可用于调用链中~</p>
<h3 id="elvis-操作符">elvis 操作符</h3>
<p><code>?:</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val l <span style="color:#f92672">=</span> b?.length ?: -1

等于同下面

val l: Int <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>b !<span style="color:#f92672">=</span> null<span style="color:#f92672">)</span> b.length <span style="color:#66d9ef">else</span> -1
</code></pre></div><h3 id="-操作符">!! 操作符</h3>
<p>如果引用为 null , 它会自动抛出 NPE 异常.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val l <span style="color:#f92672">=</span> b!!.length
</code></pre></div><h3 id="安全转换">安全转换</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val aInt: Int? <span style="color:#f92672">=</span> a as? Int
</code></pre></div><p>当目标对象不能正确转换时, 它会返回 <code>null</code></p>
<h3 id="nullable-类型的集合">nullable 类型的集合</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val nullableList: List&lt;Int?&gt; <span style="color:#f92672">=</span> listOf<span style="color:#f92672">(</span>1, 2, null, 4<span style="color:#f92672">)</span>
val intList: List&lt;Int&gt; <span style="color:#f92672">=</span> nullableList.filterNotNull<span style="color:#f92672">()</span>
</code></pre></div><h2 id="使用类型检查和自动转换">使用类型检查和自动转换</h2>
<p><code>is</code> 操作符检查一个表达式是否是一种类型的实例. 如果一个 immutable 的 local variable 或 属性 是已经检测为特定类型的话, 则不需要显式转换它. 例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun getStringLength<span style="color:#f92672">(</span>obj: Any<span style="color:#f92672">)</span>: Int? <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>obj is String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // <span style="color:#e6db74">`</span>obj<span style="color:#e6db74">`</span> is automatically cast to <span style="color:#e6db74">`</span>String<span style="color:#e6db74">`</span> in this branch
        <span style="color:#66d9ef">return</span> obj.length
    <span style="color:#f92672">}</span>

    // <span style="color:#e6db74">`</span>obj<span style="color:#e6db74">`</span> is still of type <span style="color:#e6db74">`</span>Any<span style="color:#e6db74">`</span> outside of the type-checked branch
    <span style="color:#66d9ef">return</span> null
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用-for-循环">使用 for 循环</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>item in collection<span style="color:#f92672">)</span> print<span style="color:#f92672">(</span>item<span style="color:#f92672">)</span>

<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>item: Int in ints<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>


<span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>index, value<span style="color:#f92672">)</span> in array.withIndex<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;the element at </span>$index<span style="color:#e6db74"> is </span>$value<span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用-while-循环">使用 while 循环</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>x &gt; 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    x--
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
    val y <span style="color:#f92672">=</span> retrieveData<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>y !<span style="color:#f92672">=</span> null<span style="color:#f92672">)</span> // y is visible here!
</code></pre></div><h2 id="when-表达式">when 表达式</h2>
<p>用于替换C系的 <code>switch</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">when <span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#ae81ff">1</span> -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x == 1&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#ae81ff">2</span> -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x == 2&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">else</span> -&gt; <span style="color:#f92672">{</span> // Note the block
        print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x is neither 1 nor 2&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

或

when <span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    0, <span style="color:#ae81ff">1</span> -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x == 0 or x == 1&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">else</span> -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;otherwise&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>

或

when <span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    in 1..10 -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x is in the range&#34;</span><span style="color:#f92672">)</span>
    in validNumbers -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x is valid&#34;</span><span style="color:#f92672">)</span>
    !in 10..20 -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;x is outside the range&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">else</span> -&gt; print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;none of the above&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用-range">使用 range</h2>
<p>范围操作符: <code>..</code></p>
<p>例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i in 1..10<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> // equivalent of <span style="color:#ae81ff">1</span> &lt;<span style="color:#f92672">=</span> i <span style="color:#f92672">&amp;&amp;</span> i &lt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    println<span style="color:#f92672">(</span>i<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>反序:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i in <span style="color:#ae81ff">4</span> downTo 1<span style="color:#f92672">)</span> print<span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> // prints <span style="color:#e6db74">&#34;4321&#34;</span>
</code></pre></div><p>步进</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i in 1..4 step 2<span style="color:#f92672">)</span> print<span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> // prints <span style="color:#e6db74">&#34;13&#34;</span>
</code></pre></div><p>until:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i in <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">until</span> 10<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> // i in <span style="color:#f92672">[</span>1, 10<span style="color:#f92672">)</span>, <span style="color:#ae81ff">10</span> is excluded
     println<span style="color:#f92672">(</span>i<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用集合">使用集合</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>item in items<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span>item<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>

when <span style="color:#f92672">{</span>
    <span style="color:#e6db74">&#34;orange&#34;</span> in items -&gt; println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;juicy&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#e6db74">&#34;apple&#34;</span> in items -&gt; println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apple is fine too&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>

或

fruits
.filter <span style="color:#f92672">{</span> it.startsWith<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
.sortedBy <span style="color:#f92672">{</span> it <span style="color:#f92672">}</span>
.map <span style="color:#f92672">{</span> it.toUpperCase<span style="color:#f92672">()</span> <span style="color:#f92672">}</span>
.forEach <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span>it<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</code></pre></div><h2 id="创建基本类和它们的实例">创建基本类和它们的实例</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val rectangle <span style="color:#f92672">=</span> Rectangle<span style="color:#f92672">(</span>5.0, 2.0<span style="color:#f92672">)</span> //no <span style="color:#e6db74">&#39;new&#39;</span> keyword required
val triangle <span style="color:#f92672">=</span> Triangle<span style="color:#f92672">(</span>3.0, 4.0, 5.0<span style="color:#f92672">)</span>
</code></pre></div><h1 id="源码组织">源码组织</h1>
<h2 id="目录结构">目录结构</h2>
<p>在一个混合语言的项目里, Kotlin 的源码应该与 Java 的源码的根目录相同, 并且跟随相同的目录结构(每个文件应该保存到 <code>package</code> 语句中的相应的目录)</p>
<p>在一个纯 Kotlin 的项目里, 建议目录的结构跟随在一个忽略了公共的根 package 下面(例如, 如果项目里所有的代码都是在 <code>org.example.kotlin</code> 包及子包下面, 则这些文件应该直接放在源码的根目录下, 并且文件在 <code>org.example.kotlin.foo.bar</code> 的则应该在源码的子目录 <code>foo/bar</code> 下面)</p>
<h2 id="源码文件名">源码文件名</h2>
<p>如果一个 kotlin 文件包含一个单独的 class , 则文件名应该与 class 的名字相同, 并带有 <code>.kt</code> 后缀.</p>
<p>如果包含多个 class, 或仅有顶层的声明的话, 则相应选择一个适当的描述的文件名. 使用 <code>CamelHumps</code> (驼峰命名), 例如 <code>ProcessDeclarations.kt</code></p>
<p>文件名应该选择适当描述文件内容的名称的. 因此, 应该避免使用无意义的单词, 例如 <code>Util</code> 这种文件名.</p>
<h2 id="源文件的组织">源文件的组织</h2>
<p>我们鼓励将多个声明(class, 层顶的函数或属性)放在同一个源文件里, 只要这些声明相关性是比较话的话, 并且文件的大小也比较适合(不超出几百行代码)</p>
<p>特别地, 当为某个 class 定义 <code>extension</code> 函数时, 则建议将它们放在同一个文件中.</p>
<h2 id="类层次">类层次</h2>
<p>通常, class 的内容是按以下顺序来保存的:</p>
<ul>
<li>属性声明和初始化块</li>
<li>构造器</li>
<li>方法声明</li>
<li>引用的对象</li>
</ul>
<p>不要将方法声明按字母或可见性来排序!</p>
<p>也不要分隔普通的方法和 extension 方法</p>
<p>相应的, 应该将相关性的放在一起, 以便人从上到下阅读源码时可以根据逻辑顺序来阅读.</p>
<p>将嵌套的类放在紧接着使用这些类的下面. 如果这些嵌套类是用于外部调用并且没有在内部使用的, 则放在类的最后.</p>
<h2 id="接口实现层">接口实现层</h2>
<p>如果实现一个接口的话, 则将实现的成员按接口中的相同顺序来保存.</p>
<p>如果有需要的话, 则为这些实现插入额外的私有方法.</p>
<h2 id="重载层">重载层</h2>
<p>总是将重载的方法放在一起!</p>
<h1 id="命名规则">命名规则</h1>
<p>跟随Java的命名规则. 特别地:</p>
<p>名包总是小写的, 并且不要使用下划线(<code>org.example.myproject</code>). 通常不建议使用多单词的名字, 但如果你确实需要, 你也可以简单地将它们拼接在一起, 或者使用驼峰式( <code>com.example.myProject</code>)</p>
<h2 id="函数名">函数名</h2>
<p>函数名, 属性名, 以及 local variable 应该以小写字母开头, 并且使用驼峰的形式(没有下划线).</p>
<p>例外:</p>
<p>工厂方法(用于创建类实例)的, 方法名可以跟类名一样(大写字母开头的驼峰)</p>
<h3 id="测试方法的命名">测试方法的命名</h3>
<blockquote>
<p>仅在测试方法中</p>
</blockquote>
<p>它可以接受用反单引号里带有空格的方法名.(注意: 这种方法暂不被 Android Runtime 支持)</p>
<p>带有下划线的命名也允许在测试代码中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class MyTestCase <span style="color:#f92672">{</span>
     @Test fun <span style="color:#e6db74">`</span>ensure everything works<span style="color:#e6db74">`</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
     <span style="color:#f92672">}</span>

     @Test fun ensureEverythingWorks_onAndroid<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
     <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="属性名">属性名</h2>
<p>常量的命名, 应该以大写和以下划线分隔的名字:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">const val MAX_COUNT <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
val USER_NAME_FIELD <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UserName&#34;</span>
</code></pre></div><p>其他的使用普通的驼峰命名(小写开头)</p>
<h1 id="修饰符的顺序">修饰符的顺序</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">public / protected / private / internal
expect / actual
final / open / abstract / sealed / const
external
override
lateinit
tailrec
vararg
suspend
inner
enum / annotation
companion
inline
infix
operator
data
</code></pre></div><h1 id="lable">Lable</h1>
<p>在 Kotlin 中任意的语句都可以标记有一个 <code>label</code> .</p>
<p>语法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">labelName@
</code></pre></div><p>即名称最后加个 <code>@</code></p>
<p>使用 label 时, 则将 <code>@</code> 放在名称开头即可:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">@labelName
</code></pre></div><h2 id="return-中使用-label">return 中使用 label</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    listOf<span style="color:#f92672">(</span>1, 2, 3, 4, 5<span style="color:#f92672">)</span>.forEach lit@<span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>it <span style="color:#f92672">==</span> 3<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span>@lit // local <span style="color:#66d9ef">return</span> to the caller of the lambda, i.e. the forEach loop
        print<span style="color:#f92672">(</span>it<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
    print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34; done with explicit label&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>return @a 1</code></p>
<p>表示在label <code>@a</code> 中进行 <code>return 1</code></p>
<h1 id="class-和-继承">class 和 继承</h1>
<h2 id="class">class</h2>
<p>通过关键字 <code>class</code> 来定义</p>
<p>组成:</p>
<ul>
<li>class name</li>
<li>class header(指定它的参数, 主构造器, primary constructor 等)</li>
<li>class body(用大括号包着)</li>
</ul>
<p>header 和 body 都是可选的. 如果没有 body 的话:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Empty
</code></pre></div><p>即可.</p>
<h3 id="主构造器">主构造器</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Person constructor<span style="color:#f92672">(</span>firstName: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果主构造器没有任何的 annotation 或 可见性修饰符, 则可以省略 <code>constructor</code> 关键字:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Person<span style="color:#f92672">(</span>firstName: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>注意, 主构造器不能有任何代码!初始化代码可以被放在 <code>initializer blocks</code> (初始化块中). 它是以 <code>init</code> 关键字为开头的代码块.它的初始化顺序, 就是代码出现的顺序. 例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class InitOrderDemo<span style="color:#f92672">(</span>name: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val firstProperty <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;First property: </span>$name<span style="color:#e6db74">&#34;</span>.also<span style="color:#f92672">(</span>::println<span style="color:#f92672">)</span>

    init <span style="color:#f92672">{</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;First initializer block that prints </span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>

    val secondProperty <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Second property: </span><span style="color:#e6db74">${</span>name.length<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>.also<span style="color:#f92672">(</span>::println<span style="color:#f92672">)</span>

    init <span style="color:#f92672">{</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Second initializer block that prints </span><span style="color:#e6db74">${</span>name.length<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果一个非抽象的 class 没有声明任何的构造器(主或次), 它会自动生成一个没有参数的 <code>public</code> 的主构造器. 如果你需要修改这访问权限的话, 则要显式地这样子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class DontCreateMe private constructor <span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>在JVM平台上, 如果主构造器的所有参数都有默认值的话, 编译器会生成一个额外的无参构造器, 它将使用这些默认值.这使 Kotlin 使用一些类似 Jackson 或 JPA 这些库更方便, 它们需要通过无参构造器来创建实例.</p>
</blockquote>
<h3 id="次构造器">次构造器</h3>
<blockquote>
<p>可以有多个</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Person <span style="color:#f92672">{</span>
    constructor<span style="color:#f92672">(</span>parent: Person<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        parent.children.add<span style="color:#f92672">(</span>this<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果一个 class 有一个 主构造器, 则每一个次构造器都需要委派给(delegate to)主构造器: 通过 <code>this</code> 关键字来做:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Person<span style="color:#f92672">(</span>val name: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    constructor<span style="color:#f92672">(</span>name: String, parent: Person<span style="color:#f92672">)</span> : this<span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        parent.children.add<span style="color:#f92672">(</span>this<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="初始化块">初始化块</h3>
<p>注意, 初始化块相当于主构造器的一部分. 委派给主构造器会相当于在次构造器的第一条语句中执行.</p>
<p>因此, 所有在初始化块的代码, 都会在次构器代码之前执行! 即使 class 没有主构造器也一样!</p>
<h3 id="创建实例">创建实例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val invoice <span style="color:#f92672">=</span> Invoice<span style="color:#f92672">()</span>

val customer <span style="color:#f92672">=</span> Customer<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Joe Smith&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>注意, 不需要 <code>new</code> 关键字.</p>
<h3 id="class-成员">class 成员</h3>
<p>它可以包含</p>
<ul>
<li>构造器来初始化块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套以及内部类</li>
<li>对象声明</li>
</ul>
<h3 id="继承">继承</h3>
<p>所有 Kotlin 类都有一个公共的超类 <code>Any</code> .</p>
<p>注意, <code>Any</code> 不是 <code>java.lang.Object</code> . 特别地, 它没有任何的成员, 除了 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> 之外.</p>
<p>显式指定继承的类, 可以在 class header 之后加个冒号. 如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Derived<span style="color:#f92672">(</span>p: Int<span style="color:#f92672">)</span> : Base<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span>
</code></pre></div><p>注意, 默认情况下, 所有的 Kotlin 类都是 <code>final</code> 的(基于 Effective Java 的第17条规则).</p>
<p>可以通过 <code>open</code> 来改变:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class Base<span style="color:#f92672">(</span>p: Int<span style="color:#f92672">)</span>
</code></pre></div><p>这样子, 就允许该类被继承了.</p>
<p>如果子类有一个主构造器, 则父类可以且必需被初始化在正确的地方.</p>
<p>如果子类没有主构造器, 则每个子类中的次构造器必须通过 <code>super</code> 关键字来进行委派另一个构造器来初始化.</p>
<h3 id="重写方法">重写方法</h3>
<p>不同于Java, Kotlin 中要求显式使用 <code>override</code> 来指明这是一个重写的方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class Base <span style="color:#f92672">{</span>
    open fun v<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
    fun nv<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
<span style="color:#f92672">}</span>
class Derived<span style="color:#f92672">()</span> : Base<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override fun v<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>一个标记为 <code>override</code> 的成员, 本身是 <code>open</code> 的. 如果你想禁止它重写, 则可使用 <code>final</code> 关键字:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class AnotherDerived<span style="color:#f92672">()</span> : Base<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    final override fun v<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="重写属性">重写属性</h3>
<p>重写属性也必须显式使用 <code>override</code>, 并且它们必须有一个兼容的类型.</p>
<p>如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class Foo <span style="color:#f92672">{</span>
    open val x: Int get<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

class Bar1 : Foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override val x: Int <span style="color:#f92672">=</span> ...
<span style="color:#f92672">}</span>
</code></pre></div><p>注意, 也可以在主构造器中使用 <code>override</code> 关键字作为属性声明的一部分.:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">interface Foo <span style="color:#f92672">{</span>
    val count: Int
<span style="color:#f92672">}</span>

class Bar1<span style="color:#f92672">(</span>override val count: Int<span style="color:#f92672">)</span> : Foo

class Bar2 : Foo <span style="color:#f92672">{</span>
    override var count: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="子类初始化顺序">子类初始化顺序</h3>
<p>父类先初始化完, 再到子类.</p>
<p>这意味着, 在父类构造器执行期间, 子类中的声明的或重写的属性还没有初始化完毕的. 如果这些属性用在父类的初始化逻辑(不管是直接还是间接, 还是其他通过重写 <code>open</code> 成员来实现), 它可能会导致不正确的行为, 或者一个 runtime 失败.</p>
<p>设计一个父类时, 因此你应该避免在构造器, 属性初始化以及<code>init</code> 代码块中使用 <code>open</code> 的成员.</p>
<h3 id="调用父类的实现">调用父类的实现</h3>
<p>通过 <code>super</code> 关键字来调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class Foo <span style="color:#f92672">{</span>
    open fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Foo.f()&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
    open val x: Int get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#f92672">}</span>

class Bar : Foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> 
        super.f<span style="color:#f92672">()</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Bar.f()&#34;</span><span style="color:#f92672">)</span> 
    <span style="color:#f92672">}</span>

    override val x: Int get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> super.x + <span style="color:#ae81ff">1</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在一个内部类中, 访问外部类的父类时, 可以通过 <code>super</code> 并带有外部类的名来实现: <code>super@Outer</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Bar : Foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> /* ... */ <span style="color:#f92672">}</span>
    override val x: Int get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

    inner class Baz <span style="color:#f92672">{</span>
        fun g<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            super@Bar.f<span style="color:#f92672">()</span> // Calls Foo<span style="color:#e6db74">&#39;s implementation of f()
</span><span style="color:#e6db74">            println(super@Bar.x) // Uses Foo&#39;</span>s implementation of x<span style="color:#960050;background-color:#1e0010">&#39;</span>s getter
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="重写规则">重写规则</h4>
<p><em>如果一个类从它的直接父类中继承了多个相同的成员, 则它必须重写它自己的成员, 并且提供它自己的实现.</em></p>
<p>为了指明使用哪个父类的实现, 可以通过 <code>super</code> 关键字, 并在带有 <code>类括号</code> 里写上父类类型. 例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class A <span style="color:#f92672">{</span>
    open fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
    fun a<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

interface B <span style="color:#f92672">{</span>
    fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span> // interface members are <span style="color:#e6db74">&#39;open&#39;</span> by default
    fun b<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

class C<span style="color:#f92672">()</span> : A<span style="color:#f92672">()</span>, B <span style="color:#f92672">{</span>
    // The compiler requires f<span style="color:#f92672">()</span> to be overridden:
    override fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        super&lt;A&gt;.f<span style="color:#f92672">()</span> // call to A.f<span style="color:#f92672">()</span>
        super&lt;B&gt;.f<span style="color:#f92672">()</span> // call to B.f<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="abstract-class">abstract class</h3>
<p>注意, 我们不需要标记一个抽象类或函数为 <code>open</code> 的, 默认就是 <code>open</code> 的.</p>
<p>我们可以将一个非抽象的 <code>open</code> 成员, 重写为 <code>abstract</code> 的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class Base <span style="color:#f92672">{</span>
    open fun f<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
<span style="color:#f92672">}</span>

abstract class Derived : Base<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override abstract fun f<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="companion-objects">Companion Objects</h3>
<p>在 Kotlin 中, 不像 Java 或 C# , 它没有静态方法的. 绝大部分情况下, 建议简单地使用 包级别的方法来代码~</p>
<p>如果你需要写一个函数可以不需要通过类实例就可以调用的话. 你可以将它写为一个 <code>object declaration</code> 的成员即可.</p>
<p>更具体地, 你可以声明一个 <code>companion object</code> 在你的类里. 这样, 你就可以像Java调用静态方法那样来调用它了.</p>
<h3 id="object-declaration">Object Declaration</h3>
<p>单例某几种情况下是非常有用的, 在 Kotlin 中, 你可以非常方便地声明单例:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">object DataProviderManager <span style="color:#f92672">{</span>
    fun registerDataProvider<span style="color:#f92672">(</span>provider: DataProvider<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // ...
    <span style="color:#f92672">}</span>

    val allDataProviders: Collection&lt;DataProvider&gt;
        get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> // ...
<span style="color:#f92672">}</span>
</code></pre></div><p>这被称为 <code>object declaration</code> , 并且它总是一个 <code>object</code> 关键字后接一个名字的.</p>
<p><code>object declaration</code> 的初始化是线程安全的.</p>
<h3 id="companion-object">companion object</h3>
<p>在一个类内部进行 <code>object declaration</code> 的话, 它可以用 <code>companion</code> 关键字来标记.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class MyClass <span style="color:#f92672">{</span>
    companion object Factory <span style="color:#f92672">{</span>
        fun create<span style="color:#f92672">()</span>: MyClass <span style="color:#f92672">=</span> MyClass<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>然后可以这样子简化调用:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val instance <span style="color:#f92672">=</span> MyClass.create<span style="color:#f92672">()</span>
</code></pre></div><p>声明时, <code>companion object</code> 的名称可以省略:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class MyClass <span style="color:#f92672">{</span>
    companion object <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

val x <span style="color:#f92672">=</span> MyClass.Companion
</code></pre></div><h1 id="属性和字段">属性和字段</h1>
<h2 id="声明属性">声明属性</h2>
<p><code>var</code> 的表示是可变的(mutable)
<code>val</code> 的表示是只读的(read-only)</p>
<h2 id="setter-和-getter">setter 和 getter</h2>
<p>完整的语法为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var &lt;propertyName&gt;<span style="color:#f92672">[</span>: &lt;PropertyType&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[=</span> &lt;property_initializer&gt;<span style="color:#f92672">]</span>
    <span style="color:#f92672">[</span>&lt;getter&gt;<span style="color:#f92672">]</span>
    <span style="color:#f92672">[</span>&lt;setter&gt;<span style="color:#f92672">]</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var stringRepresentation: String
    get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> this.toString<span style="color:#f92672">()</span>
    set<span style="color:#f92672">(</span>value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        setDataFromString<span style="color:#f92672">(</span>value<span style="color:#f92672">)</span> // parses the string and assigns values to other properties
    <span style="color:#f92672">}</span>
</code></pre></div><h1 id="接口-interface">接口 interface</h1>
<p>与 Java 8 非常相似.</p>
<p>它可以包含抽象方法, 也可以有方法实现. 使用 <code>interface</code> 关键字来定义:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">interface MyInterface <span style="color:#f92672">{</span>
    fun bar<span style="color:#f92672">()</span>
    fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      // optional body
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>实现接口</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Child : MyInterface <span style="color:#f92672">{</span>
    override fun bar<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        // body
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="接口中的属性">接口中的属性</h2>
<p>可以为抽象的, 也可以提供访问器实现.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">interface MyInterface <span style="color:#f92672">{</span>
    val prop: Int // abstract

    val propertyWithImplementation: String
        get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;foo&#34;</span>

    fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        print<span style="color:#f92672">(</span>prop<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

class Child : MyInterface <span style="color:#f92672">{</span>
    override val prop: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">29</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="重写时的冲突解决">重写时的冲突解决</h2>
<p>参考上面说的.</p>
<h1 id="访问修饰符">访问修饰符</h1>
<p><code>getter</code> 总是与属性的访问性是一致的!一共有4种:</p>
<ul>
<li><code>private</code> : 仅声明的地方可以访问.</li>
<li><code>protected</code> : 在顶层的声明中不可用.</li>
<li><code>internal</code> : 在相同的 <code>module</code> 中可见.</li>
<li><code>public</code> (默认就是 <code>public</code>) : 所有代码都可以访问.</li>
</ul>
<h2 id="module">module</h2>
<p>一个 <code>module</code> 表示是一个 kotlin 文件编译在一起的集合:</p>
<ul>
<li>一个 intellij 的 moduel</li>
<li>一个 maven 项目</li>
<li>一个 gradle 文件源的集合</li>
<li>一个 ant task 编译的集合</li>
</ul>
<h1 id="extension-扩展">extension 扩展</h1>
<h2 id="extension-function-1">extension function</h2>
<p>为了声明一个扩展函数, 我们需要有一个接收者类型的前缀, 例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun MutableList&lt;Int&gt;.swap<span style="color:#f92672">(</span>index1: Int, index2: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val tmp <span style="color:#f92672">=</span> this<span style="color:#f92672">[</span>index1<span style="color:#f92672">]</span> // <span style="color:#e6db74">&#39;this&#39;</span> corresponds to the list
    this<span style="color:#f92672">[</span>index1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> this<span style="color:#f92672">[</span>index2<span style="color:#f92672">]</span>
    this<span style="color:#f92672">[</span>index2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp
<span style="color:#f92672">}</span>
</code></pre></div><p><code>this</code> 关键字对应于接收者的对象. 现在, 我们可以调用在任意的<code>MutableList&lt;Int&gt;</code> 中调用这个方法了:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val l <span style="color:#f92672">=</span> mutableListOf<span style="color:#f92672">(</span>1, 2, 3<span style="color:#f92672">)</span>
l.swap<span style="color:#f92672">(</span>0, 2<span style="color:#f92672">)</span> // <span style="color:#e6db74">&#39;this&#39;</span> inside <span style="color:#e6db74">&#39;swap()&#39;</span> will hold the value of <span style="color:#e6db74">&#39;l&#39;</span>
</code></pre></div><p>当然, 也可以是泛型版本:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun &lt;T&gt; MutableList&lt;T&gt;.swap<span style="color:#f92672">(</span>index1: Int, index2: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val tmp <span style="color:#f92672">=</span> this<span style="color:#f92672">[</span>index1<span style="color:#f92672">]</span> // <span style="color:#e6db74">&#39;this&#39;</span> corresponds to the list
    this<span style="color:#f92672">[</span>index1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> this<span style="color:#f92672">[</span>index2<span style="color:#f92672">]</span>
    this<span style="color:#f92672">[</span>index2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="extension-是静态解析的">extension 是静态解析的</h2>
<p>扩展函数实际上并不修改它们扩展的 class 的. 通过定义一个 extension, 你并没有插入新的成员到该 class 中, 但仅是在该类型的变量中通过 <code>.</code> 来调用这个方法而已.</p>
<p>我们想强调的是,  extension function 是通过静态分发的.</p>
<p>注意, 如果 class 中有一个成员函数, 以及一个 extension 函数, 它们的方法签名一样的话,则 <code>member always wins!</code></p>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class C <span style="color:#f92672">{</span>
    fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;member&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

fun C.foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;extension&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</code></pre></div><p>它总是会输出 <code>member</code>.</p>
<p>然而, 可以通过 extension 来重载 (overload) 成员函数(即相同的方法名, 但签名不一样)</p>
<h2 id="nullable-接收者">nullable 接收者</h2>
<p>你可以在方法内部检查是否为 <code>null</code> 例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun Any?.toString<span style="color:#f92672">()</span>: String <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>this <span style="color:#f92672">==</span> null<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;null&#34;</span>
    // after the null check, <span style="color:#e6db74">&#39;this&#39;</span> is autocast to a non-null type, so the toString<span style="color:#f92672">()</span> below
    // resolves to the member <span style="color:#66d9ef">function</span> of the Any class
    <span style="color:#66d9ef">return</span> toString<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="extension-属性">extension 属性</h2>
<p>类似函数, kotlin 支持扩展属性:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> size - <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="companion-object-extensions">Companion Object Extensions</h2>
<p>如果一个 class 有 <code>companion object</code> , 你也可以为它定义一个扩展函数和扩展属性:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class MyClass <span style="color:#f92672">{</span>
    companion object <span style="color:#f92672">{</span> <span style="color:#f92672">}</span>  // will be called <span style="color:#e6db74">&#34;Companion&#34;</span>
<span style="color:#f92672">}</span>

fun MyClass.Companion.foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>
</code></pre></div><p>调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">MyClass.foo<span style="color:#f92672">()</span>
</code></pre></div><h2 id="定义-extension-作为成员">定义 extension 作为成员</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class D <span style="color:#f92672">{</span>
    fun bar<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

class C <span style="color:#f92672">{</span>
    fun baz<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>

    fun D.foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        bar<span style="color:#f92672">()</span>   // calls D.bar
        baz<span style="color:#f92672">()</span>   // calls C.baz
    <span style="color:#f92672">}</span>

    fun caller<span style="color:#f92672">(</span>d: D<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        d.foo<span style="color:#f92672">()</span>   // call the extension <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="data-classes">Data classes</h1>
<p>我们经常会创建一些主要用来持有数据的 class . 这在 Kotlin 中称为 <code>data</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">data class User<span style="color:#f92672">(</span>val name: String, val age: Int<span style="color:#f92672">)</span>
</code></pre></div><p>编译器会自动为声明在主构造器(primary constructor) 中的属性创建以下</p>
<ul>
<li><code>equals() / hashCode()</code> 方法对</li>
<li><code>toString()</code> , 形式为 <code>User(name=John, age=42)</code></li>
<li><code>componentN()</code> 函数</li>
<li><code>copy()</code> 函数</li>
</ul>
<p>前提条件(要全满足)</p>
<ul>
<li>主构造器至少要有一个参数</li>
<li>所以主构造器的参数需要标记为 <code>val</code> 或 <code>var</code></li>
<li>data class 不能为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或 <code>inner</code> 的.</li>
<li>(1.1之前), data class 仅实现接口</li>
</ul>
<p>生成代码的规则:</p>
<ul>
<li>如果显式实现了 <code>equals()</code>, <code>hashCode()</code> 或 <code>toString()</code> , 或父类的这些实现是 <code>final</code> 的话, 则不会生成这些代码了, 它会用现成的代码</li>
<li>如果父类有 <code>componentN()</code> 函数, 并且为 <code>open</code> 以及返回兼容的类型, 则会生成的代码会重写父类的. 如果不能重写, 则会报错.</li>
<li>从一个有 <code>copy()</code> 函数的类中派生的话, 在 1.2 中是标记为 <code>deprecated</code> 的, 并且 在 1.3 中是禁止的.</li>
<li>不允许显式实现 <code>componentN()</code> 和 <code>copy()</code> 函数</li>
</ul>
<h2 id="在-body-里声明属性">在 body 里声明属性</h2>
<p>注意: 只有在主构造器的参数的, 才会在 <code>toString()</code> , <code>equals()</code> 和 <code>hashCode()</code>, <code>copy()</code> 中使用到. 如果是在 body 中声明的, 则不会使用.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">data class Person<span style="color:#f92672">(</span>val name: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    var age: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="copying">copying</h2>
<p>有时, 我们经常需要 copy 一个对象, 但仅修改某些属性, 又不想影响原有对象. <code>copy()</code> 方法就是为它使用的.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun copy<span style="color:#f92672">(</span>name: String <span style="color:#f92672">=</span> this.name, age: Int <span style="color:#f92672">=</span> this.age<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> User<span style="color:#f92672">(</span>name, age<span style="color:#f92672">)</span>


val jack <span style="color:#f92672">=</span> User<span style="color:#f92672">(</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Jack&#34;</span>, age <span style="color:#f92672">=</span> 1<span style="color:#f92672">)</span>
val olderJack <span style="color:#f92672">=</span> jack.copy<span style="color:#f92672">(</span>age <span style="color:#f92672">=</span> 2<span style="color:#f92672">)</span>
</code></pre></div><h1 id="sealed-classes">Sealed Classes</h1>
<p><code>sealed classes</code> 是用来表示有限的 class 继承的, 它的值仅可以为一些有限集合之中的一种类型, 并且不能为其他类型.</p>
<p>在某种意义上说, 它是一个扩展的枚举类, 值的集合是限定为枚举类, 但每个枚举常量仅存在一个单例, 而 <code>sealed class</code> 的子类则可以有多个实例状态.</p>
<p>声明一个 <code>sealed class</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sealed class Expr
</code></pre></div><p><code>sealed class</code> 可以有子类, 但所有这些子类, 必须在声明 <code>sealed class</code> 的文件内!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sealed class Expr
data class Const<span style="color:#f92672">(</span>val number: Double<span style="color:#f92672">)</span> : Expr<span style="color:#f92672">()</span>
data class Sum<span style="color:#f92672">(</span>val e1: Expr, val e2: Expr<span style="color:#f92672">)</span> : Expr<span style="color:#f92672">()</span>
object NotANumber : Expr<span style="color:#f92672">()</span>
</code></pre></div><p><code>sealed class</code> 不允许有非 private 的构造器(默认就是 <code>private</code> 的)</p>
<p><code>sealed class</code> 主要用在 <code>when</code> 表达式~</p>
<h1 id="generic-泛型">generic 泛型</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Box&lt;T&gt;<span style="color:#f92672">(</span>t: T<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    var value <span style="color:#f92672">=</span> t
<span style="color:#f92672">}</span>
</code></pre></div><p>如果参数是可以被解析的话, 则可以忽略类型:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val box <span style="color:#f92672">=</span> Box<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> // <span style="color:#ae81ff">1</span> has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;
</code></pre></div><h1 id="嵌套类和内部类">嵌套类和内部类</h1>
<p>嵌套类:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Outer <span style="color:#f92672">{</span>
    private val bar: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    class Nested <span style="color:#f92672">{</span>
        fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

val demo <span style="color:#f92672">=</span> Outer.Nested<span style="color:#f92672">()</span>.foo<span style="color:#f92672">()</span> // <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>
</code></pre></div><p>内部类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Outer <span style="color:#f92672">{</span>
    private val bar: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    inner class Inner <span style="color:#f92672">{</span>
        fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> bar
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>匿名内部类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">window.addMouseListener<span style="color:#f92672">(</span>object: MouseAdapter<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override fun mouseClicked<span style="color:#f92672">(</span>e: MouseEvent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // ...
    <span style="color:#f92672">}</span>

    override fun mouseEntered<span style="color:#f92672">(</span>e: MouseEvent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // ...
    <span style="color:#f92672">}</span>
<span style="color:#f92672">})</span>
</code></pre></div><h1 id="枚举类">枚举类</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">enum class Direction <span style="color:#f92672">{</span>
    NORTH, SOUTH, WEST, EAST
<span style="color:#f92672">}</span>
</code></pre></div><p>初始化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">enum class Color<span style="color:#f92672">(</span>val rgb: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        RED<span style="color:#f92672">(</span>0xFF0000<span style="color:#f92672">)</span>,
        GREEN<span style="color:#f92672">(</span>0x00FF00<span style="color:#f92672">)</span>,
        BLUE<span style="color:#f92672">(</span>0x0000FF<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>匿名类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">enum class ProtocolState <span style="color:#f92672">{</span>
    WAITING <span style="color:#f92672">{</span>
        override fun signal<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> TALKING
    <span style="color:#f92672">}</span>,

    TALKING <span style="color:#f92672">{</span>
        override fun signal<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> WAITING
    <span style="color:#f92672">}</span>;

    abstract fun signal<span style="color:#f92672">()</span>: ProtocolState
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="object-expression-和-declaration">object expression 和 declaration</h1>
<p>有时, 我们需要创建一个对象来小小修改一些 class 的, 不用为它显式声明一个新的子类. 在Java中, 处理这种情况的, 是用匿名内部类. Kotlin 则是用 <code>object expression</code> 和 <code>object declaration</code></p>
<p>为现有的类型创建一个匿名类型, 可以这样子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">window.addMouseListener<span style="color:#f92672">(</span>object : MouseAdapter<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    override fun mouseClicked<span style="color:#f92672">(</span>e: MouseEvent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // ...
    <span style="color:#f92672">}</span>

    override fun mouseEntered<span style="color:#f92672">(</span>e: MouseEvent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        // ...
    <span style="color:#f92672">}</span>
<span style="color:#f92672">})</span>
</code></pre></div><p>如果父类是多种类型的话, 则用逗号隔开:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">open class A<span style="color:#f92672">(</span>x: Int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    public open val y: Int <span style="color:#f92672">=</span> x
<span style="color:#f92672">}</span>

interface B <span style="color:#f92672">{</span>...<span style="color:#f92672">}</span>

val ab: A <span style="color:#f92672">=</span> object : A<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>, B <span style="color:#f92672">{</span>
    override val y <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>但我们仅需要一个对象的话, 则我们可以简单地:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    val adHoc <span style="color:#f92672">=</span> object <span style="color:#f92672">{</span>
        var x: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        var y: Int <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#f92672">}</span>
    print<span style="color:#f92672">(</span>adHoc.x + adHoc.y<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>object declaration , 参考前面.</p>
<h1 id="delegation-委托">Delegation 委托</h1>
<p><code>delegation</code> 模式提供了一个比较好的修改实现的方式. <code>Kotlin</code> 则原生支持它. 一个 <code>Derived</code> 类, 可以继承一个接口 <code>Base</code> 并且委托它所有的 <code>public</code> 方法到一个指定的对象:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">interface Base <span style="color:#f92672">{</span>
    fun print<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>

class BaseImpl<span style="color:#f92672">(</span>val x: Int<span style="color:#f92672">)</span> : Base <span style="color:#f92672">{</span>
    override fun print<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> print<span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

class Derived<span style="color:#f92672">(</span>b: Base<span style="color:#f92672">)</span> : Base by b

fun main<span style="color:#f92672">(</span>args: Array&lt;String&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val b <span style="color:#f92672">=</span> BaseImpl<span style="color:#f92672">(</span>10<span style="color:#f92672">)</span>
    Derived<span style="color:#f92672">(</span>b<span style="color:#f92672">)</span>.print<span style="color:#f92672">()</span> // prints <span style="color:#ae81ff">10</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>by</code> 子句, 在 <code>Derived</code> class 中, 指示 <code>b</code> 将被内部保存在 <code>Derived</code> 中, 并且编译器将生成所有 <code>Base</code> 类的方法到 <code>b</code></p>
<p>注意, <code>override</code> : 编译器会使用你的 <code>override</code> 的实现来委托.</p>
<h1 id="delegated-properties">Delegated Properties</h1>
<p>有一些公共的属性, 尽管我们可以手工多次实现它, 但更好的是实现它一次, 然后放到一个库中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class Example <span style="color:#f92672">{</span>
    var p: String by Delegate<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>


class Delegate <span style="color:#f92672">{</span>
    operator fun getValue<span style="color:#f92672">(</span>thisRef: Any?, property: KProperty&lt;*&gt;<span style="color:#f92672">)</span>: String <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span>$thisRef<span style="color:#e6db74">, thank you for delegating &#39;</span><span style="color:#e6db74">${</span>property.name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39; to me!&#34;</span>
    <span style="color:#f92672">}</span>

    operator fun setValue<span style="color:#f92672">(</span>thisRef: Any?, property: KProperty&lt;*&gt;, value: String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;</span>$value<span style="color:#e6db74"> has been assigned to &#39;</span><span style="color:#e6db74">${</span>property.name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39; in </span>$thisRef<span style="color:#e6db74">.&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="标准的-delegates">标准的 delegates</h2>
<ul>
<li>Lazy</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val lazyValue: String by lazy <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;computed!&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#e6db74">&#34;Hello&#34;</span>
<span style="color:#f92672">}</span>

fun main<span style="color:#f92672">(</span>args: Array&lt;String&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    println<span style="color:#f92672">(</span>lazyValue<span style="color:#f92672">)</span>
    println<span style="color:#f92672">(</span>lazyValue<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>Observable</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">import kotlin.properties.Delegates

class User <span style="color:#f92672">{</span>
    var name: String by Delegates.observable<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&lt;no name&gt;&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        prop, old, new -&gt;
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;</span>$old<span style="color:#e6db74"> -&gt; </span>$new<span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

fun main<span style="color:#f92672">(</span>args: Array&lt;String&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val user <span style="color:#f92672">=</span> User<span style="color:#f92672">()</span>
    user.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;first&#34;</span>
    user.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;second&#34;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="storing-properties-in-a-map">Storing Properties in a Map</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class User<span style="color:#f92672">(</span>val map: Map&lt;String, Any?&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val name: String by map
    val age: Int     by map
<span style="color:#f92672">}</span>


val user <span style="color:#f92672">=</span> User<span style="color:#f92672">(</span>mapOf<span style="color:#f92672">(</span>
    <span style="color:#e6db74">&#34;name&#34;</span> to <span style="color:#e6db74">&#34;John Doe&#34;</span>,
    <span style="color:#e6db74">&#34;age&#34;</span>  to <span style="color:#ae81ff">25</span>
<span style="color:#f92672">))</span>
</code></pre></div><h1 id="higher-order-function-和-lambda-1">higher-order function 和 lambda</h1>
<p><code>higher-order function</code> 是这样一种函数: 它可以作为参数或函数返回值. 例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun &lt;T&gt; lock<span style="color:#f92672">(</span>lock: Lock, body: <span style="color:#f92672">()</span> -&gt; T<span style="color:#f92672">)</span>: T <span style="color:#f92672">{</span>
    lock.lock<span style="color:#f92672">()</span>
    try <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> body<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
    finally <span style="color:#f92672">{</span>
        lock.unlock<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="it--隐式的单一的参数名字"><code>it</code> : 隐式的单一的参数名字</h2>
<p>如果 lambda 只有一个参数时, 可以这样子简写(并且不需要 <code>-&gt;</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ints.map <span style="color:#f92672">{</span> it * <span style="color:#ae81ff">2</span> <span style="color:#f92672">}</span>
</code></pre></div><h2 id="_--忽略参数11-版本开始"><code>_</code> : 忽略参数:(1.1 版本开始)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">map.forEach <span style="color:#f92672">{</span> _, value -&gt; println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;</span>$value<span style="color:#e6db74">!&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</code></pre></div><h2 id="inline-function-1">inline function</h2>
<p>它一般可增强性能.</p>
<h2 id="lambda-expression-和-匿名函数">lambda expression 和 匿名函数</h2>
<p>它们都是 <code>function iteral</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">max<span style="color:#f92672">(</span>strings, <span style="color:#f92672">{</span> a, b -&gt; a.length &lt; b.length <span style="color:#f92672">})</span>
</code></pre></div><h3 id="匿名函数">匿名函数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fun<span style="color:#f92672">(</span>x: Int, y: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">=</span> x + y

fun<span style="color:#f92672">(</span>x: Int, y: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> x + y
<span style="color:#f92672">}</span>

ints.filter<span style="color:#f92672">(</span>fun<span style="color:#f92672">(</span>item<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> item &gt; 0<span style="color:#f92672">)</span>
</code></pre></div><h2 id="closures">closures</h2>
<p>一个 <code>lambda expression</code> 或 <code>anonymous function</code> 可以访问它的 <code>closure</code> (例如, 一个声明在外部的变量) 不同于Java, 捕获的变量可以被修改(Java中, 只能访问 <code>final</code> 的变量)</p>
<h2 id="function-literal-与-receiver">function literal 与 receiver</h2>
<p>Kotlin 允许为它提供一个接收者:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sum : Int.<span style="color:#f92672">(</span>other: Int<span style="color:#f92672">)</span> -&gt; Int
</code></pre></div><p>然后可以这样子调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">1.sum<span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>
</code></pre></div><h1 id="inline-function-2">inline function</h1>
<p>使用 <code>higher-order function</code> 都会加重运行时的负担: 每一个函数都是一个 <code>object</code>, 并且它会捕获一个 <code>closure</code>, 例如, 可访问的函数体的变量. 内存分配以及虚拟调用都会增加 runtime 的负载.</p>
<p>但多数情况下, 可以通过 <code>inline lambda expression</code>  来减少这种负载.</p>
<p>例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">lock<span style="color:#f92672">(</span>l<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> foo<span style="color:#f92672">()</span> <span style="color:#f92672">}</span>
</code></pre></div><h2 id="开启-inline">开启 <code>inline</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">inline fun &lt;T&gt; lock<span style="color:#f92672">(</span>lock: Lock, body: <span style="color:#f92672">()</span> -&gt; T<span style="color:#f92672">)</span>: T <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="noinline">noinline</h2>
<p>如果你只想指定的某些参数不进行 inline:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">inline fun foo<span style="color:#f92672">(</span>inlined: <span style="color:#f92672">()</span> -&gt; Unit, noinline notInlined: <span style="color:#f92672">()</span> -&gt; Unit<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    // ...
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="inline-properties">inline properties</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val foo: Foo
    inline get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> Foo<span style="color:#f92672">()</span>

var bar: Bar
    get<span style="color:#f92672">()</span> <span style="color:#f92672">=</span> ...
    inline set<span style="color:#f92672">(</span>v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>
</code></pre></div><h1 id="destructuring-declaration">destructuring declaration</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val <span style="color:#f92672">(</span>name, age<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> person 
</code></pre></div><p>以上就是析构的声明语法. 它由编译器自动生成以下代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val name <span style="color:#f92672">=</span> person.component1<span style="color:#f92672">()</span>
val age <span style="color:#f92672">=</span> person.component2<span style="color:#f92672">()</span>
</code></pre></div><p>也可以在 <code>for</code> 循环里使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>a, b<span style="color:#f92672">)</span> in collection<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>
</code></pre></div><h2 id="从一个函数中返回2个值">从一个函数中返回2个值</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">data class Result<span style="color:#f92672">(</span>val result: Int, val status: Status<span style="color:#f92672">)</span>
fun <span style="color:#66d9ef">function</span><span style="color:#f92672">(</span>...<span style="color:#f92672">)</span>: Result <span style="color:#f92672">{</span>
    // computations

    <span style="color:#66d9ef">return</span> Result<span style="color:#f92672">(</span>result, status<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>

// Now, to use this <span style="color:#66d9ef">function</span>:
val <span style="color:#f92672">(</span>result, status<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">(</span>...<span style="color:#f92672">)</span>
</code></pre></div><h2 id="在-map-中使用">在 map 中使用</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>key, value<span style="color:#f92672">)</span> in map<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   // <span style="color:#66d9ef">do</span> something with the key and the value
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="在-lambda-中使用">在 lambda 中使用</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">map.mapValues <span style="color:#f92672">{</span> entry -&gt; <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>entry.value<span style="color:#e6db74">}</span><span style="color:#e6db74">!&#34;</span> <span style="color:#f92672">}</span>
map.mapValues <span style="color:#f92672">{</span> <span style="color:#f92672">(</span>key, value<span style="color:#f92672">)</span> -&gt; <span style="color:#e6db74">&#34;</span>$value<span style="color:#e6db74">!&#34;</span> <span style="color:#f92672">}</span>
</code></pre></div><h1 id="collections">Collections</h1>
<p>Kotlin 是会区分 <code>mutable</code> 和 <code>immutable</code> 的集合的.</p>
<p>区分一个 mutable 的 <code>read-only</code> 视图, 和一个真正 <code>immutable</code> 的集合是非常重要的.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">val numbers: MutableList&lt;Int&gt; <span style="color:#f92672">=</span> mutableListOf<span style="color:#f92672">(</span>1, 2, 3<span style="color:#f92672">)</span>
val readOnlyView: List&lt;Int&gt; <span style="color:#f92672">=</span> numbers
println<span style="color:#f92672">(</span>numbers<span style="color:#f92672">)</span>        // prints <span style="color:#e6db74">&#34;[1, 2, 3]&#34;</span>
numbers.add<span style="color:#f92672">(</span>4<span style="color:#f92672">)</span>
println<span style="color:#f92672">(</span>readOnlyView<span style="color:#f92672">)</span>   // prints <span style="color:#e6db74">&#34;[1, 2, 3, 4]&#34;</span>
readOnlyView.clear<span style="color:#f92672">()</span>    // -&gt; does not compile

val strings <span style="color:#f92672">=</span> hashSetOf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">)</span>
assert<span style="color:#f92672">(</span>strings.size <span style="color:#f92672">==</span> 3<span style="color:#f92672">)</span>
</code></pre></div><h1 id="this-expression">this expression</h1>
<ul>
<li>在一个 class 成员内, <code>this</code> 引用的是当前class 的 object 对象</li>
<li>在一个 <code>expression function</code> 或 <code>function literal with receiver</code> 中, <code>this</code> 表示 <code>receiver</code> 参数(即 <code>.</code> 左边类型的对象)</li>
</ul>
<p>如果 <code>this</code> 没有限定符, 则它引用的是 <code>内部最近的作用域</code>. 为了使 <code>this</code> 引用其他作用域的, 可以使用 <code>label qualifiers</code></p>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">class A <span style="color:#f92672">{</span> // implicit label @A
    inner class B <span style="color:#f92672">{</span> // implicit label @B
        fun Int.foo<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> // implicit label @foo
            val a <span style="color:#f92672">=</span> this@A // A<span style="color:#e6db74">&#39;s this
</span><span style="color:#e6db74">            val b = this@B // B&#39;</span>s this

            val c <span style="color:#f92672">=</span> this // foo<span style="color:#f92672">()</span><span style="color:#e6db74">&#39;s receiver, an Int
</span><span style="color:#e6db74">            val c1 = this@foo // foo()&#39;</span>s receiver, an Int

            val funLit <span style="color:#f92672">=</span> lambda@ fun String.<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                val d <span style="color:#f92672">=</span> this // funLit<span style="color:#e6db74">&#39;s receiver
</span><span style="color:#e6db74">            }
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">            val funLit2 = { s: String -&gt;
</span><span style="color:#e6db74">                // foo()&#39;</span>s receiver, since enclosing lambda expression
                // doesn<span style="color:#960050;background-color:#1e0010">&#39;</span>t have any receiver
                val d1 <span style="color:#f92672">=</span> this
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="equality-相等">equality 相等</h1>
<ul>
<li><code>equals()</code> : structural equality (a == b, 它会被翻译为 <code>a?.equals(b) ?: (b === null)</code>)</li>
<li>引用相等: 使用 <code>===</code> 或 <code>!==</code> 来判断</li>
</ul>
<h1 id="操作符重载">操作符重载</h1>
<p>参考 <a href="http://kotlinlang.org/docs/reference/operator-overloading.html">doc</a></p>
<h1 id="annotation">annotation</h1>
<p>声明注解</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">annotation class Fancy

@Target<span style="color:#f92672">(</span>AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,
        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION<span style="color:#f92672">)</span>
@Retention<span style="color:#f92672">(</span>AnnotationRetention.SOURCE<span style="color:#f92672">)</span>
@MustBeDocumented
annotation class Fancy
</code></pre></div><p>使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">@Fancy class Foo <span style="color:#f92672">{</span>
    @Fancy fun baz<span style="color:#f92672">(</span>@Fancy foo: Int<span style="color:#f92672">)</span>: Int <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>@Fancy 1<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h1 id="type-aliases-类型别名">Type aliases 类型别名</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">typealias NodeSet <span style="color:#f92672">=</span> Set&lt;Network.Node&gt;

typealias FileTable&lt;K&gt; <span style="color:#f92672">=</span> MutableMap&lt;K, MutableList&lt;File&gt;&gt;
</code></pre></div>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-03-01</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/kotlin/">kotlin</a>
          
          <a href="/tags/java/">java</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2018/03/12/rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Rust 学习笔记</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2018/02/28/%E6%88%91%E7%9A%84java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
            <span class="next-text nav-default">我的Java开发环境</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2018-03-01 11:25:40 \x2b0000 UTC',
    title: 'Kotlin lang 学习笔记',
    link: decodeURI(location.href),
    desc: '基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>









<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278300546'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278300546%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>
