<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Kotlin lang 学习笔记 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置 源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等 特别地," />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.54.0" />


<link rel="canonical" href="https://emacsist.github.io/2018/03/01/kotlin-lang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="Kotlin lang 学习笔记" />
<meta property="og:description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置 源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等 特别地," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2018/03/01/kotlin-lang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2018-03-01T11:25:40&#43;00:00"/>
<meta property="article:modified_time" content="2018-03-01T11:25:40&#43;00:00"/>

<meta itemprop="name" content="Kotlin lang 学习笔记">
<meta itemprop="description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置 源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等 特别地,">


<meta itemprop="datePublished" content="2018-03-01T11:25:40&#43;00:00" />
<meta itemprop="dateModified" content="2018-03-01T11:25:40&#43;00:00" />
<meta itemprop="wordCount" content="8798">



<meta itemprop="keywords" content="kotlin,java," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin lang 学习笔记"/>
<meta name="twitter:description" content="基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置 源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等 特别地,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Kotlin lang 学习笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-03-01 </span>
        
        <span class="more-meta"> 8798 words </span>
        <span class="more-meta"> 18 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#基本语法">基本语法</a>
<ul>
<li><a href="#定义-package">定义 package</a>
<ul>
<li><a href="#默认导入的包">默认导入的包</a></li>
</ul></li>
<li><a href="#import-导入包">import, 导入包</a></li>
<li><a href="#定义函数">定义函数</a>
<ul>
<li><a href="#语法">语法</a>
<ul>
<li><a href="#参数定义">参数定义</a></li>
<li><a href="#默认参数">默认参数</a>
<ul>
<li><a href="#override-method">override method</a></li>
</ul></li>
<li><a href="#命名参数">命名参数</a>
<ul>
<li><a href="#命名参数与位置参数混合调用时">命名参数与位置参数混合调用时</a></li>
</ul></li>
<li><a href="#可变参数">可变参数</a></li>
<li><a href="#unit-返回类型">Unit 返回类型</a></li>
<li><a href="#单一表达式-函数-single-expression-function">单一表达式 函数 (Single-Expression function)</a></li>
<li><a href="#infix-符号">infix 符号</a></li>
<li><a href="#函数作用域">函数作用域</a>
<ul>
<li><a href="#local-function">local function</a></li>
<li><a href="#member-function">member function</a></li>
<li><a href="#generic-function">generic function</a></li>
<li><a href="#inline-function">inline function</a></li>
<li><a href="#extension-function">extension function</a></li>
<li><a href="#higher-order-function-和-lambda">higher-order function 和 lambda</a></li>
<li><a href="#tail-recursive-function">tail recursive function</a></li>
</ul></li>
</ul></li>
<li><a href="#例子">例子</a></li>
</ul></li>
<li><a href="#定义变量">定义变量</a>
<ul>
<li><a href="#定义属性">定义属性</a>
<ul>
<li><a href="#compile-time-constant">compile time constant</a></li>
<li><a href="#late-initialized-属性和变量-延迟初始化">late initialized 属性和变量(延迟初始化)</a></li>
</ul></li>
</ul></li>
<li><a href="#注释">注释</a></li>
<li><a href="#使用字符串模板">使用字符串模板</a>
<ul>
<li><a href="#例子-1">例子</a></li>
</ul></li>
<li><a href="#null-安全的">Null 安全的</a>
<ul>
<li><a href="#调用">调用</a>
<ul>
<li><a href="#检查-null-条件">检查 null 条件</a></li>
<li><a href="#安全调用">安全调用</a></li>
</ul></li>
<li><a href="#elvis-操作符">elvis 操作符</a></li>
<li><a href="#操作符">!! 操作符</a></li>
<li><a href="#安全转换">安全转换</a></li>
<li><a href="#nullable-类型的集合">nullable 类型的集合</a></li>
</ul></li>
<li><a href="#使用类型检查和自动转换">使用类型检查和自动转换</a></li>
<li><a href="#使用-for-循环">使用 for 循环</a></li>
<li><a href="#使用-while-循环">使用 while 循环</a></li>
<li><a href="#when-表达式">when 表达式</a></li>
<li><a href="#使用-range">使用 range</a></li>
<li><a href="#使用集合">使用集合</a></li>
<li><a href="#创建基本类和它们的实例">创建基本类和它们的实例</a></li>
</ul></li>
<li><a href="#源码组织">源码组织</a>
<ul>
<li><a href="#目录结构">目录结构</a></li>
<li><a href="#源码文件名">源码文件名</a></li>
<li><a href="#源文件的组织">源文件的组织</a></li>
<li><a href="#类层次">类层次</a></li>
<li><a href="#接口实现层">接口实现层</a></li>
<li><a href="#重载层">重载层</a></li>
</ul></li>
<li><a href="#命名规则">命名规则</a>
<ul>
<li><a href="#函数名">函数名</a>
<ul>
<li><a href="#测试方法的命名">测试方法的命名</a></li>
</ul></li>
<li><a href="#属性名">属性名</a></li>
</ul></li>
<li><a href="#修饰符的顺序">修饰符的顺序</a></li>
<li><a href="#lable">Lable</a>
<ul>
<li><a href="#return-中使用-label">return 中使用 label</a></li>
</ul></li>
<li><a href="#class-和-继承">class 和 继承</a>
<ul>
<li><a href="#class">class</a>
<ul>
<li><a href="#主构造器">主构造器</a></li>
<li><a href="#次构造器">次构造器</a></li>
<li><a href="#初始化块">初始化块</a></li>
<li><a href="#创建实例">创建实例</a></li>
<li><a href="#class-成员">class 成员</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#重写方法">重写方法</a></li>
<li><a href="#重写属性">重写属性</a></li>
<li><a href="#子类初始化顺序">子类初始化顺序</a></li>
<li><a href="#调用父类的实现">调用父类的实现</a>
<ul>
<li><a href="#重写规则">重写规则</a></li>
</ul></li>
<li><a href="#abstract-class">abstract class</a></li>
<li><a href="#companion-objects">Companion Objects</a></li>
<li><a href="#object-declaration">Object Declaration</a></li>
<li><a href="#companion-object">companion object</a></li>
</ul></li>
</ul></li>
<li><a href="#属性和字段">属性和字段</a>
<ul>
<li><a href="#声明属性">声明属性</a></li>
<li><a href="#setter-和-getter">setter 和 getter</a></li>
</ul></li>
<li><a href="#接口-interface">接口 interface</a>
<ul>
<li><a href="#接口中的属性">接口中的属性</a></li>
<li><a href="#重写时的冲突解决">重写时的冲突解决</a></li>
</ul></li>
<li><a href="#访问修饰符">访问修饰符</a>
<ul>
<li><a href="#module">module</a></li>
</ul></li>
<li><a href="#extension-扩展">extension 扩展</a>
<ul>
<li><a href="#extension-function-1">extension function</a></li>
<li><a href="#extension-是静态解析的">extension 是静态解析的</a></li>
<li><a href="#nullable-接收者">nullable 接收者</a></li>
<li><a href="#extension-属性">extension 属性</a></li>
<li><a href="#companion-object-extensions">Companion Object Extensions</a></li>
<li><a href="#定义-extension-作为成员">定义 extension 作为成员</a></li>
</ul></li>
<li><a href="#data-classes">Data classes</a>
<ul>
<li><a href="#在-body-里声明属性">在 body 里声明属性</a></li>
<li><a href="#copying">copying</a></li>
</ul></li>
<li><a href="#sealed-classes">Sealed Classes</a></li>
<li><a href="#generic-泛型">generic 泛型</a></li>
<li><a href="#嵌套类和内部类">嵌套类和内部类</a></li>
<li><a href="#枚举类">枚举类</a></li>
<li><a href="#object-expression-和-declaration">object expression 和 declaration</a></li>
<li><a href="#delegation-委托">Delegation 委托</a></li>
<li><a href="#delegated-properties">Delegated Properties</a>
<ul>
<li><a href="#标准的-delegates">标准的 delegates</a></li>
<li><a href="#storing-properties-in-a-map">Storing Properties in a Map</a></li>
</ul></li>
<li><a href="#higher-order-function-和-lambda-1">higher-order function 和 lambda</a>
<ul>
<li><a href="#it-隐式的单一的参数名字"><code>it</code> : 隐式的单一的参数名字</a></li>
<li><a href="#忽略参数-1-1-版本开始"><code>_</code> : 忽略参数:(1.1 版本开始)</a></li>
<li><a href="#inline-function-1">inline function</a></li>
<li><a href="#lambda-expression-和-匿名函数">lambda expression 和 匿名函数</a>
<ul>
<li><a href="#匿名函数">匿名函数</a></li>
</ul></li>
<li><a href="#closures">closures</a></li>
<li><a href="#function-literal-与-receiver">function literal 与 receiver</a></li>
</ul></li>
<li><a href="#inline-function-2">inline function</a>
<ul>
<li><a href="#开启-inline">开启 <code>inline</code></a></li>
<li><a href="#noinline">noinline</a></li>
<li><a href="#inline-properties">inline properties</a></li>
</ul></li>
<li><a href="#destructuring-declaration">destructuring declaration</a>
<ul>
<li><a href="#从一个函数中返回2个值">从一个函数中返回2个值</a></li>
<li><a href="#在-map-中使用">在 map 中使用</a></li>
<li><a href="#在-lambda-中使用">在 lambda 中使用</a></li>
</ul></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#this-expression">this expression</a></li>
<li><a href="#equality-相等">equality 相等</a></li>
<li><a href="#操作符重载">操作符重载</a></li>
<li><a href="#annotation">annotation</a></li>
<li><a href="#type-aliases-类型别名">Type aliases 类型别名</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="基本语法">基本语法</h1>

<h2 id="定义-package">定义 package</h2>

<blockquote>
<p>不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置</p>
</blockquote>

<p>源文件中的所有内容, 都是通过包声明来包含的. 即: <code>名包.方法名</code> 等</p>

<blockquote>
<p>特别地, 如果没指定包, 则该文件属于 <code>default</code> 包.(没有显式的名称的包)</p>
</blockquote>

<h3 id="默认导入的包">默认导入的包</h3>

<p>所有 kotlin 文件默认情况下, 都会导入以下包</p>

<pre><code class="language-bash">kotlin.*
kotlin.annotation.*
kotlin.collections.*
kotlin.comparisons.* (since 1.1)
kotlin.io.*
kotlin.ranges.*
kotlin.sequences.*
kotlin.text.*
</code></pre>

<p>根据不同的目标平台, 还会导入一些额外的包:</p>

<ul>
<li>JVM 平台</li>
</ul>

<pre><code class="language-bash">java.lang.*
kotlin.jvm.*
</code></pre>

<ul>
<li>JS 平台</li>
</ul>

<pre><code class="language-bash">kotlin.js.*
</code></pre>

<h2 id="import-导入包">import, 导入包</h2>

<blockquote>
<p>import 指令不必限制于 classes 的, 你可以用它来导入其他的声明:</p>
</blockquote>

<ul>
<li>顶层的 方法和属性</li>
<li>声明在对象声明里的 方法和属性</li>
<li>枚举常量</li>
</ul>

<blockquote>
<p>不同于Java, Kotlin 没有单独的 <code>import static</code> 语法. 所有的导入, 都是通过 <code>import</code> 来声明的</p>
</blockquote>

<p>例子:</p>

<pre><code class="language-bash">import foo.Bar

import foo.*

import bar.Bar as bBar
</code></pre>

<h2 id="定义函数">定义函数</h2>

<h3 id="语法">语法</h3>

<p>函数是通过 <code>fun</code> 关键字来定义的</p>

<h4 id="参数定义">参数定义</h4>

<p>它是使用 <code>Pascal</code> 风格来定义的</p>

<pre><code class="language-bash">name: type
</code></pre>

<p>即, <code>名称: 类型</code></p>

<h4 id="默认参数">默认参数</h4>

<p>即在 <code>type</code> 后使用 <code>= defaultValue</code> 来定义. 如:</p>

<pre><code class="language-bash">fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) {
...
}
</code></pre>

<h5 id="override-method">override method</h5>

<p><code>override method</code> 总是与 <code>base method</code> 使用相同的默认值的!(注意, <code>总是</code>, always)~</p>

<p>当 <code>override method</code> 时, 要注意在方法签名里, 不能带有默认值! 否则会报如下错:</p>

<pre><code class="language-bash">An overriding function is not allowed to specify default values for its parameters
</code></pre>

<blockquote>
<p>如果一个方法中, 前面带有默认参数, 后面参数没有时, 这时如果想利用默认参数值的话, 则只能通过命名参数的方式来调用方法:</p>
</blockquote>

<pre><code class="language-bash">fun foo(bar: Int = 0, baz: Int) { /* ... */ }

foo(baz = 1) // The default value bar = 0 is used
</code></pre>

<p>但, 如果最后一个参数是 <code>lambda</code> 时, 则允许只直接传递最后一个没有默认值的 <code>lambda</code> 参数:</p>

<pre><code class="language-bash">fun foo(bar: Int = 0, baz: Int = 1, qux: () -&gt; Unit) { /* ... */ }

foo(1) { println(&quot;hello&quot;) } // Uses the default value baz = 1 
foo { println(&quot;hello&quot;) }    // Uses both default values bar = 0 and baz = 1
</code></pre>

<h4 id="命名参数">命名参数</h4>

<p>当调用方法时, 允许通过命名参数的方式来调用.</p>

<h5 id="命名参数与位置参数混合调用时">命名参数与位置参数混合调用时</h5>

<p>规则为: 所有的位置参数必须在第一个命名参数的前面.即:</p>

<p>允许:</p>

<pre><code class="language-bash">f(1, y = 2)
</code></pre>

<p>但不允许:</p>

<pre><code class="language-bash">f(x = 1, 2)
</code></pre>

<h4 id="可变参数">可变参数</h4>

<p><code>vararg</code> 来声明</p>

<pre><code class="language-bash">fun foo(vararg strings: String) { /* ... */ }

foo(strings = *arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
</code></pre>

<h4 id="unit-返回类型">Unit 返回类型</h4>

<p>如果一个方法没有返回值, 则它的返回类型为 <code>Unit</code>, 它是一种仅有唯一值 <code>Unit</code> 的类型.(可以忽略显式写法)</p>

<pre><code class="language-bash">fun printHello(name: String?): Unit {
    if (name != null)
        println(&quot;Hello ${name}&quot;)
    else
        println(&quot;Hi there!&quot;)
    // `return Unit` or `return` is optional
}
</code></pre>

<p>或</p>

<pre><code class="language-bash">fun printHello(name: String?) {
    ...
}
</code></pre>

<h4 id="单一表达式-函数-single-expression-function">单一表达式 函数 (Single-Expression function)</h4>

<pre><code class="language-bash">fun double(x: Int): Int = x * 2
</code></pre>

<h4 id="infix-符号">infix 符号</h4>

<p>通过 <code>infix</code> 关键字的 <code>function</code> 也被称为使用 <code>infix</code> 符号记法(即, 允许忽略点和括号来调用). 它必须满足以下条件:</p>

<ul>
<li>它们必须是成员函数(member function)或扩展函数(extension function)</li>
<li>它们必须有一个参数</li>
<li>参数一定不能为可变参数, 也不能有默认值</li>
</ul>

<p>如</p>

<pre><code class="language-bash">infix fun Int.shl(x: Int): Int {
    // ...
}

// calling the function using the infix notation
1 shl 2

// is the same as
1.shl(2)
</code></pre>

<blockquote>
<p>注意, infix 函数 比 算术操作符, 类型转换换以入 rangeTo 操作符的优先级更低!</p>
</blockquote>

<p>注意, infix 函数总是要求指定 <code>receiver</code> 和 <code>parameter</code> 的!</p>

<ul>
<li>当你在一个方法里调用 infix 函数时, 你需要显式使用 <code>this</code> 作为 <code>receiver</code>, 其他的方法允许忽略它, 但 infix 方法不能忽略 <code>this</code>.</li>
</ul>

<p>这种要求用来确保解释时没有歧义!</p>

<h4 id="函数作用域">函数作用域</h4>

<h5 id="local-function">local function</h5>

<p>本地函数. 即一个函数在另一个函数里面.</p>

<pre><code class="language-bash">fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
</code></pre>

<p><code>local function</code> 可以访问外部函数的 <code>local variable</code>. 如:</p>

<pre><code class="language-bash">fun dfs(graph: Graph) {
    val visited = HashSet&lt;Vertex&gt;()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
</code></pre>

<h5 id="member-function">member function</h5>

<pre><code class="language-bash">class Sample() {
    fun foo() { print(&quot;Foo&quot;) }
}
</code></pre>

<p>调用</p>

<pre><code class="language-bash">Sample().foo() // creates instance of class Sample and calls foo
</code></pre>

<h5 id="generic-function">generic function</h5>

<pre><code class="language-bash">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
    // ...
}
</code></pre>

<h5 id="inline-function">inline function</h5>

<h5 id="extension-function">extension function</h5>

<h5 id="higher-order-function-和-lambda">higher-order function 和 lambda</h5>

<h5 id="tail-recursive-function">tail recursive function</h5>

<h3 id="例子">例子</h3>

<pre><code class="language-bash">fun sum(a: Int, b: Int): Int {
    return a + b
}
</code></pre>

<pre><code class="language-bash">fun sum(a: Int, b: Int) = a + b
</code></pre>

<pre><code class="language-bash">fun printSum(a: Int, b: Int): Unit {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
</code></pre>

<pre><code class="language-bash">fun printSum(a: Int, b: Int) {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
</code></pre>

<h2 id="定义变量">定义变量</h2>

<p>一次性声明 local variable(read only):</p>

<pre><code class="language-bash">val a: Int = 1  // immediate assignment
val b = 2   // `Int` type is inferred
val c: Int  // Type required when no initializer is provided
c = 3       // deferred assignment
</code></pre>

<p>可变变量</p>

<pre><code class="language-bash">var x = 5 // `Int` type is inferred
x += 1
</code></pre>

<p>顶层变量</p>

<pre><code class="language-bash">val PI = 3.14
var x = 0

fun incrementX() { 
    x += 1 
}
</code></pre>

<h3 id="定义属性">定义属性</h3>

<p>在 kotlin 中, classes 可以有属性. 它们可通过使用 <code>var</code> 关键字来声明为可变的(mutable), 或 通过 <code>val</code> 关键字来声明为不可变的.</p>

<p>完整的语法</p>

<pre><code class="language-bash">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]
    [&lt;getter&gt;]
    [&lt;setter&gt;]
</code></pre>

<p>当声明为 <code>var</code> (可变) 的属性时, 它默认会有 <code>getter</code> 和 <code>setter</code> 方法.</p>

<p>当声明为 <code>val</code> (不可变) 的属性时, 它只有 <code>getter</code> 而没有 <code>setter</code> 方法</p>

<p>自定义访问方法: (1.1及之后版本, 可以忽略 属性的类型, 由 getter 方法来推断)</p>

<pre><code class="language-bash">val isEmpty: Boolean
    get() = this.size == 0
</code></pre>

<p>自定义setter 方法:</p>

<pre><code class="language-bash">var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }
</code></pre>

<p>如果你想修改 <code>getter 和 setter</code> 的访问权限或想注入它, 但又不想修改默认实现, 则可以这样子:</p>

<pre><code class="language-bash">var setterVisibility: String = &quot;abc&quot;
    private set // the setter is private and has the default implementation

var setterWithAnnotation: Any? = null
    @Inject set // annotate the setter with Inject
</code></pre>

<h4 id="compile-time-constant">compile time constant</h4>

<p>如果属性的值可以在编译时就可以确定的话, 则它可以标记为编译时常量. 通过 <code>const</code> 修饰符来设置.这样子的属性, 要完全满足以下要求:</p>

<ul>
<li>顶层或者是一个 object 的成员.</li>
<li>初始值的类型为 <code>String</code> 或为 基本数据类型 (primitive type)</li>
<li>没有自定义的 <code>setter</code> 方法</li>
</ul>

<p>例如</p>

<pre><code class="language-bash">const val SUBSYSTEM_DEPRECATED: String = &quot;This subsystem is deprecated&quot;
</code></pre>

<h4 id="late-initialized-属性和变量-延迟初始化">late initialized 属性和变量(延迟初始化)</h4>

<p>通过 <code>lateinit</code> 修饰符来修饰.</p>

<p>条件为
- var 声明的变量
- 必须是 non null
- 没有自定义的 getter 和 setter
- 1.2及之后版本, 则为 顶层的属性 以及 local variable</p>

<pre><code class="language-bash">public class MyTest {
    lateinit var subject: TestSubject

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // dereference directly
    }
}
</code></pre>

<p>检测 <code>lateinit</code> 修改的变量是否初始化(1.2版本开始)</p>

<pre><code class="language-bash">if (foo::bar.isInitialized) {
    println(foo.bar)
}
</code></pre>

<h2 id="注释">注释</h2>

<p>行注释</p>

<pre><code class="language-bash">//
</code></pre>

<p>块注释</p>

<pre><code class="language-bash">/*
*/
</code></pre>

<p>不同于Java, 在 kotlin 中, 块注释可以嵌套的~</p>

<h2 id="使用字符串模板">使用字符串模板</h2>

<p>字符串可以包含 <code>template expression</code>, 它是以一个 <code>$</code> 开头以及一个简单的变量或表达式组成的.</p>

<p>它在在 <code>raw string</code> 中也支持.</p>

<pre><code class="language-bash">val price = &quot;&quot;&quot;
${'$'}9.99
&quot;&quot;&quot;
</code></pre>

<h3 id="例子-1">例子</h3>

<pre><code class="language-bash">var a = 1
// simple name in template:
val s1 = &quot;a is $a&quot; 

a = 2
// arbitrary expression in template:
val s2 = &quot;${s1.replace(&quot;is&quot;, &quot;was&quot;)}, but now is $a&quot;
</code></pre>

<h2 id="null-安全的">Null 安全的</h2>

<p>Kotlin 的类型系统被设计于消除 null 引用的危险性的. 它可以区分是否一个引用能否为 <code>null</code> 的:</p>

<p>允许为 null:</p>

<pre><code class="language-bash">var b: String? = &quot;abc&quot;
b = null // ok
</code></pre>

<p>不允许为 null:</p>

<pre><code class="language-bash">var a: String = &quot;abc&quot;
a = null // compilation error
</code></pre>

<h3 id="调用">调用</h3>

<h4 id="检查-null-条件">检查 null 条件</h4>

<pre><code class="language-bash">if (b != null) {
    //do something
}
</code></pre>

<h4 id="安全调用">安全调用</h4>

<pre><code class="language-bash">b?.length
</code></pre>

<p>这种也可用于调用链中~</p>

<h3 id="elvis-操作符">elvis 操作符</h3>

<p><code>?:</code></p>

<pre><code class="language-bash">val l = b?.length ?: -1

等于同下面

val l: Int = if (b != null) b.length else -1
</code></pre>

<h3 id="操作符">!! 操作符</h3>

<p>如果引用为 null , 它会自动抛出 NPE 异常.</p>

<pre><code class="language-bash">val l = b!!.length
</code></pre>

<h3 id="安全转换">安全转换</h3>

<pre><code class="language-bash">val aInt: Int? = a as? Int
</code></pre>

<p>当目标对象不能正确转换时, 它会返回 <code>null</code></p>

<h3 id="nullable-类型的集合">nullable 类型的集合</h3>

<pre><code class="language-bash">val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)
val intList: List&lt;Int&gt; = nullableList.filterNotNull()
</code></pre>

<h2 id="使用类型检查和自动转换">使用类型检查和自动转换</h2>

<p><code>is</code> 操作符检查一个表达式是否是一种类型的实例. 如果一个 immutable 的 local variable 或 属性 是已经检测为特定类型的话, 则不需要显式转换它. 例如:</p>

<pre><code class="language-bash">fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` is automatically cast to `String` in this branch
        return obj.length
    }

    // `obj` is still of type `Any` outside of the type-checked branch
    return null
}
</code></pre>

<h2 id="使用-for-循环">使用 for 循环</h2>

<pre><code class="language-bash">for (item in collection) print(item)

for (item: Int in ints) {
    // ...
}


for ((index, value) in array.withIndex()) {
    println(&quot;the element at $index is $value&quot;)
}
</code></pre>

<h2 id="使用-while-循环">使用 while 循环</h2>

<pre><code class="language-bash">while (x &gt; 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y is visible here!
</code></pre>

<h2 id="when-表达式">when 表达式</h2>

<p>用于替换C系的 <code>switch</code></p>

<pre><code class="language-bash">when (x) {
    1 -&gt; print(&quot;x == 1&quot;)
    2 -&gt; print(&quot;x == 2&quot;)
    else -&gt; { // Note the block
        print(&quot;x is neither 1 nor 2&quot;)
    }
}

或

when (x) {
    0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;)
    else -&gt; print(&quot;otherwise&quot;)
}

或

when (x) {
    in 1..10 -&gt; print(&quot;x is in the range&quot;)
    in validNumbers -&gt; print(&quot;x is valid&quot;)
    !in 10..20 -&gt; print(&quot;x is outside the range&quot;)
    else -&gt; print(&quot;none of the above&quot;)
}
</code></pre>

<h2 id="使用-range">使用 range</h2>

<p>范围操作符: <code>..</code></p>

<p>例如:</p>

<pre><code class="language-bash">if (i in 1..10) { // equivalent of 1 &lt;= i &amp;&amp; i &lt;= 10
    println(i)
}
</code></pre>

<p>反序:</p>

<pre><code class="language-bash">for (i in 4 downTo 1) print(i) // prints &quot;4321&quot;
</code></pre>

<p>步进</p>

<pre><code class="language-bash">for (i in 1..4 step 2) print(i) // prints &quot;13&quot;
</code></pre>

<p>until:</p>

<pre><code class="language-bash">for (i in 1 until 10) { // i in [1, 10), 10 is excluded
     println(i)
}
</code></pre>

<h2 id="使用集合">使用集合</h2>

<pre><code class="language-bash">for (item in items) {
    println(item)
}

when {
    &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;)
    &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;)
}

或

fruits
.filter { it.startsWith(&quot;a&quot;) }
.sortedBy { it }
.map { it.toUpperCase() }
.forEach { println(it) }
</code></pre>

<h2 id="创建基本类和它们的实例">创建基本类和它们的实例</h2>

<pre><code class="language-bash">val rectangle = Rectangle(5.0, 2.0) //no 'new' keyword required
val triangle = Triangle(3.0, 4.0, 5.0)
</code></pre>

<h1 id="源码组织">源码组织</h1>

<h2 id="目录结构">目录结构</h2>

<p>在一个混合语言的项目里, Kotlin 的源码应该与 Java 的源码的根目录相同, 并且跟随相同的目录结构(每个文件应该保存到 <code>package</code> 语句中的相应的目录)</p>

<p>在一个纯 Kotlin 的项目里, 建议目录的结构跟随在一个忽略了公共的根 package 下面(例如, 如果项目里所有的代码都是在 <code>org.example.kotlin</code> 包及子包下面, 则这些文件应该直接放在源码的根目录下, 并且文件在 <code>org.example.kotlin.foo.bar</code> 的则应该在源码的子目录 <code>foo/bar</code> 下面)</p>

<h2 id="源码文件名">源码文件名</h2>

<p>如果一个 kotlin 文件包含一个单独的 class , 则文件名应该与 class 的名字相同, 并带有 <code>.kt</code> 后缀.</p>

<p>如果包含多个 class, 或仅有顶层的声明的话, 则相应选择一个适当的描述的文件名. 使用 <code>CamelHumps</code> (驼峰命名), 例如 <code>ProcessDeclarations.kt</code></p>

<p>文件名应该选择适当描述文件内容的名称的. 因此, 应该避免使用无意义的单词, 例如 <code>Util</code> 这种文件名.</p>

<h2 id="源文件的组织">源文件的组织</h2>

<p>我们鼓励将多个声明(class, 层顶的函数或属性)放在同一个源文件里, 只要这些声明相关性是比较话的话, 并且文件的大小也比较适合(不超出几百行代码)</p>

<p>特别地, 当为某个 class 定义 <code>extension</code> 函数时, 则建议将它们放在同一个文件中.</p>

<h2 id="类层次">类层次</h2>

<p>通常, class 的内容是按以下顺序来保存的:
- 属性声明和初始化块
- 构造器
- 方法声明
- 引用的对象</p>

<p>不要将方法声明按字母或可见性来排序!</p>

<p>也不要分隔普通的方法和 extension 方法</p>

<p>相应的, 应该将相关性的放在一起, 以便人从上到下阅读源码时可以根据逻辑顺序来阅读.</p>

<p>将嵌套的类放在紧接着使用这些类的下面. 如果这些嵌套类是用于外部调用并且没有在内部使用的, 则放在类的最后.</p>

<h2 id="接口实现层">接口实现层</h2>

<p>如果实现一个接口的话, 则将实现的成员按接口中的相同顺序来保存.</p>

<p>如果有需要的话, 则为这些实现插入额外的私有方法.</p>

<h2 id="重载层">重载层</h2>

<p>总是将重载的方法放在一起!</p>

<h1 id="命名规则">命名规则</h1>

<p>跟随Java的命名规则. 特别地:</p>

<p>名包总是小写的, 并且不要使用下划线(<code>org.example.myproject</code>). 通常不建议使用多单词的名字, 但如果你确实需要, 你也可以简单地将它们拼接在一起, 或者使用驼峰式( <code>com.example.myProject</code>)</p>

<h2 id="函数名">函数名</h2>

<p>函数名, 属性名, 以及 local variable 应该以小写字母开头, 并且使用驼峰的形式(没有下划线).</p>

<p>例外:</p>

<p>工厂方法(用于创建类实例)的, 方法名可以跟类名一样(大写字母开头的驼峰)</p>

<h3 id="测试方法的命名">测试方法的命名</h3>

<blockquote>
<p>仅在测试方法中</p>
</blockquote>

<p>它可以接受用反单引号里带有空格的方法名.(注意: 这种方法暂不被 Android Runtime 支持)</p>

<p>带有下划线的命名也允许在测试代码中:</p>

<pre><code class="language-bash">class MyTestCase {
     @Test fun `ensure everything works`() {
     }

     @Test fun ensureEverythingWorks_onAndroid() {
     }
}
</code></pre>

<h2 id="属性名">属性名</h2>

<p>常量的命名, 应该以大写和以下划线分隔的名字:</p>

<pre><code class="language-bash">const val MAX_COUNT = 8
val USER_NAME_FIELD = &quot;UserName&quot;
</code></pre>

<p>其他的使用普通的驼峰命名(小写开头)</p>

<h1 id="修饰符的顺序">修饰符的顺序</h1>

<pre><code class="language-bash">public / protected / private / internal
expect / actual
final / open / abstract / sealed / const
external
override
lateinit
tailrec
vararg
suspend
inner
enum / annotation
companion
inline
infix
operator
data
</code></pre>

<h1 id="lable">Lable</h1>

<p>在 Kotlin 中任意的语句都可以标记有一个 <code>label</code> .</p>

<p>语法:</p>

<pre><code class="language-bash">labelName@
</code></pre>

<p>即名称最后加个 <code>@</code></p>

<p>使用 label 时, 则将 <code>@</code> 放在名称开头即可:</p>

<pre><code class="language-bash">@labelName
</code></pre>

<h2 id="return-中使用-label">return 中使用 label</h2>

<pre><code class="language-bash">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop
        print(it)
    }
    print(&quot; done with explicit label&quot;)
}
</code></pre>

<p><code>return @a 1</code></p>

<p>表示在label <code>@a</code> 中进行 <code>return 1</code></p>

<h1 id="class-和-继承">class 和 继承</h1>

<h2 id="class">class</h2>

<p>通过关键字 <code>class</code> 来定义</p>

<p>组成:</p>

<ul>
<li>class name</li>
<li>class header(指定它的参数, 主构造器, primary constructor 等)</li>
<li>class body(用大括号包着)</li>
</ul>

<p>header 和 body 都是可选的. 如果没有 body 的话:</p>

<pre><code class="language-bash">class Empty
</code></pre>

<p>即可.</p>

<h3 id="主构造器">主构造器</h3>

<pre><code class="language-bash">class Person constructor(firstName: String) {
}
</code></pre>

<p>如果主构造器没有任何的 annotation 或 可见性修饰符, 则可以省略 <code>constructor</code> 关键字:</p>

<pre><code class="language-bash">class Person(firstName: String) {
}
</code></pre>

<p>注意, 主构造器不能有任何代码!初始化代码可以被放在 <code>initializer blocks</code> (初始化块中). 它是以 <code>init</code> 关键字为开头的代码块.它的初始化顺序, 就是代码出现的顺序. 例如:</p>

<pre><code class="language-bash">class InitOrderDemo(name: String) {
    val firstProperty = &quot;First property: $name&quot;.also(::println)

    init {
        println(&quot;First initializer block that prints ${name}&quot;)
    }

    val secondProperty = &quot;Second property: ${name.length}&quot;.also(::println)

    init {
        println(&quot;Second initializer block that prints ${name.length}&quot;)
    }
}
</code></pre>

<p>如果一个非抽象的 class 没有声明任何的构造器(主或次), 它会自动生成一个没有参数的 <code>public</code> 的主构造器. 如果你需要修改这访问权限的话, 则要显式地这样子:</p>

<pre><code class="language-bash">class DontCreateMe private constructor () {
}
</code></pre>

<blockquote>
<p>在JVM平台上, 如果主构造器的所有参数都有默认值的话, 编译器会生成一个额外的无参构造器, 它将使用这些默认值.这使 Kotlin 使用一些类似 Jackson 或 JPA 这些库更方便, 它们需要通过无参构造器来创建实例.</p>
</blockquote>

<h3 id="次构造器">次构造器</h3>

<blockquote>
<p>可以有多个</p>
</blockquote>

<pre><code class="language-bash">class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
</code></pre>

<p>如果一个 class 有一个 主构造器, 则每一个次构造器都需要委派给(delegate to)主构造器: 通过 <code>this</code> 关键字来做:</p>

<pre><code class="language-bash">class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
</code></pre>

<h3 id="初始化块">初始化块</h3>

<p>注意, 初始化块相当于主构造器的一部分. 委派给主构造器会相当于在次构造器的第一条语句中执行.</p>

<p>因此, 所有在初始化块的代码, 都会在次构器代码之前执行! 即使 class 没有主构造器也一样!</p>

<h3 id="创建实例">创建实例</h3>

<pre><code class="language-bash">val invoice = Invoice()

val customer = Customer(&quot;Joe Smith&quot;)
</code></pre>

<p>注意, 不需要 <code>new</code> 关键字.</p>

<h3 id="class-成员">class 成员</h3>

<p>它可以包含</p>

<ul>
<li>构造器来初始化块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套以及内部类</li>
<li>对象声明</li>
</ul>

<h3 id="继承">继承</h3>

<p>所有 Kotlin 类都有一个公共的超类 <code>Any</code> .</p>

<p>注意, <code>Any</code> 不是 <code>java.lang.Object</code> . 特别地, 它没有任何的成员, 除了 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> 之外.</p>

<p>显式指定继承的类, 可以在 class header 之后加个冒号. 如</p>

<pre><code class="language-bash">class Derived(p: Int) : Base(p)
</code></pre>

<p>注意, 默认情况下, 所有的 Kotlin 类都是 <code>final</code> 的(基于 Effective Java 的第17条规则).</p>

<p>可以通过 <code>open</code> 来改变:</p>

<pre><code class="language-bash">open class Base(p: Int)
</code></pre>

<p>这样子, 就允许该类被继承了.</p>

<p>如果子类有一个主构造器, 则父类可以且必需被初始化在正确的地方.</p>

<p>如果子类没有主构造器, 则每个子类中的次构造器必须通过 <code>super</code> 关键字来进行委派另一个构造器来初始化.</p>

<h3 id="重写方法">重写方法</h3>

<p>不同于Java, Kotlin 中要求显式使用 <code>override</code> 来指明这是一个重写的方法</p>

<pre><code class="language-bash">open class Base {
    open fun v() {}
    fun nv() {}
}
class Derived() : Base() {
    override fun v() {}
}
</code></pre>

<p>一个标记为 <code>override</code> 的成员, 本身是 <code>open</code> 的. 如果你想禁止它重写, 则可使用 <code>final</code> 关键字:</p>

<pre><code class="language-bash">open class AnotherDerived() : Base() {
    final override fun v() {}
}
</code></pre>

<h3 id="重写属性">重写属性</h3>

<p>重写属性也必须显式使用 <code>override</code>, 并且它们必须有一个兼容的类型.</p>

<p>如:</p>

<pre><code class="language-bash">open class Foo {
    open val x: Int get() { ... }
}

class Bar1 : Foo() {
    override val x: Int = ...
}
</code></pre>

<p>注意, 也可以在主构造器中使用 <code>override</code> 关键字作为属性声明的一部分.:</p>

<pre><code class="language-bash">interface Foo {
    val count: Int
}

class Bar1(override val count: Int) : Foo

class Bar2 : Foo {
    override var count: Int = 0
}
</code></pre>

<h3 id="子类初始化顺序">子类初始化顺序</h3>

<p>父类先初始化完, 再到子类.</p>

<p>这意味着, 在父类构造器执行期间, 子类中的声明的或重写的属性还没有初始化完毕的. 如果这些属性用在父类的初始化逻辑(不管是直接还是间接, 还是其他通过重写 <code>open</code> 成员来实现), 它可能会导致不正确的行为, 或者一个 runtime 失败.</p>

<p>设计一个父类时, 因此你应该避免在构造器, 属性初始化以及<code>init</code> 代码块中使用 <code>open</code> 的成员.</p>

<h3 id="调用父类的实现">调用父类的实现</h3>

<p>通过 <code>super</code> 关键字来调用</p>

<pre><code class="language-bash">open class Foo {
    open fun f() { println(&quot;Foo.f()&quot;) }
    open val x: Int get() = 1
}

class Bar : Foo() {
    override fun f() { 
        super.f()
        println(&quot;Bar.f()&quot;) 
    }

    override val x: Int get() = super.x + 1
}
</code></pre>

<p>在一个内部类中, 访问外部类的父类时, 可以通过 <code>super</code> 并带有外部类的名来实现: <code>super@Outer</code></p>

<pre><code class="language-bash">class Bar : Foo() {
    override fun f() { /* ... */ }
    override val x: Int get() = 0

    inner class Baz {
        fun g() {
            super@Bar.f() // Calls Foo's implementation of f()
            println(super@Bar.x) // Uses Foo's implementation of x's getter
        }
    }
}
</code></pre>

<h4 id="重写规则">重写规则</h4>

<p><em>如果一个类从它的直接父类中继承了多个相同的成员, 则它必须重写它自己的成员, 并且提供它自己的实现.</em></p>

<p>为了指明使用哪个父类的实现, 可以通过 <code>super</code> 关键字, 并在带有 <code>类括号</code> 里写上父类类型. 例如:</p>

<pre><code class="language-bash">open class A {
    open fun f() { print(&quot;A&quot;) }
    fun a() { print(&quot;a&quot;) }
}

interface B {
    fun f() { print(&quot;B&quot;) } // interface members are 'open' by default
    fun b() { print(&quot;b&quot;) }
}

class C() : A(), B {
    // The compiler requires f() to be overridden:
    override fun f() {
        super&lt;A&gt;.f() // call to A.f()
        super&lt;B&gt;.f() // call to B.f()
    }
}
</code></pre>

<h3 id="abstract-class">abstract class</h3>

<p>注意, 我们不需要标记一个抽象类或函数为 <code>open</code> 的, 默认就是 <code>open</code> 的.</p>

<p>我们可以将一个非抽象的 <code>open</code> 成员, 重写为 <code>abstract</code> 的:</p>

<pre><code class="language-bash">open class Base {
    open fun f() {}
}

abstract class Derived : Base() {
    override abstract fun f()
}
</code></pre>

<h3 id="companion-objects">Companion Objects</h3>

<p>在 Kotlin 中, 不像 Java 或 C# , 它没有静态方法的. 绝大部分情况下, 建议简单地使用 包级别的方法来代码~</p>

<p>如果你需要写一个函数可以不需要通过类实例就可以调用的话. 你可以将它写为一个 <code>object declaration</code> 的成员即可.</p>

<p>更具体地, 你可以声明一个 <code>companion object</code> 在你的类里. 这样, 你就可以像Java调用静态方法那样来调用它了.</p>

<h3 id="object-declaration">Object Declaration</h3>

<p>单例某几种情况下是非常有用的, 在 Kotlin 中, 你可以非常方便地声明单例:</p>

<pre><code class="language-bash">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ...
    }

    val allDataProviders: Collection&lt;DataProvider&gt;
        get() = // ...
}
</code></pre>

<p>这被称为 <code>object declaration</code> , 并且它总是一个 <code>object</code> 关键字后接一个名字的.</p>

<p><code>object declaration</code> 的初始化是线程安全的.</p>

<h3 id="companion-object">companion object</h3>

<p>在一个类内部进行 <code>object declaration</code> 的话, 它可以用 <code>companion</code> 关键字来标记.</p>

<pre><code class="language-bash">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre>

<p>然后可以这样子简化调用:</p>

<pre><code class="language-bash">val instance = MyClass.create()
</code></pre>

<p>声明时, <code>companion object</code> 的名称可以省略:</p>

<pre><code class="language-bash">class MyClass {
    companion object {
    }
}

val x = MyClass.Companion
</code></pre>

<h1 id="属性和字段">属性和字段</h1>

<h2 id="声明属性">声明属性</h2>

<p><code>var</code> 的表示是可变的(mutable)
<code>val</code> 的表示是只读的(read-only)</p>

<h2 id="setter-和-getter">setter 和 getter</h2>

<p>完整的语法为</p>

<pre><code class="language-bash">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]
    [&lt;getter&gt;]
    [&lt;setter&gt;]
</code></pre>

<pre><code class="language-bash">var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }
</code></pre>

<h1 id="接口-interface">接口 interface</h1>

<p>与 Java 8 非常相似.</p>

<p>它可以包含抽象方法, 也可以有方法实现. 使用 <code>interface</code> 关键字来定义:</p>

<pre><code class="language-bash">interface MyInterface {
    fun bar()
    fun foo() {
      // optional body
    }
}
</code></pre>

<p>实现接口</p>

<pre><code class="language-bash">class Child : MyInterface {
    override fun bar() {
        // body
    }
}
</code></pre>

<h2 id="接口中的属性">接口中的属性</h2>

<p>可以为抽象的, 也可以提供访问器实现.</p>

<pre><code class="language-bash">interface MyInterface {
    val prop: Int // abstract

    val propertyWithImplementation: String
        get() = &quot;foo&quot;

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}
</code></pre>

<h2 id="重写时的冲突解决">重写时的冲突解决</h2>

<p>参考上面说的.</p>

<h1 id="访问修饰符">访问修饰符</h1>

<p><code>getter</code> 总是与属性的访问性是一致的!一共有4种:</p>

<ul>
<li><code>private</code> : 仅声明的地方可以访问.</li>
<li><code>protected</code> : 在顶层的声明中不可用.</li>
<li><code>internal</code> : 在相同的 <code>module</code> 中可见.</li>
<li><code>public</code> (默认就是 <code>public</code>) : 所有代码都可以访问.</li>
</ul>

<h2 id="module">module</h2>

<p>一个 <code>module</code> 表示是一个 kotlin 文件编译在一起的集合:</p>

<ul>
<li>一个 intellij 的 moduel</li>
<li>一个 maven 项目</li>
<li>一个 gradle 文件源的集合</li>
<li>一个 ant task 编译的集合</li>
</ul>

<h1 id="extension-扩展">extension 扩展</h1>

<h2 id="extension-function-1">extension function</h2>

<p>为了声明一个扩展函数, 我们需要有一个接收者类型的前缀, 例如</p>

<pre><code class="language-bash">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
</code></pre>

<p><code>this</code> 关键字对应于接收者的对象. 现在, 我们可以调用在任意的<code>MutableList&lt;Int&gt;</code> 中调用这个方法了:</p>

<pre><code class="language-bash">val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
</code></pre>

<p>当然, 也可以是泛型版本:</p>

<pre><code class="language-bash">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
</code></pre>

<h2 id="extension-是静态解析的">extension 是静态解析的</h2>

<p>扩展函数实际上并不修改它们扩展的 class 的. 通过定义一个 extension, 你并没有插入新的成员到该 class 中, 但仅是在该类型的变量中通过 <code>.</code> 来调用这个方法而已.</p>

<p>我们想强调的是,  extension function 是通过静态分发的.</p>

<p>注意, 如果 class 中有一个成员函数, 以及一个 extension 函数, 它们的方法签名一样的话,则 <code>member always wins!</code></p>

<p>例如</p>

<pre><code class="language-bash">class C {
    fun foo() { println(&quot;member&quot;) }
}

fun C.foo() { println(&quot;extension&quot;) }
</code></pre>

<p>它总是会输出 <code>member</code>.</p>

<p>然而, 可以通过 extension 来重载 (overload) 成员函数(即相同的方法名, 但签名不一样)</p>

<h2 id="nullable-接收者">nullable 接收者</h2>

<p>你可以在方法内部检查是否为 <code>null</code> 例如:</p>

<pre><code class="language-bash">fun Any?.toString(): String {
    if (this == null) return &quot;null&quot;
    // after the null check, 'this' is autocast to a non-null type, so the toString() below
    // resolves to the member function of the Any class
    return toString()
}
</code></pre>

<h2 id="extension-属性">extension 属性</h2>

<p>类似函数, kotlin 支持扩展属性:</p>

<pre><code class="language-bash">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    get() = size - 1
</code></pre>

<h2 id="companion-object-extensions">Companion Object Extensions</h2>

<p>如果一个 class 有 <code>companion object</code> , 你也可以为它定义一个扩展函数和扩展属性:</p>

<pre><code class="language-bash">class MyClass {
    companion object { }  // will be called &quot;Companion&quot;
}

fun MyClass.Companion.foo() {
    // ...
}
</code></pre>

<p>调用</p>

<pre><code class="language-bash">MyClass.foo()
</code></pre>

<h2 id="定义-extension-作为成员">定义 extension 作为成员</h2>

<pre><code class="language-bash">class D {
    fun bar() { ... }
}

class C {
    fun baz() { ... }

    fun D.foo() {
        bar()   // calls D.bar
        baz()   // calls C.baz
    }

    fun caller(d: D) {
        d.foo()   // call the extension function
    }
}
</code></pre>

<h1 id="data-classes">Data classes</h1>

<p>我们经常会创建一些主要用来持有数据的 class . 这在 Kotlin 中称为 <code>data</code></p>

<pre><code class="language-bash">data class User(val name: String, val age: Int)
</code></pre>

<p>编译器会自动为声明在主构造器(primary constructor) 中的属性创建以下</p>

<ul>
<li><code>equals() / hashCode()</code> 方法对</li>
<li><code>toString()</code> , 形式为 <code>User(name=John, age=42)</code></li>
<li><code>componentN()</code> 函数</li>
<li><code>copy()</code> 函数</li>
</ul>

<p>前提条件(要全满足)</p>

<ul>
<li>主构造器至少要有一个参数</li>
<li>所以主构造器的参数需要标记为 <code>val</code> 或 <code>var</code></li>
<li>data class 不能为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或 <code>inner</code> 的.</li>
<li>(1.1之前), data class 仅实现接口</li>
</ul>

<p>生成代码的规则:
- 如果显式实现了 <code>equals()</code>, <code>hashCode()</code> 或 <code>toString()</code> , 或父类的这些实现是 <code>final</code> 的话, 则不会生成这些代码了, 它会用现成的代码
- 如果父类有 <code>componentN()</code> 函数, 并且为 <code>open</code> 以及返回兼容的类型, 则会生成的代码会重写父类的. 如果不能重写, 则会报错.
- 从一个有 <code>copy()</code> 函数的类中派生的话, 在 1.2 中是标记为 <code>deprecated</code> 的, 并且 在 1.3 中是禁止的.
- 不允许显式实现 <code>componentN()</code> 和 <code>copy()</code> 函数</p>

<h2 id="在-body-里声明属性">在 body 里声明属性</h2>

<p>注意: 只有在主构造器的参数的, 才会在 <code>toString()</code> , <code>equals()</code> 和 <code>hashCode()</code>, <code>copy()</code> 中使用到. 如果是在 body 中声明的, 则不会使用.</p>

<pre><code class="language-bash">data class Person(val name: String) {
    var age: Int = 0
}
</code></pre>

<h2 id="copying">copying</h2>

<p>有时, 我们经常需要 copy 一个对象, 但仅修改某些属性, 又不想影响原有对象. <code>copy()</code> 方法就是为它使用的.</p>

<pre><code class="language-bash">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)


val jack = User(name = &quot;Jack&quot;, age = 1)
val olderJack = jack.copy(age = 2)
</code></pre>

<h1 id="sealed-classes">Sealed Classes</h1>

<p><code>sealed classes</code> 是用来表示有限的 class 继承的, 它的值仅可以为一些有限集合之中的一种类型, 并且不能为其他类型.</p>

<p>在某种意义上说, 它是一个扩展的枚举类, 值的集合是限定为枚举类, 但每个枚举常量仅存在一个单例, 而 <code>sealed class</code> 的子类则可以有多个实例状态.</p>

<p>声明一个 <code>sealed class</code></p>

<pre><code class="language-bash">sealed class Expr
</code></pre>

<p><code>sealed class</code> 可以有子类, 但所有这些子类, 必须在声明 <code>sealed class</code> 的文件内!</p>

<pre><code class="language-bash">sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()
</code></pre>

<p><code>sealed class</code> 不允许有非 private 的构造器(默认就是 <code>private</code> 的)</p>

<p><code>sealed class</code> 主要用在 <code>when</code> 表达式~</p>

<h1 id="generic-泛型">generic 泛型</h1>

<pre><code class="language-bash">class Box&lt;T&gt;(t: T) {
    var value = t
}
</code></pre>

<p>如果参数是可以被解析的话, 则可以忽略类型:</p>

<pre><code class="language-bash">val box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;
</code></pre>

<h1 id="嵌套类和内部类">嵌套类和内部类</h1>

<p>嵌套类:</p>

<pre><code class="language-bash">class Outer {
    private val bar: Int = 1
    class Nested {
        fun foo() = 2
    }
}

val demo = Outer.Nested().foo() // == 2
</code></pre>

<p>内部类</p>

<pre><code class="language-bash">class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}
</code></pre>

<p>匿名内部类</p>

<pre><code class="language-bash">window.addMouseListener(object: MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})
</code></pre>

<h1 id="枚举类">枚举类</h1>

<pre><code class="language-bash">enum class Direction {
    NORTH, SOUTH, WEST, EAST
}
</code></pre>

<p>初始化</p>

<pre><code class="language-bash">enum class Color(val rgb: Int) {
        RED(0xFF0000),
        GREEN(0x00FF00),
        BLUE(0x0000FF)
}
</code></pre>

<p>匿名类</p>

<pre><code class="language-bash">enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };

    abstract fun signal(): ProtocolState
}
</code></pre>

<h1 id="object-expression-和-declaration">object expression 和 declaration</h1>

<p>有时, 我们需要创建一个对象来小小修改一些 class 的, 不用为它显式声明一个新的子类. 在Java中, 处理这种情况的, 是用匿名内部类. Kotlin 则是用 <code>object expression</code> 和 <code>object declaration</code></p>

<p>为现有的类型创建一个匿名类型, 可以这样子:</p>

<pre><code class="language-bash">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})
</code></pre>

<p>如果父类是多种类型的话, 则用逗号隔开:</p>

<pre><code class="language-bash">open class A(x: Int) {
    public open val y: Int = x
}

interface B {...}

val ab: A = object : A(1), B {
    override val y = 15
}
</code></pre>

<p>但我们仅需要一个对象的话, 则我们可以简单地:</p>

<pre><code class="language-bash">fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)
}
</code></pre>

<p>object declaration , 参考前面.</p>

<h1 id="delegation-委托">Delegation 委托</h1>

<p><code>delegation</code> 模式提供了一个比较好的修改实现的方式. <code>Kotlin</code> 则原生支持它. 一个 <code>Derived</code> 类, 可以继承一个接口 <code>Base</code> 并且委托它所有的 <code>public</code> 方法到一个指定的对象:</p>

<pre><code class="language-bash">interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    Derived(b).print() // prints 10
}
</code></pre>

<p><code>by</code> 子句, 在 <code>Derived</code> class 中, 指示 <code>b</code> 将被内部保存在 <code>Derived</code> 中, 并且编译器将生成所有 <code>Base</code> 类的方法到 <code>b</code></p>

<p>注意, <code>override</code> : 编译器会使用你的 <code>override</code> 的实现来委托.</p>

<h1 id="delegated-properties">Delegated Properties</h1>

<p>有一些公共的属性, 尽管我们可以手工多次实现它, 但更好的是实现它一次, 然后放到一个库中:</p>

<pre><code class="language-bash">class Example {
    var p: String by Delegate()
}


class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String {
        return &quot;$thisRef, thank you for delegating '${property.name}' to me!&quot;
    }

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {
        println(&quot;$value has been assigned to '${property.name}' in $thisRef.&quot;)
    }
}
</code></pre>

<h2 id="标准的-delegates">标准的 delegates</h2>

<ul>
<li>Lazy</li>
</ul>

<pre><code class="language-bash">val lazyValue: String by lazy {
    println(&quot;computed!&quot;)
    &quot;Hello&quot;
}

fun main(args: Array&lt;String&gt;) {
    println(lazyValue)
    println(lazyValue)
}
</code></pre>

<ul>
<li>Observable</li>
</ul>

<pre><code class="language-bash">import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) {
        prop, old, new -&gt;
        println(&quot;$old -&gt; $new&quot;)
    }
}

fun main(args: Array&lt;String&gt;) {
    val user = User()
    user.name = &quot;first&quot;
    user.name = &quot;second&quot;
}
</code></pre>

<h2 id="storing-properties-in-a-map">Storing Properties in a Map</h2>

<pre><code class="language-bash">class User(val map: Map&lt;String, Any?&gt;) {
    val name: String by map
    val age: Int     by map
}


val user = User(mapOf(
    &quot;name&quot; to &quot;John Doe&quot;,
    &quot;age&quot;  to 25
))
</code></pre>

<h1 id="higher-order-function-和-lambda-1">higher-order function 和 lambda</h1>

<p><code>higher-order function</code> 是这样一种函数: 它可以作为参数或函数返回值. 例如</p>

<pre><code class="language-bash">fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T {
    lock.lock()
    try {
        return body()
    }
    finally {
        lock.unlock()
    }
}
</code></pre>

<h2 id="it-隐式的单一的参数名字"><code>it</code> : 隐式的单一的参数名字</h2>

<p>如果 lambda 只有一个参数时, 可以这样子简写(并且不需要 <code>-&gt;</code>):</p>

<pre><code class="language-bash">ints.map { it * 2 }
</code></pre>

<h2 id="忽略参数-1-1-版本开始"><code>_</code> : 忽略参数:(1.1 版本开始)</h2>

<pre><code class="language-bash">map.forEach { _, value -&gt; println(&quot;$value!&quot;) }
</code></pre>

<h2 id="inline-function-1">inline function</h2>

<p>它一般可增强性能.</p>

<h2 id="lambda-expression-和-匿名函数">lambda expression 和 匿名函数</h2>

<p>它们都是 <code>function iteral</code></p>

<pre><code class="language-bash">max(strings, { a, b -&gt; a.length &lt; b.length })
</code></pre>

<h3 id="匿名函数">匿名函数</h3>

<pre><code class="language-bash">fun(x: Int, y: Int): Int = x + y

fun(x: Int, y: Int): Int {
    return x + y
}

ints.filter(fun(item) = item &gt; 0)
</code></pre>

<h2 id="closures">closures</h2>

<p>一个 <code>lambda expression</code> 或 <code>anonymous function</code> 可以访问它的 <code>closure</code> (例如, 一个声明在外部的变量) 不同于Java, 捕获的变量可以被修改(Java中, 只能访问 <code>final</code> 的变量)</p>

<h2 id="function-literal-与-receiver">function literal 与 receiver</h2>

<p>Kotlin 允许为它提供一个接收者:</p>

<pre><code class="language-bash">sum : Int.(other: Int) -&gt; Int
</code></pre>

<p>然后可以这样子调用</p>

<pre><code class="language-bash">1.sum(2)
</code></pre>

<h1 id="inline-function-2">inline function</h1>

<p>使用 <code>higher-order function</code> 都会加重运行时的负担: 每一个函数都是一个 <code>object</code>, 并且它会捕获一个 <code>closure</code>, 例如, 可访问的函数体的变量. 内存分配以及虚拟调用都会增加 runtime 的负载.</p>

<p>但多数情况下, 可以通过 <code>inline lambda expression</code>  来减少这种负载.</p>

<p>例如:</p>

<pre><code class="language-bash">lock(l) { foo() }
</code></pre>

<h2 id="开启-inline">开启 <code>inline</code></h2>

<pre><code class="language-bash">inline fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T {
    // ...
}
</code></pre>

<h2 id="noinline">noinline</h2>

<p>如果你只想指定的某些参数不进行 inline:</p>

<pre><code class="language-bash">inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {
    // ...
}
</code></pre>

<h2 id="inline-properties">inline properties</h2>

<pre><code class="language-bash">val foo: Foo
    inline get() = Foo()

var bar: Bar
    get() = ...
    inline set(v) { ... }
</code></pre>

<h1 id="destructuring-declaration">destructuring declaration</h1>

<pre><code class="language-bash">val (name, age) = person 
</code></pre>

<p>以上就是析构的声明语法. 它由编译器自动生成以下代码</p>

<pre><code class="language-bash">val name = person.component1()
val age = person.component2()
</code></pre>

<p>也可以在 <code>for</code> 循环里使用</p>

<pre><code class="language-bash">for ((a, b) in collection) { ... }
</code></pre>

<h2 id="从一个函数中返回2个值">从一个函数中返回2个值</h2>

<pre><code class="language-bash">data class Result(val result: Int, val status: Status)
fun function(...): Result {
    // computations

    return Result(result, status)
}

// Now, to use this function:
val (result, status) = function(...)
</code></pre>

<h2 id="在-map-中使用">在 map 中使用</h2>

<pre><code class="language-bash">for ((key, value) in map) {
   // do something with the key and the value
}
</code></pre>

<h2 id="在-lambda-中使用">在 lambda 中使用</h2>

<pre><code class="language-bash">map.mapValues { entry -&gt; &quot;${entry.value}!&quot; }
map.mapValues { (key, value) -&gt; &quot;$value!&quot; }
</code></pre>

<h1 id="collections">Collections</h1>

<p>Kotlin 是会区分 <code>mutable</code> 和 <code>immutable</code> 的集合的.</p>

<p>区分一个 mutable 的 <code>read-only</code> 视图, 和一个真正 <code>immutable</code> 的集合是非常重要的.</p>

<pre><code class="language-bash">val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)
val readOnlyView: List&lt;Int&gt; = numbers
println(numbers)        // prints &quot;[1, 2, 3]&quot;
numbers.add(4)
println(readOnlyView)   // prints &quot;[1, 2, 3, 4]&quot;
readOnlyView.clear()    // -&gt; does not compile

val strings = hashSetOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;)
assert(strings.size == 3)
</code></pre>

<h1 id="this-expression">this expression</h1>

<ul>
<li>在一个 class 成员内, <code>this</code> 引用的是当前class 的 object 对象</li>
<li>在一个 <code>expression function</code> 或 <code>function literal with receiver</code> 中, <code>this</code> 表示 <code>receiver</code> 参数(即 <code>.</code> 左边类型的对象)</li>
</ul>

<p>如果 <code>this</code> 没有限定符, 则它引用的是 <code>内部最近的作用域</code>. 为了使 <code>this</code> 引用其他作用域的, 可以使用 <code>label qualifiers</code></p>

<p>例如</p>

<pre><code class="language-bash">class A { // implicit label @A
    inner class B { // implicit label @B
        fun Int.foo() { // implicit label @foo
            val a = this@A // A's this
            val b = this@B // B's this

            val c = this // foo()'s receiver, an Int
            val c1 = this@foo // foo()'s receiver, an Int

            val funLit = lambda@ fun String.() {
                val d = this // funLit's receiver
            }


            val funLit2 = { s: String -&gt;
                // foo()'s receiver, since enclosing lambda expression
                // doesn't have any receiver
                val d1 = this
            }
        }
    }
}
</code></pre>

<h1 id="equality-相等">equality 相等</h1>

<ul>
<li><code>equals()</code> : structural equality (a == b, 它会被翻译为 <code>a?.equals(b) ?: (b === null)</code>)</li>
<li>引用相等: 使用 <code>===</code> 或 <code>!==</code> 来判断</li>
</ul>

<h1 id="操作符重载">操作符重载</h1>

<p>参考 <a href="http://kotlinlang.org/docs/reference/operator-overloading.html">doc</a></p>

<h1 id="annotation">annotation</h1>

<p>声明注解</p>

<pre><code class="language-bash">annotation class Fancy

@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,
        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
annotation class Fancy
</code></pre>

<p>使用</p>

<pre><code class="language-bash">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}

</code></pre>

<h1 id="type-aliases-类型别名">Type aliases 类型别名</h1>

<pre><code class="language-bash">typealias NodeSet = Set&lt;Network.Node&gt;

typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;
</code></pre>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-03-01</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/kotlin/">kotlin</a>
          
          <a href="/tags/java/">java</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2018/03/12/rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Rust 学习笔记</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/2018/02/28/%E6%88%91%E7%9A%84java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
            <span class="next-text nav-default">我的Java开发环境</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2018-03-01 11:25:40 \x2b0000 UTC',
    title: 'Kotlin lang 学习笔记',
    link: decodeURI(location.href),
    desc: '基本语法 定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置 源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等 特别地,',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>








<script src="https://s13.cnzz.com/z_stat.php?id=1273926342&web_id=1273926342"></script>

</body>
</html>
