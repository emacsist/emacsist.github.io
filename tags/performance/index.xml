<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>performance on emacsist</title>
    <link>https://emacsist.github.io/tags/performance/</link>
    <description>Recent content in performance on emacsist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 12 Oct 2019 14:08:17 +0800</lastBuildDate>
    
	<atom:link href="https://emacsist.github.io/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Disruptor学习</title>
      <link>https://emacsist.github.io/2019/10/12/disruptor%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 12 Oct 2019 14:08:17 +0800</pubDate>
      
      <guid>https://emacsist.github.io/2019/10/12/disruptor%E5%AD%A6%E4%B9%A0/</guid>
      <description>简介-翻译 原文 https://github.com/LMAX-Exchange/disruptor/wiki/Introduction 理解 Disruptor 是什么的最好方式是与相似的众所周知的东西进行比较. 对于 Disruptor 来说, 就是 Java 的 BlockingQueue . 像队列一样, Disruptor 的目的是在同一进程内的线程相互</description>
    </item>
    
    <item>
      <title>&lt;HikariCP 数据库连接池实践&gt;笔记</title>
      <link>https://emacsist.github.io/2019/09/11/hikaricp-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 11 Sep 2019 14:16:26 +0800</pubDate>
      
      <guid>https://emacsist.github.io/2019/09/11/hikaricp-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</guid>
      <description>Linux 内核 文件句柄相关参数 # kernel 级别最大打开文件句柄数 sudo sysctl -w fs.file-max=3145728 sudo sysctl -w fs.nr_open=3145728 sudo sysctl -p sudo echo 3145728 &amp;gt; /proc/sys/fs/nr_open # 进程级别最大打开文件句柄数 ulimit -n 1048576 TCP 栈相关参数 # backlog sudo sysctl -w net.core.somaxconn=32768 sudo</description>
    </item>
    
    <item>
      <title>关于StringBuilder中设置初始容量对性能的测试</title>
      <link>https://emacsist.github.io/2017/06/16/%E5%85%B3%E4%BA%8Estringbuilder%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 16 Jun 2017 16:09:45 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2017/06/16/%E5%85%B3%E4%BA%8Estringbuilder%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E6%B5%8B%E8%AF%95/</guid>
      <description>被测试代码 package org.agoncal.sample.jmh; /** * Created by emacsist on 2017/6/16. */ public class StringAppend { public static String defaultBuilder(int len) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &amp;lt; len; i++) { sb.append(i); } return sb.toString(); } public static String bufferBuilder(int len) { StringBuilder sb = new StringBuilder(len); for (int i = 0; i &amp;lt; len; i++) { sb.append(i); } return sb.toString();</description>
    </item>
    
    <item>
      <title>请不要再说Java中final方法比非final性能更好了</title>
      <link>https://emacsist.github.io/2017/06/16/%E8%AF%B7%E4%B8%8D%E8%A6%81%E5%86%8D%E8%AF%B4java%E4%B8%ADfinal%E6%96%B9%E6%B3%95%E6%AF%94%E9%9D%9Efinal%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E4%BA%86/</link>
      <pubDate>Fri, 16 Jun 2017 12:07:00 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2017/06/16/%E8%AF%B7%E4%B8%8D%E8%A6%81%E5%86%8D%E8%AF%B4java%E4%B8%ADfinal%E6%96%B9%E6%B3%95%E6%AF%94%E9%9D%9Efinal%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E4%BA%86/</guid>
      <description>无继承 有 static 修饰 static final // 生成随机数字和字母, public static final String getStringRandomFinal(int length) { String val = &amp;quot;&amp;quot;; Random random = new Random(); // 参数length，表示生成几位随机数 for (int i = 0; i &amp;lt; length; i++) { String charOrNum = random.nextInt(2) %</description>
    </item>
    
    <item>
      <title>Java监控方法调用树以及方法性能</title>
      <link>https://emacsist.github.io/2016/05/23/java%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%91%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD/</link>
      <pubDate>Mon, 23 May 2016 15:57:18 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2016/05/23/java%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%91%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD/</guid>
      <description>JETM 下载 Download 使用 @Test public void hello() throws InterruptedException { BasicEtmConfigurator.configure(true); etmMonitor.start(); EtmPoint etmPoint = etmMonitor.createPoint(&amp;quot;SETest:hello&amp;quot;); System.out.println(&amp;quot;hello world&amp;quot;); Thread.currentThread().sleep(2 * 1000); nested(); nested(); sayf(); etmPoint.collect(); // visualize results etmMonitor.render(new SimpleTextRenderer()); etmMonitor.stop(); } private static void nested() throws InterruptedException { EtmPoint etmPoint = etmMonitor.createPoint(&amp;quot;SETest:nested&amp;quot;); System.out.println(&amp;quot;in nested&amp;quot;); Thread.currentThread().sleep(2*1000); etmPoint.collect(); } private static void sayf() throws InterruptedException { EtmPoint etmPoint = etmMonitor.createPoint(&amp;quot;SETest:sayf&amp;quot;); System.out.println(&amp;quot;in nested&amp;quot;); Thread.currentThread().sleep(2*1000); nested(); etmPoint.collect(); } 输出</description>
    </item>
    
    <item>
      <title>Java常见应用的性能优化</title>
      <link>https://emacsist.github.io/2016/01/26/java%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 26 Jan 2016 17:05:37 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2016/01/26/java%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>总诀式 减少网络连接次数 减小网络传输数据 添加缓存 分布式 Redis 式 在同一线程的操作里，尽可能合并redis的操作(pipeline)（减少网络连接次数</description>
    </item>
    
  </channel>
</rss>