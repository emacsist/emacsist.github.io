<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go学习 - emacsist</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="emacsist" />
  <meta name="description" content="安装多个版本的 go GVM Go依赖管理与 GOPATH 的关系. GOPATH环境变" />

  <meta name="keywords" content="Golang, Java, PostgreSQL, Postgres, MySQL, emacsist, RabbitMQ, Go, emacs, orgmode" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://emacsist.github.io/2016/10/18/go%E5%AD%A6%E4%B9%A0/" />

<link href="." rel="alternate" type="application/rss+xml" title="emacsist" />
<link href="." rel="feed" type="application/rss+xml" title="emacsist" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">





<meta property="og:title" content="Go学习" />
<meta property="og:description" content="安装多个版本的 go GVM Go依赖管理与 GOPATH 的关系. GOPATH环境变" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://emacsist.github.io/2016/10/18/go%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2016-10-18T19:35:00+00:00" />
<meta property="article:modified_time" content="2016-10-18T19:35:00+00:00" />
<meta itemprop="name" content="Go学习">
<meta itemprop="description" content="安装多个版本的 go GVM Go依赖管理与 GOPATH 的关系. GOPATH环境变">


<meta itemprop="datePublished" content="2016-10-18T19:35:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-10-18T19:35:00&#43;00:00" />
<meta itemprop="wordCount" content="5986">



<meta itemprop="keywords" content="golang,go," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go学习"/>
<meta name="twitter:description" content="安装多个版本的 go GVM Go依赖管理与 GOPATH 的关系. GOPATH环境变"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">emacsist</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">emacsist</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go学习</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-10-18 </span>
        <div class="post-category">
            
              <a href="/categories/golang/"> golang </a>
            
              <a href="/categories/go/"> go </a>
            
          </div>
        <span class="more-meta"> 5986 words </span>
        <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#安装多个版本的-go">安装多个版本的 go</a></li>
<li><a href="#go依赖管理与-gopath-的关系">Go依赖管理与 GOPATH 的关系.</a></li>
<li><a href="#自己对go中包的理解">自己对Go中包的理解</a></li>
<li><a href="#golang中的字符串拼接">Golang中的字符串拼接</a></li>
<li><a href="#vscode中调试go">vscode中调试Go</a></li>
<li><a href="#go单元测试">Go单元测试</a>
<ul>
<li><a href="#单元测试某个指定的方法">单元测试某个指定的方法</a></li>
<li><a href="#单元测试递归执行">单元测试递归执行</a></li>
<li><a href="#关于单元测试中的-log-logf">关于单元测试中的 Log()， Logf()</a></li>
</ul></li>
<li><a href="#golang中类似java中的-tostring-功能">Golang中类似Java中的<code>toString()</code>功能</a></li>
<li><a href="#int64-to-string">int64 to String</a></li>
<li><a href="#通过反射遍历结构体">通过反射遍历结构体</a></li>
<li><a href="#将json字段串自动转化生成struct结构">将json字段串自动转化生成struct结构</a>
<ul>
<li><a href="#json-字符串-转换为-struct">json 字符串 转换为 struct</a></li>
<li><a href="#struct-对象-转换为json字符串">struct 对象 转换为json字符串</a></li>
<li><a href="#示例">示例</a></li>
</ul></li>
<li><a href="#参数中是否是指针的区别">参数中是否是指针的区别:</a></li>
<li><a href="#常用go包">常用Go包</a></li>
<li><a href="#常见错误">常见错误</a>
<ul>
<li><a href="#http-contentlength-xxx-with-body-length-yyy">http: ContentLength=xxx with Body length yyy</a></li>
<li><a href="#cannot-define-new-methods-on-non-local-type">cannot define new methods on non-local type</a></li>
<li><a href="#can-t-load-package-import-cycle-not-allowed">can&rsquo;t load package: import cycle not allowed</a></li>
<li><a href="#too-many-arguments-to-return">too many arguments to return</a></li>
<li><a href="#interface-is-pointer-to-interface-not-interface">*interface {} is pointer to interface, not interface</a></li>
<li><a href="#cannot-use-nil-as-type-xxx">cannot use nil as type xxx</a></li>
<li><a href="#found-packages-xxxx-and-xxxx-xxxx-in-xxxx">found packages xxxx () and xxxx (xxxx) in xxxx</a></li>
</ul></li>
<li><a href="#struct-结构体的继承">struct 结构体的继承</a></li>
<li><a href="#go中的字符串转换为字符数组">Go中的字符串转换为字符数组</a></li>
<li><a href="#golang中顶级的json数组字符串转换为json对象">Golang中顶级的JSON数组字符串转换为json对象</a></li>
<li><a href="#创建一个自定义的error">创建一个自定义的error</a></li>
<li><a href="#json数组转换为map">json数组转换为map</a></li>
<li><a href="#go交叉编译">Go交叉编译</a>
<ul>
<li><a href="#常见错误-1">常见错误:</a></li>
<li><a href="#linux下交叉编译mac">Linux下交叉编译Mac</a></li>
<li><a href="#os常量以及arch常量">OS常量以及ARCH常量</a></li>
</ul></li>
<li><a href="#go打包静态资源">Go打包静态资源</a>
<ul>
<li><a href="#常用编译选项">常用编译选项</a>
<ul>
<li><a href="#去掉调试信息">去掉调试信息</a></li>
<li><a href="#查看优化的信息-内联-inline-信息-逃逸分析等">查看优化的信息(内联 inline 信息、逃逸分析等)</a></li>
</ul></li>
</ul></li>
<li><a href="#数组与slice-区别">数组与slice 区别</a></li>
<li><a href="#go中使用-redis">Go中使用 redis</a></li>
<li><a href="#go-中使用-gorm-与-mysql-交互">Go 中使用 gorm 与 mysql 交互</a></li>
<li><a href="#go-中使用-rabbitmq">go 中使用 rabbitmq</a>
<ul>
<li><a href="#注意事项">注意事项</a></li>
</ul></li>
<li><a href="#go中long与timestamp-json的转换">go中long与timestamp json的转换</a></li>
<li><a href="#go-中找出实现了某接口的代码">Go 中找出实现了某接口的代码</a></li>
<li><a href="#golang中实现优雅关闭程序">Golang中实现优雅关闭程序</a>
<ul>
<li><a href="#检查程序监控了哪些信号">检查程序监控了哪些信号</a></li>
</ul></li>
<li><a href="#golang中的struct-tag使用">Golang中的struct tag使用</a></li>
<li><a href="#限制goalng的http-工作线程-goroutine">限制Goalng的HTTP 工作线程(goroutine)</a></li>
<li><a href="#为什么我的内存没有被操作系统回收">为什么我的内存没有被操作系统回收？</a></li>
<li><a href="#golang1-8-中的优雅关闭-http">Golang1.8 中的优雅关闭 http</a></li>
<li><a href="#按-github-风格的项目组织结构">按 github 风格的项目组织结构</a></li>
<li><a href="#压缩编译后的文件大小">压缩编译后的文件大小</a>
<ul>
<li><a href="#去掉符号信息">去掉符号信息</a></li>
<li><a href="#使用-upx-压缩">使用 upx 压缩</a></li>
</ul></li>
<li><a href="#golang-中的-web">Golang 中的 web</a></li>
<li><a href="#短声明注意">短声明注意</a></li>
<li><a href="#类型转换">类型转换</a></li>
<li><a href="#golang-中格式化日期">Golang 中格式化日期</a></li>
<li><a href="#go-中发送登录请求-保持-cookie">Go 中发送登录请求（保持 cookie)</a></li>
<li><a href="#go-中提交表单">Go 中提交表单</a></li>
<li><a href="#logrus-设置日志时间格式">logrus 设置日志时间格式</a></li>
<li><a href="#go-中自动重连-rabbitmq">Go 中自动重连 RabbitMQ</a></li>
<li><a href="#go-中批量处理-sql">Go 中批量处理 SQL</a></li>
<li><a href="#go-中处理-gbk-字符集">Go 中处理 GBK 字符集</a></li>
<li><a href="#go-中-get-请求的参数处理">Go 中 GET 请求的参数处理</a></li>
<li><a href="#go-中调试-http-的-request-和-response">Go 中调试 http 的 request 和 response</a></li>
<li><a href="#go-中按行读取-string">Go 中按行读取 string</a></li>
<li><a href="#go-中按空格-split-字符串">Go 中按空格 split 字符串</a></li>
<li><a href="#读取-json-文件为-struct-结构体">读取 json 文件为 struct 结构体</a></li>
<li><a href="#string-与-int-互转">string 与 int 互转</a></li>
<li><a href="#go-中-http-client-的-timeout-设置">Go 中 http client 的 timeout 设置</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h2 id="安装多个版本的-go">安装多个版本的 go</h2>

<p><a href="https://github.com/moovweb/gvm">GVM</a></p>

<h2 id="go依赖管理与-gopath-的关系">Go依赖管理与 GOPATH 的关系.</h2>

<p><code>GOPATH</code>环境变量中可以包含多个目录。</p>

<pre><code class="language-bash">go get
</code></pre>

<p>这种方式，它会将依赖下载在<code>$GOPATH</code>环境变量中的第一个目录中.</p>

<h2 id="自己对go中包的理解">自己对Go中包的理解</h2>

<pre><code class="language-bash">编写代码时，使用的`package`，表示代码所在的包名。

引用时，`import package`，这个`package`表示相对于`GOPATH`中的`src`目录下的目录名，多层目录，使用`/`分隔。
一般来说，引用的`package`的名字，和你的最后一个目录的名字相同，但也可以不同。`import package`的名字，以所在包名的名字为准，而不是以目录名为准.
</code></pre>

<h2 id="golang中的字符串拼接">Golang中的字符串拼接</h2>

<pre><code class="language-bash">package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
)

func main() {
    var buffer bytes.Buffer

    for i := 0; i &lt; 1000; i++ {
        buffer.WriteString(&quot;a&quot;)
    }

    fmt.Println(buffer.String())
}
</code></pre>

<h2 id="vscode中调试go">vscode中调试Go</h2>

<pre><code class="language-bash">can't load package: package .: no buildable Go source files in /ihome/go/golang-weibo-sdk
exit status 1
</code></pre>

<p>这个问题是由于你没有将设置指向main.go的所在目录里.即，在Go的debug设置里，要类似如下：</p>

<pre><code class="language-bash">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [{
        &quot;name&quot;: &quot;Launch&quot;,
        &quot;type&quot;: &quot;go&quot;,
        &quot;request&quot;: &quot;launch&quot;,
        &quot;mode&quot;: &quot;debug&quot;,
        &quot;remotePath&quot;: &quot;&quot;,
        &quot;port&quot;: 2345,
        &quot;host&quot;: &quot;127.0.0.1&quot;,
        &quot;program&quot;: &quot;${workspaceRoot}/src/main&quot;,
        &quot;env&quot;: {},
        &quot;args&quot;: [],
        &quot;showLog&quot;: true
    }]
}
</code></pre>

<p>即，<code>program</code>要设置为指向Go的main函数文件所在的目录即可.</p>

<h2 id="go单元测试">Go单元测试</h2>

<p>必须要将命令行，先切换到要进行单元测试文件的目录的根目录。比如：</p>

<pre><code class="language-bash">$GOPATH/src/utils/myutil.go
$GOPATH/src/utils/myutil_test.go
</code></pre>

<p>要想进行 <code>myutil_test.go</code> 的单元测试，则先切换到目录<code>$GOPATH/src/utils</code>，然后在该目录下执行命令:<code>go test</code>即可。</p>

<h3 id="单元测试某个指定的方法">单元测试某个指定的方法</h3>

<pre><code class="language-bash">go test -run mehtodName
</code></pre>

<h3 id="单元测试递归执行">单元测试递归执行</h3>

<pre><code class="language-bash">进入到$GOPATH的根目录，然后按以下方式执行即可:
go test com.github.emacsist.weibosdk/api...
</code></pre>

<h3 id="关于单元测试中的-log-logf">关于单元测试中的 Log()， Logf()</h3>

<p>默认的情况下，<code>go test</code>并不会输出这些， 如果需要的话，可以添加<code>go test -v</code>来输出详细信息.</p>

<h2 id="golang中类似java中的-tostring-功能">Golang中类似Java中的<code>toString()</code>功能</h2>

<pre><code class="language-bash">package resp

import (
	&quot;fmt&quot;
)

// ErrorResp ： 错误码返回对象
type ErrorResp struct {
	Request   string `json:&quot;request&quot;`
	ErrorCode int32  `json:&quot;error_code&quot;`
	Error     string `json:&quot;error&quot;`
}

func (errorResp *ErrorResp) String() string {
	return fmt.Sprintf(&quot;request=%v\nErrorCode=%v\nError=%v\n&quot;, errorResp.Request, errorResp.ErrorCode, errorResp.Error)
}

</code></pre>

<p>即为它添加一个方法 <code>String() string</code>即可，这样子，在调用<code>fmt.Printf()</code>这些格式化打印时，就会自动调用对象的<code>String()</code>方法来打印了.</p>

<h2 id="int64-to-string">int64 to String</h2>

<pre><code class="language-bash">
import &quot;strconv&quot;

strconv.FormatInt(int64Value, 10)
</code></pre>

<h2 id="通过反射遍历结构体">通过反射遍历结构体</h2>

<pre><code class="language-bash">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Person struct {
	Age  int
	Name string
}

func main() {
	p := Person{Age: 10, Name: &quot;HelloWorld&quot;}

	refValue := reflect.ValueOf(&amp;p)

	fields := refValue.Elem()
	for i := 0; i &lt; fields.NumField(); i++ {
		field := fields.Field(i)
		fieldName := fields.Type().Field(i).Name
		fieldValue := field.Interface()
		fmt.Printf(&quot;fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
	}
}

</code></pre>

<p>要注意的是，<code>fieldName</code>是通过<code>fields</code>这个来获取的.</p>

<p>如果想要将字段的值转换为确定类型的值，则就可以这样子做:</p>

<pre><code class="language-bash">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Person struct {
	Age  int
	Name string
}

func main() {
	p := Person{Age: 10, Name: &quot;HelloWorld&quot;}

	refValue := reflect.ValueOf(&amp;p)

	fields := refValue.Elem()
	for i := 0; i &lt; fields.NumField(); i++ {
		field := fields.Field(i)
		fieldName := fields.Type().Field(i).Name

		if field.Type().Name() == &quot;string&quot; {
			fieldValue := field.Interface().(string)
			fmt.Printf(&quot;string --&gt; fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
		} else if field.Type().Name() == &quot;int&quot; {
			fieldValue := field.Interface().(int)
			fmt.Printf(&quot;int --&gt; fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
		}

	}
}

</code></pre>

<h2 id="将json字段串自动转化生成struct结构">将json字段串自动转化生成struct结构</h2>

<p><a href="http://json2struct.mervine.net/">mervine.net</a>
<a href="https://mholt.github.io/json-to-go/">mholt.github.io</a></p>

<h3 id="json-字符串-转换为-struct">json 字符串 转换为 struct</h3>

<pre><code class="language-bash">import &quot;encoding/json&quot;

json.Unmarshal([]byte(body), &amp;status)
</code></pre>

<h3 id="struct-对象-转换为json字符串">struct 对象 转换为json字符串</h3>

<pre><code class="language-bash">p为结构体变量
body, error := json.Marshal(p)
</code></pre>

<h3 id="示例">示例</h3>

<pre><code class="language-bash">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

// Person : test object
type Person struct {
	Name string
	Age  int
}

func changeValue(p Person) {
	p.Age = 10
}

func changeValue2(p *Person) {
	p.Age = 10
}

func main() {
	p := Person{Age: 1, Name: &quot;HelloWorld&quot;}
	changeValue(p)
	fmt.Printf(&quot;changeValue, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
	changeValue2(&amp;p)
	fmt.Printf(&quot;changeValue2, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)

	body, _ := json.Marshal(p)
	fmt.Printf(&quot;struct to json -&gt; %v\n&quot;, string(body))

	newP := Person{}
	fmt.Printf(&quot;newP age -&gt; %v\n&quot;, newP.Age)
	json.Unmarshal(body, &amp;newP)
	fmt.Printf(&quot;after json to struct -&gt; %v\n&quot;, newP.Age)
}

</code></pre>

<p>输出的结果为</p>

<pre><code class="language-bash">[Running] go run &quot;/ihome/go/golang-weibo-sdk/src/main/main.go&quot;
changeValue, name -&gt;HelloWorld, age -&gt; 1
changeValue2, name -&gt;HelloWorld, age -&gt; 10
struct to json -&gt; {&quot;Name&quot;:&quot;HelloWorld&quot;,&quot;Age&quot;:10}
newP age -&gt; 0
after json to struct -&gt; 10

[Done] exited with code=0 in 0.13 seconds
</code></pre>

<h2 id="参数中是否是指针的区别">参数中是否是指针的区别:</h2>

<pre><code class="language-bash">package main

import &quot;fmt&quot;

// Person : test object
type Person struct {
	Name string
	Age  int
}

func changeValue(p Person) {
	p.Age = 10
}

func changeValue2(p *Person) {
	p.Age = 10
}

func main() {
	p := Person{Age: 1, Name: &quot;HelloWorld&quot;}
	changeValue(p)
	fmt.Printf(&quot;changeValue, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
	changeValue2(&amp;p)
	fmt.Printf(&quot;changeValue2, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
}

</code></pre>

<p>输出的结果为</p>

<pre><code class="language-bash">[Running] go run &quot;/ihome/go/golang-weibo-sdk/src/main/main.go&quot;
changeValue, name -&gt;HelloWorld, age -&gt; 1
changeValue2, name -&gt;HelloWorld, age -&gt; 10

[Done] exited with code=0 in 0.103 seconds
</code></pre>

<h2 id="常用go包">常用Go包</h2>

<pre><code class="language-bash">将struct转换为查询参数:
https://godoc.org/github.com/google/go-querystring/query
</code></pre>

<h2 id="常见错误">常见错误</h2>

<h3 id="http-contentlength-xxx-with-body-length-yyy">http: ContentLength=xxx with Body length yyy</h3>

<p>ContentLength=299 with Body length 367</p>

<pre><code class="language-bash">这一般是request对象前后的长度不一致（中间关闭了或处理了，导致后面的再次读取时不一致）
</code></pre>

<p>参考: <a href="http://stackoverflow.com/questions/31337891/net-http-http-contentlength-222-with-body-length-0">stackoverflow</a></p>

<p>具体例子：我是在构造<code>request</code>时这样子写:</p>

<pre><code class="language-bash">	bodyBuf := &amp;bytes.Buffer{}
	bodyWriter := multipart.NewWriter(bodyBuf)

	v := reflect.ValueOf(param)
	fileds := v.Elem()

	paramsMap := netURL.Values{}
	//defer bodyWriter.Close()

	return http.NewRequest(&quot;POST&quot;, URL, bodyBuf)
</code></pre>

<p>关键是那行：<code>defer bodyWriter.Close()</code>，注释掉这行就可以了.</p>

<h3 id="cannot-define-new-methods-on-non-local-type">cannot define new methods on non-local type</h3>

<pre><code class="language-bash">type MyRouter mux.Router

func (m *MyRouter) F() { ... }

或者

type MyRouter struct {
    *mux.Router
}

func (m *MyRouter) F() { ... }

...
r := &amp;MyRouter{router}
r.F()
</code></pre>

<h3 id="can-t-load-package-import-cycle-not-allowed">can&rsquo;t load package: import cycle not allowed</h3>

<pre><code class="language-bash">package project/controllers/account
    imports project/controllers/base
    imports project/components/mux
    imports project/controllers/account
</code></pre>

<p>这表明有循环引用，循环引用的结果为:</p>

<pre><code class="language-bash">                  project/controllers/account
                     ^                    \    
                    /                      \
                   /                        \ 
                  /                         \/
         project/components/mux &lt;--- project/controllers/base
</code></pre>

<p>只要处理掉这个循环引用的一条链即可解决.</p>

<h3 id="too-many-arguments-to-return">too many arguments to return</h3>

<p>一般来说，是你的方法签名中没有返回值，但你却进行了<code>return value</code>或者，你的方法签名中的返回值个数与<code>return 语句不匹配</code></p>

<h3 id="interface-is-pointer-to-interface-not-interface">*interface {} is pointer to interface, not interface</h3>

<p>这个应该是你想在方法里进行泛型例如写成这样子:</p>

<pre><code class="language-bash">package helper

import &quot;reflect&quot;

// SetDefaultValues : 设置参数默认值
func SetDefaultValues(param *interface{}) {
	v := reflect.ValueOf(param)
	fileds := v.Elem()
	for i := 0; i &lt; fileds.NumField(); i++ {
		field := fileds.Field(i)
		// Ignore fields that don't have the same type as a string
		if field.Type().Name() == &quot;string&quot; {
			//如果是一个字符串对象
			if field.CanSet() {
				field.SetString(&quot;&quot;)
			}
		} else if field.Type().Name() == &quot;int&quot; || field.Type().Name() == &quot;int64&quot; {
			//如果是整型
			if field.CanSet() {
				field.SetInt(-1)
			}
		}
	}
}

</code></pre>

<p>但其实<code>interface{}</code>它表示的是接收任意的类型（包括指针），所以，这里不能这样子，应该修改参数为:<code>param interface{}</code>即可。</p>

<p>这样子，在调用方法时，传递的是指针，那么它就代表指针，传递的是普通类型，那就是普通类型。</p>

<h3 id="cannot-use-nil-as-type-xxx">cannot use nil as type xxx</h3>

<p>这表你的xxx并不能接受<code>nil</code>值。（一般来说，只有指针类型才能接受nil值)</p>

<h3 id="found-packages-xxxx-and-xxxx-xxxx-in-xxxx">found packages xxxx () and xxxx (xxxx) in xxxx</h3>

<pre><code class="language-bash">┌─[sky@sky-linux] - [/ihome/go/golang-weibo-sdk/src/com.github.emacsist.weibosdk/api/business/status] - [2016-10-21 05:40:43]                              
└─[2] &lt;git:(master 3c154e3✱✈) &gt; go test -run StatusesRepostTimelineBizString                                                                               
../../../helper/HttpHelper.go:8:2: found packages resp (CommentsAndTotalNumberResp.go) and api (TagsTagsBatchOther.go) in /ihome/go/golang-weibo-sdk/src/co
m.github.emacsist.weibosdk/resp 
</code></pre>

<p>Go语言规则，所有在同一个目录的源文件，都必须是同属一个包的.解决了这个问题就可以编译通过了.</p>

<h2 id="struct-结构体的继承">struct 结构体的继承</h2>

<pre><code class="language-bash">// Person : test object
type Person struct {
	Name string
	Age  int
	Animal
}

type Animal struct {
    Colour string
    Name string
}

</code></pre>

<h2 id="go中的字符串转换为字符数组">Go中的字符串转换为字符数组</h2>

<pre><code class="language-bash">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(string(&quot;Hello&quot;[1]))              // ASCII only
    fmt.Println(string([]rune(&quot;Hello, 世界&quot;)[1])) // UTF-8
    fmt.Println(string([]rune(&quot;Hello, 世界&quot;)[8])) // UTF-8
}
</code></pre>

<p>千万要注意：<code>string[0:1]</code>这种形式是按<code>字节</code>来分隔的.<code>len(string)</code>返回的是字节数.
要操作字符的话，则要使用<code>rune</code>类型。</p>

<h2 id="golang中顶级的json数组字符串转换为json对象">Golang中顶级的JSON数组字符串转换为json对象</h2>

<pre><code class="language-bash">package main

import &quot;fmt&quot;
import &quot;encoding/json&quot;

type PublicKey struct {
	Id  int
	Key string
}

func main() {
	keysBody := []byte(`[{&quot;id&quot;: 1,&quot;key&quot;: &quot;-&quot;},{&quot;id&quot;: 2,&quot;key&quot;: &quot;-&quot;},{&quot;id&quot;: 3,&quot;key&quot;: &quot;-&quot;}]`)
	keys := make([]PublicKey, 0)
	json.Unmarshal(keysBody, &amp;keys)
	fmt.Printf(&quot;%#v&quot;, keys[2].Id)
}

</code></pre>

<h2 id="创建一个自定义的error">创建一个自定义的error</h2>

<pre><code class="language-bash">import &quot;errors&quot;

errors.New(&quot;xx&quot;)
</code></pre>

<h2 id="json数组转换为map">json数组转换为map</h2>

<pre><code class="language-bash">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

func main() {
	h := `[
    {
        &quot;221012100001985342&quot;: &quot;80后&quot;,
        &quot;weight&quot;: 50
    },
     {
        &quot;221012100001985342&quot;: &quot;80后1&quot;,
        &quot;weight&quot;: 51
    }
]`
	var hell []map[string]interface{}

	err := json.Unmarshal([]byte(h), &amp;hell)
	fmt.Printf(&quot;%v\n&quot;, err)
	fmt.Printf(&quot;%v\n&quot;, h)
	fmt.Printf(&quot;%v\n&quot;, hell)
}

</code></pre>

<h2 id="go交叉编译">Go交叉编译</h2>

<p>进入Go的安装目录<code>cd $GOROOT/src</code>，然后 选择要生成的目标构架的工具链:</p>

<pre><code class="language-bash"># windows64位
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash

# mac
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 ./make.bash

# linux 64
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 ./make.bash
</code></pre>

<h3 id="常见错误-1">常见错误:</h3>

<pre><code class="language-bash">┌─[sky@sky-linux] - [/ihome/go/go-current/src] - [2016-10-26 02:14:42]
└─[0] &lt;&gt; CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash
##### Building Go bootstrap tool.
cmd/dist
ERROR: Cannot find /home/sky/go1.4/bin/go.
Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4.
</code></pre>

<p>这表需要有一个<code>&gt;=1.4</code>的另一个<code>go</code>安装目录，并将<code>GOROOT_BOOTSTRAP</code>指向该目录即可.</p>

<h3 id="linux下交叉编译mac">Linux下交叉编译Mac</h3>

<p><a href="http://stackoverflow.com/questions/34084597/cross-compilation-of-cgo-for-darwin-fails">stackoverflow</a></p>

<h3 id="os常量以及arch常量">OS常量以及ARCH常量</h3>

<p><a href="https://github.com/golang/go/blob/master/src/go/build/syslist.go">syslist</a></p>

<pre><code class="language-bash">
package build

const goosList = &quot;android darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows zos &quot;
const goarchList = &quot;386 amd64 amd64p32 arm armbe arm64 arm64be ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc s390 s390x sparc sparc64 &quot;

</code></pre>

<h2 id="go打包静态资源">Go打包静态资源</h2>

<p>安装: <code>go get -u github.com/jteeuwen/go-bindata/...</code></p>

<p><a href="https://github.com/jteeuwen/go-bindata">go-bindata</a></p>

<p>假设<code>/tmp/go</code>是一个<code>$GOPATH</code>:</p>

<pre><code class="language-bash">┌─[sky@sky-linux] - [/tmp/go] - [2016-10-26 03:25:55]
└─[0] &lt;&gt; ll /tmp/go/src/nlp/dict
total 820K
-rw-r--r-- 1 sky sky 3.1K 10月 25 18:36 adv_full.txt
-rw-r--r-- 1 sky sky 3.2K 10月 25 18:36 adv.txt
-rw-r--r-- 1 sky sky 212K 10月 25 18:36 neg_full.txt
-rw-r--r-- 1 sky sky 305K 10月 25 18:36 neg.txt
-rw-r--r-- 1 sky sky  273 10月 25 18:36 not_full.txt
-rw-r--r-- 1 sky sky  287 10月 25 18:36 not.txt
-rw-r--r-- 1 sky sky 116K 10月 25 18:36 pos_full.txt
-rw-r--r-- 1 sky sky 149K 10月 25 18:36 pos.txt
-rw-r--r-- 1 sky sky 8.0K 10月 25 21:21 stp_full.txt
-rw-r--r-- 1 sky sky 8.0K 10月 25 18:36 stp.txt

┌─[sky@sky-linux] - [/tmp/go] - [2016-10-26 12:35:32]                                                                                                                      
└─[0] &lt;&gt; ./bin/go-bindata -o=src/nlp/asset/asset.go -pkg=asset -prefix &quot;/tmp/go/src/nlp/&quot; /tmp/go/src/nlp/dict
</code></pre>

<p>说明：</p>

<p><code>-o</code> : 表示生成静态资源的访问包的文件.
<code>-pkg</code> ： 表示包名
<code>-prefix</code> ： 表示自动添加的前缀。</p>

<p><code>/tmp/go/src/nlp/dict</code>表示静态资源的目录.如果要递归的话，可以这样子写: <code>/tmp/go/src/nlp/dict/...</code></p>

<p>成功后，可以看到生成了一个新的文件:<code>/tmp/go/src/nlp/asset/asset.go</code></p>

<p>使用例子:</p>

<pre><code class="language-bash">import (
	&quot;nlp/asset&quot;
)

func init() {
	fmt.Printf(&quot;init --&gt; %v\n&quot;, asset.AssetNames())
	loadDict(&quot;dict/adv_full.txt&quot;, &amp;advMap)
	loadDict(&quot;dict/neg_full.txt&quot;, &amp;negMap)
	loadDict(&quot;dict/not_full.txt&quot;, &amp;notMap)
	loadDict(&quot;dict/pos_full.txt&quot;, &amp;posMap)
	loadDict(&quot;dict/stp_full.txt&quot;, &amp;stpMap)
}

func loadDict(path string, dic *map[string]bool) {
	//&quot;dict/adv_full.txt&quot;
	data, _ := asset.Asset(path)
	bufferReader := bytes.NewReader(data)
	scan := bufio.NewScanner(bufferReader)
	for scan.Scan() {
		t := scan.Text()
		(*dic)[t] = true
	}
}
</code></pre>

<p>因为我们添加了<code>-prefix &quot;/tmp/go/src/nlp/&quot;</code>, 所以，我们可以直接这样子： <code>dict/adv_full.txt</code>的路径，就可以通过<code>asset.Asset(&quot;dict/adv_full.txt&quot;)</code>来访问我们的静态资源了.</p>

<h3 id="常用编译选项">常用编译选项</h3>

<p>输出所有可用编译选项:</p>

<pre><code class="language-bash">go tool compile -help
</code></pre>

<h4 id="去掉调试信息">去掉调试信息</h4>

<pre><code class="language-bash">go build -ldflags '-w'
</code></pre>

<h4 id="查看优化的信息-内联-inline-信息-逃逸分析等">查看优化的信息(内联 inline 信息、逃逸分析等)</h4>

<pre><code class="language-bash">go build -gcflags=-m 
</code></pre>

<h2 id="数组与slice-区别">数组与slice 区别</h2>

<pre><code class="language-bash">package main

import &quot;fmt&quot;

func main() {
	arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	sliceArray := arr[3:5]

	// 由此可知，slice是一种引用类型，因为它的第一个元素地址，与arr[3]的地址是一样的
	fmt.Printf(&quot;arr[3] address = %v\n&quot;, &amp;arr[3])
	fmt.Printf(&quot;sliceArray[0] address = %v\n&quot;, &amp;sliceArray[0])

	// len = 2
	fmt.Printf(&quot;len slice = %v\n&quot;, len(sliceArray))

	// cap = 7，cap的计算，是从第一个slice元素的位置，到原数组的结尾的长度.
	fmt.Printf(&quot;cap slice = %v\n&quot;, cap(sliceArray))

	// 因为sliceArray的cap为7,已经存在2个，那还可以容纳5个元素，这时引用的，还是arr数组，这样子append后，会修改arr的内容
	// arr 为 : [0 1 2 3 4 1 2 3 4 5]
	// sliceArray 为 : [3 4 1 2 3 4 5
	sliceArray = append(sliceArray, 1, 2, 3, 4, 5)

	// 当cap还在arr容纳范围之内时，slice指向的就是arr,通过打印他们的地址可知:
	fmt.Printf(&quot;arr[5] address = %v， value=%v\n&quot;, &amp;arr[6], arr[6])
	fmt.Printf(&quot;sliceArray[2] address = %v, value=%v\n&quot;, &amp;sliceArray[3], sliceArray[3])

	//但当sliceArray超过了cap时: [3 4 1 2 3 4 5 1 2 3 4 5]
	sliceArray = append(sliceArray, 1, 2, 3, 4, 5)
	// 可以发现，它指向了一个新的数组:因为他们的地址不同了.
	fmt.Printf(&quot;arr[5] address = %v， value=%v\n&quot;, &amp;arr[6], arr[6])
	fmt.Printf(&quot;sliceArray[2] address = %v, value=%v\n&quot;, &amp;sliceArray[3], sliceArray[3])
	fmt.Printf(&quot;cap slice = %v\n&quot;, cap(sliceArray))

	fmt.Printf(&quot;%v, %v\n&quot;, arr, sliceArray)
}

</code></pre>

<p>append超出cap之前与之后：</p>

<pre><code class="language-bash">package main

import &quot;fmt&quot;

func main() {
	arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	sliceArray := arr[3:5]
	sliceArray2 := arr[3:5]

	fmt.Printf(&quot;%v, %v, %v\n&quot;, arr, sliceArray, sliceArray2)
	fmt.Printf(&quot;%v, %v, %v\n&quot;, &amp;arr[3], &amp;sliceArray[0], &amp;sliceArray2[0])

	sliceArray = append(sliceArray, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)

	fmt.Printf(&quot;%v, %v, %v\n&quot;, arr, sliceArray, sliceArray2)
	fmt.Printf(&quot;%v, %v, %v\n&quot;, &amp;arr[3], &amp;sliceArray[0], &amp;sliceArray2[0])
}
</code></pre>

<h2 id="go中使用-redis">Go中使用 redis</h2>

<pre><code class="language-bash">package main

import (
	&quot;flag&quot;
	&quot;time&quot;

	&quot;fmt&quot;

	&quot;github.com/garyburd/redigo/redis&quot;
)

func newPool(server, password string) *redis.Pool {
	return &amp;redis.Pool{
		MaxIdle:     3,
		IdleTimeout: 240 * time.Second,
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial(&quot;tcp&quot;, server)
			if err != nil {
				return nil, err
			}
			if len(password) &gt; 0 {
				if _, err := c.Do(&quot;AUTH&quot;, password); err != nil {
					c.Close()
					return nil, err
				}
			}
			return c, err
		},
		TestOnBorrow: func(c redis.Conn, t time.Time) error {
			if time.Since(t) &lt; time.Minute {
				return nil
			}
			_, err := c.Do(&quot;PING&quot;)
			return err
		},
	}
}

var (
	pool          *redis.Pool
	redisServer   = flag.String(&quot;redisServer&quot;, &quot;:6379&quot;, &quot;&quot;)
	redisPassword = flag.String(&quot;redisPassword&quot;, &quot;&quot;, &quot;&quot;)
)

func main() {
	redisGet()
	redisPipline()
}

func redisGet() {
	redisConnection := pool.Get()
	defer redisConnection.Close()

	//如果这个不为空，表明获取链接时出错
	if redisConnection.Err() != nil {
		fmt.Printf(&quot;Hello World %v\n&quot;, redisConnection.Err().Error())
		return
	}

	val, err := redisConnection.Do(&quot;get&quot;, &quot;hello2&quot;)
	if err == nil {
		fmt.Printf(&quot;Hello %v\n&quot;, string(val.([]uint8)))
	} else {
		fmt.Printf(&quot;happen error : %v\n&quot;, err.Error())
	}

}

func redisPipline() {
	redisConnection := pool.Get()
	defer redisConnection.Close()

	//如果这个不为空，表明获取链接时出错
	if redisConnection.Err() != nil {
		fmt.Printf(&quot;Hello World %v\n&quot;, redisConnection.Err().Error())
		return
	}

	redisConnection.Send(&quot;get&quot;, &quot;hello&quot;)
	redisConnection.Send(&quot;get&quot;, &quot;hello1&quot;)
	redisConnection.Send(&quot;get&quot;, &quot;hello2&quot;)

	redisConnection.Flush()

	for i := 0; i &lt; 3; i++ {
		data, err := redisConnection.Receive()

		if err == nil &amp;&amp; redisConnection.Err() == nil {
			if data == nil {
				continue
			}
			fmt.Printf(&quot;Hello from pipline %v\n&quot;, string(data.([]uint8)))
			continue
		} else {
			fmt.Printf(&quot;Hello from pipline error %v\n&quot;, err.Error())
			break
		}
	}
	fmt.Printf(&quot;done\n&quot;)
}

func init() {
	flag.Parse()
	fmt.Printf(&quot;redis: server = %v, passwd = %v\n&quot;, *redisServer, *redisPassword)
	pool = newPool(*redisServer, *redisPassword)
	fmt.Printf(&quot;init redis connection pool ok\n&quot;)
}


</code></pre>

<p>注意，这个默认是<code>db 0</code>，如果想实现选择（虽然不推荐使用多个DB），可以按如下链接做:</p>

<p><a href="http://stackoverflow.com/questions/25708256/golang-selecting-db-on-a-redispool-in-redigo">stackoverflow</a></p>

<h2 id="go-中使用-gorm-与-mysql-交互">Go 中使用 gorm 与 mysql 交互</h2>

<pre><code class="language-bash">package main

import (
	&quot;fmt&quot;

	&quot;time&quot;

	&quot;github.com/jinzhu/gorm&quot;
	_ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;
)

type WbStatus struct {
	ID       int64 `gorm:&quot;primary_key&quot;`
	Text     string
	CreateAt time.Time
}

func (WbStatus) TableName() string {
	return &quot;wb_status&quot;
}

var db *gorm.DB

func main() {
	if db == nil {
		panic(&quot;db is nil&quot;)
	}
	var wbstatus WbStatus
	fmt.Printf(&quot;tableName = %v\n&quot;, wbstatus.TableName())
	db.First(&amp;wbstatus)

	fmt.Printf(&quot;rowId = %v\n&quot;, wbstatus.ID)
	fmt.Printf(&quot;createAt = %v\n&quot;, wbstatus.CreateAt)
	defer db.Close()
}

func init() {
	var err error
	db, err = gorm.Open(&quot;mysql&quot;, &quot;root:yang@(127.0.0.1:3306)/test?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;)
	if err != nil {
		fmt.Printf(&quot;init mysql error : %v\n&quot;, err.Error())
		panic(&quot;exit&quot;)
	}
	if db == nil {
		fmt.Printf(&quot;init mysql error : db is null\n&quot;)
		panic(&quot;exit&quot;)
	} else {
		fmt.Printf(&quot;init mysql  : db isnot null\n&quot;)
	}
	db.DB().SetMaxOpenConns(100)
	db.DB().SetMaxIdleConns(10)
	fmt.Printf(&quot;init mysql OK\n&quot;)
}

</code></pre>

<p><a href="http://jinzhu.me/gorm/">gorm</a></p>

<h2 id="go-中使用-rabbitmq">go 中使用 rabbitmq</h2>

<p><a href="https://github.com/streadway/amqp">github amqp</a></p>

<p><a href="http://stackoverflow.com/questions/36179111/whether-to-create-connection-every-time-when-amqp-dial-is-threadsafe-or-not-in-g">whether-to-create-connection-every-time-when-amqp-dial-is-threadsafe-or-not-in-golang</a></p>

<p><a href="https://ninefinity.org/post/ensuring-rabbitmq-connection-in-golang/">ensuring-rabbitmq-connection-in-golang</a></p>

<h3 id="注意事项">注意事项</h3>

<pre><code class="language-bash">ch, _ := mqCon.Channel()
	msgs, err := ch.Consume(
		config.Configuration.Rabbit.Listen,     // queue
		config.Configuration.Rabbit.ConsumerID, // consumer
		true,  // auto-ack
		false, // exclusive
		false, // no-local
		false, // no-wait
		nil,   // args
	)
</code></pre>

<p>如果你将<code>auto-ack</code>设置为true，则不用手工确认消息。如果设置为<code>false</code>，则必须手工调用:</p>

<pre><code class="language-bash">Delivery.Ack, Delivery.Reject or Delivery.Nack
</code></pre>

<p><a href="https://agocs.org/blog/2014/08/19/rabbitmq-best-practices-in-go/">rabbitmq-best-practices-in-go</a></p>

<p><code>autoAck</code>:</p>

<blockquote>
<p>When autoAck (also known as noAck) is true, the server will acknowledge
deliveries to this consumer prior to writing the delivery to the network.  When
autoAck is true, the consumer should not call Delivery.Ack.  Automatically
acknowledging deliveries means that some deliveries may get lost if the
consumer is unable to process them after the server delivers them.</p>
</blockquote>

<h2 id="go中long与timestamp-json的转换">go中long与timestamp json的转换</h2>

<p><a href="http://stackoverflow.com/questions/31744970/convert-to-time-in-golang-from-milliseconds">convert-to-time-in-golang-from-milliseconds</a></p>

<p><code>type A B只是让A获得B的内存模型而已。A不会继承B的方法，但A和B可以使用A()或B()来互相转换。</code></p>

<p><a href="http://golangtc.com/t/57fdbb43b09ecc08ce000121">golangtc</a></p>

<h2 id="go-中找出实现了某接口的代码">Go 中找出实现了某接口的代码</h2>

<pre><code class="language-bash">egrep -nr '^func (.*) ReadByte\(' *
</code></pre>

<h2 id="golang中实现优雅关闭程序">Golang中实现优雅关闭程序</h2>

<pre><code class="language-bash">func main() {

	sigs := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	// sigs 表示将收到的信号放到这个管道中。后面的参数表示你想处理的系统信号
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	//开启一个Go routine来监听信号
	go func() {
		sig := &lt;-sigs
		done &lt;- true
	}()

	//这里添加你的程序的功能（监听器，处理器等）
	fmt.Println(&quot;awaiting signal&quot;)
	&lt;-done
	fmt.Println(&quot;exiting&quot;)
}
</code></pre>

<p>常见信号:</p>

<pre><code class="language-bash">Signal Name	Number	Description
SIGHUP	1	Hangup (POSIX)
SIGINT	2	Terminal interrupt (ANSI)
SIGQUIT	3	Terminal quit (POSIX)
SIGILL	4	Illegal instruction (ANSI)
SIGTRAP	5	Trace trap (POSIX)
SIGIOT	6	IOT Trap (4.2 BSD)
SIGBUS	7	BUS error (4.2 BSD)
SIGFPE	8	Floating point exception (ANSI)
SIGKILL	9	Kill(can't be caught or ignored) (POSIX)
SIGUSR1	10	User defined signal 1 (POSIX)
SIGSEGV	11	Invalid memory segment access (ANSI)
SIGUSR2	12	User defined signal 2 (POSIX)
SIGPIPE	13	Write on a pipe with no reader, Broken pipe (POSIX)
SIGALRM	14	Alarm clock (POSIX)
SIGTERM	15	Termination (ANSI)
SIGSTKFLT	16	Stack fault
SIGCHLD	17	Child process has stopped or exited, changed (POSIX)
SIGCONT	18	Continue executing, if stopped (POSIX)
SIGSTOP	19	Stop executing(can't be caught or ignored) (POSIX)
SIGTSTP	20	Terminal stop signal (POSIX)
SIGTTIN	21	Background process trying to read, from TTY (POSIX)
SIGTTOU	22	Background process trying to write, to TTY (POSIX)
SIGURG	23	Urgent condition on socket (4.2 BSD)
SIGXCPU	24	CPU limit exceeded (4.2 BSD)
SIGXFSZ	25	File size limit exceeded (4.2 BSD)
SIGVTALRM	26	Virtual alarm clock (4.2 BSD)
SIGPROF	27	Profiling alarm clock (4.2 BSD)
SIGWINCH	28	Window size change (4.3 BSD, Sun)
SIGIO	29	I/O now possible (4.2 BSD)
SIGPWR	30	Power failure restart (System V)
</code></pre>

<h3 id="检查程序监控了哪些信号">检查程序监控了哪些信号</h3>

<p><a href="http://unix.stackexchange.com/questions/85364/how-can-i-check-what-signals-a-process-is-listening-to">signals</a></p>

<h2 id="golang中的struct-tag使用">Golang中的struct tag使用</h2>

<pre><code class="language-bash">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

// Person :
type Person struct {
	Name string `mytag:&quot;HelloName&quot;`
}

func main() {
	p := Person{Name: &quot;emacsist&quot;}
	refValue := reflect.ValueOf(&amp;p)

	fields := refValue.Elem()
	for i := 0; i &lt; fields.NumField(); i++ {
		field := fields.Field(i)
		fieldName := fields.Type().Field(i).Name
		fieldValue := field.Interface()
		fieldTag := fields.Type().Field(i).Tag.Get(&quot;mytag&quot;)
		fmt.Printf(&quot;fieldName = %v, fieldValue = %v, tagName = %v\n&quot;, fieldName, fieldValue, fieldTag)
	}
}

</code></pre>

<h2 id="限制goalng的http-工作线程-goroutine">限制Goalng的HTTP 工作线程(goroutine)</h2>

<pre><code class="language-bash">	connectionCount := 5000

	l, err := net.Listen(&quot;tcp&quot;, &quot;:9090&quot;)

	if err != nil {
		log.Fatalf(&quot;Listen: %v&quot;, err)
	}

	l = netutil.LimitListener(l, connectionCount)
	log.Fatal(http.Serve(l, nil))
	logrus.Infof(&quot;start server success. %v&quot;, ListenAddress)
</code></pre>

<h2 id="为什么我的内存没有被操作系统回收">为什么我的内存没有被操作系统回收？</h2>

<p><a href="http://stackoverflow.com/questions/24376817/go-1-3-garbage-collector-not-releasing-server-memory-back-to-system">stackoverflow</a></p>

<p><a href="https://golang.org/pkg/runtime/debug/">golang</a></p>

<h2 id="golang1-8-中的优雅关闭-http">Golang1.8 中的优雅关闭 http</h2>

<pre><code class="language-go">
	s := &amp;http.Server{
		Addr: &quot;:9090&quot;,
	}
	go func() {
		log.Infof(&quot;%s&quot;, s.ListenAndServe())
	}()
	// Handle SIGINT and SIGTERM.
	ch := make(chan os.Signal)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	log.Println(&lt;-ch)

	log.Println(&quot;http server gracefully stopping...&quot;)
	// Stop the service gracefully.
	s.Shutdown(context.Background())
	log.Println(&quot;http server gracefully shutdown done...&quot;)

</code></pre>

<h2 id="按-github-风格的项目组织结构">按 github 风格的项目组织结构</h2>

<p><a href="https://github.com/golang/go/wiki/GithubCodeLayout">github code layout</a></p>

<h2 id="压缩编译后的文件大小">压缩编译后的文件大小</h2>

<h3 id="去掉符号信息">去掉符号信息</h3>

<pre><code class="language-bash">go build -ldflags &quot;-s -w&quot;
</code></pre>

<h3 id="使用-upx-压缩">使用 upx 压缩</h3>

<pre><code class="language-bash">upx -9 GoBinaryFile
</code></pre>

<h2 id="golang-中的-web">Golang 中的 web</h2>

<p>在 web 中使用 panic 只会退出当前的 goroutine ，而不会整个应用程序退出。</p>

<p>在一般应用中，如果没有捕捉 panic() 的话，就会导致整个应用退出:</p>

<pre><code class="language-bash">package main

import (
	&quot;sync&quot;
	&quot;time&quot;
)

func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		time.Sleep(5 * time.Second)
		println(&quot;Hello World&quot;)
		panic(&quot;==================&gt;&quot;)
	}()

	go func() {
		time.Sleep(2 * time.Second)
		println(&quot;Hello World2&quot;)
		panic(&quot;==================&gt;2&quot;)
	}()
	wg.Wait()
}

</code></pre>

<h2 id="短声明注意">短声明注意</h2>

<p>短声明只能声明局部变量，而且它会覆盖外部的同名变量。</p>

<p>所以，如果目的是想进行外部变量的初始化的话，这点可能没达到我们想要的目的，这点要特别注意。</p>

<h2 id="类型转换">类型转换</h2>

<p>不论显式还是隐式的 <em>常量</em> 的类型转换，常量从一种类型转换为另一种类型，都要求目标类型能够表示 <em>原值</em></p>

<h2 id="golang-中格式化日期">Golang 中格式化日期</h2>

<pre><code class="language-bash">YYYY-MM-DD HH:mm:ss 
对应
2006-01-02 15:04:05
</code></pre>

<h2 id="go-中发送登录请求-保持-cookie">Go 中发送登录请求（保持 cookie)</h2>

<p><a href="https://stackoverflow.com/questions/18414212/golang-how-to-follow-location-with-cookie">stackoverflow.com</a></p>

<pre><code class="language-bash">package main

import (
    &quot;golang.org/x/net/publicsuffix&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;net/http/cookiejar&quot;
)

func main() {
    options := cookiejar.Options{
        PublicSuffixList: publicsuffix.List,
    }
    jar, err := cookiejar.New(&amp;options)
    if err != nil {
        log.Fatal(err)
    }
    client := http.Client{Jar: jar}
    resp, err := client.Get(&quot;http://dubbelboer.com/302cookie.php&quot;)
    if err != nil {
        log.Fatal(err)
    }
    data, err := ioutil.ReadAll(resp.Body)
    resp.Body.Close()
    if err != nil {
        log.Fatal(err)
    }
    log.Println(string(data))
}
</code></pre>

<h2 id="go-中提交表单">Go 中提交表单</h2>

<pre><code class="language-bash">
	form := url.Values{}
	form.Add(&quot;qps&quot;, strconv.FormatInt(qps, 10))


	setQPSRequest, err := http.NewRequest(&quot;POST&quot;, loginURL, strings.NewReader(form.Encode()))
	if err != nil {
		return
	}

	setQPSRequest.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=utf-8&quot;)
</code></pre>

<h2 id="logrus-设置日志时间格式">logrus 设置日志时间格式</h2>

<p>logrus 设置日期</p>

<pre><code class="language-bash">func init() {
	formatter := &amp;logrus.TextFormatter{
		FullTimestamp: true,
	}
	logrus.SetFormatter(formatter)
}
</code></pre>

<h2 id="go-中自动重连-rabbitmq">Go 中自动重连 RabbitMQ</h2>

<pre><code class="language-bash">var (
	connectionDone = make(chan *amqp.Error)
	conn           *amqp.Connection
	channel        *amqp.Channel
)

func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf(&quot;%s: %s&quot;, msg, err)
	}
}

func init() {
	connectToRabbitMQ()
	go rabbitConnector()
}

func connectToRabbitMQ() *amqp.Connection {
	for {
		conn, err := amqp.Dial(config.AppConfig.GetAmqpUrl())

		if err == nil {
			if channel != nil {
				//要先关闭之前的 channel
				log.Warnf(&quot;close before channel&quot;)
				channel.Close()
			}
			channel, _ = conn.Channel()
			log.Infof(&quot;conn address = %p, channel address =%p&quot;, config.AppConfig.GetAmqpUrl(), channel)
			return conn
		}
		log.Errorf(&quot;error connect to rabbitmq. %s&quot;, err.Error())
		log.Warnf(&quot;Trying to reconnect to RabbitMQ at %v&quot;, config.AppConfig.GetAmqpUrl())
		time.Sleep(500 * time.Millisecond)
	}
}

func rabbitConnector() {
	for {
		closeEvent := &lt;-connectionDone
		if closeEvent != nil {
			log.Errorf(&quot;receive connection closed event!&quot;)
			log.Errorf(&quot;Connecting to %v&quot;, config.AppConfig.GetAmqpUrl())
			//每一次创建时，都要用新的 chan 对象来接收通知。否则会报 panic: send on closed channel
			// update 2017-4-14
			connectionDone = make(chan *amqp.Error)
			conn = connectToRabbitMQ()
			conn.NotifyClose(connectionDone)
		}
	}
}
</code></pre>

<h2 id="go-中批量处理-sql">Go 中批量处理 SQL</h2>

<pre><code class="language-bash">	insertStatement := &quot;INSERT OR  REPLACE INTO indice (index_name, static_pe, pe_ttm, static_pb, sse, last_year_static_pe, last_year_pe_ttm, last_year_pb, statis_date) VALUES &quot;
	vals := []interface{}{}

	for _, row := range rows {
		insertStatement += &quot;(?, ?, ?, ?, ?, ?, ?, ?, ?),&quot;
		vals = append(vals, row.Index_name, row.Static_pe, row.Pe_ttm, row.Static_pb, row.Sse, row.Last_year_static_pe, row.Last_year_pe_ttm, row.Last_year_pb, row.Pe_date)
		if Debug {
			log.Infof(&quot;row =&gt; %v&quot;, row)
		}
	}
	//删除最后的 ,
	insertStatement = insertStatement[0:len(insertStatement)-1]
	//prepare the statement

	if Debug {
		log.Infof(&quot;insertStatement =&gt; %v&quot;, insertStatement)
	}

	stmt, err := db.Prepare(insertStatement)

	if err != nil {
		panic(err)
	}

	res, _ := stmt.Exec(vals...)

	effectRow, _ := res.RowsAffected()
	fmt.Printf(&quot;done.  affected %v&quot;, effectRow)
</code></pre>

<h2 id="go-中处理-gbk-字符集">Go 中处理 GBK 字符集</h2>

<pre><code class="language-bash">导入

&quot;golang.org/x/text/encoding/simplifiedchinese&quot;
&quot;golang.org/x/text/transform&quot;
</code></pre>

<pre><code class="language-bash">	robots, err := ioutil.ReadAll(response.Body)

	sr := strings.NewReader(string(robots))
	tr := transform.NewReader(sr, simplifiedchinese.GB18030.NewDecoder())
	b, _ := ioutil.ReadAll(tr)
	result := string(b)
	return result
</code></pre>

<h2 id="go-中-get-请求的参数处理">Go 中 GET 请求的参数处理</h2>

<pre><code class="language-bash">	req, err := http.NewRequest(http.MethodGet, CsindexUrl, nil)
    q := req.URL.Query()
	q.Add(&quot;参数名&quot;, &quot;参数值&quot;)
	req.URL.RawQuery = q.Encode()

    # 添加 cookie
    cookie1 := &amp;http.Cookie{
		Name:  &quot;XSRF-TOKEN&quot;,
		Value: &quot;eyJpdiI6ImYrZVwvM2k3YlF4NDhIRG1DU3A0cXNRPT0iLCJ2YWx1ZSI6IkdLc3NYUDBidVd3V3JUamY0a1FSb1pBVGxiVmxBYTRHRHBxTDRmUW92V2hhMjE1bUpPMGFOUStJSVg3RmdvdXQ0eFgrRDliSElod3hHdWRlRFwvbGo2Zz09IiwibWFjIjoiOTNjNWQyZjk0YjFjYWJjZTc3ZGE1ZjQ1Y2IyZGQzNmVjYTI3YWRiNDRmNjg2MjBkMDEzMGE2ODhkZTBmZTJhNiJ9&quot;,
	}
	cookie2 := &amp;http.Cookie{
		Name:  &quot;laravel_session&quot;,
		Value: &quot;eyJpdiI6ImZzTlJMb0NZVHMwRElqcGYzd2FmZ0E9PSIsInZhbHVlIjoiRktjN2xNczl0Z0hlN09MMzRRcmlcL1RNazZQRXJhT1FTWnh1V2o3TzVnTGhcL2RVMys5aHAwRmxyTlBJRWFramlzd29KRnpOMFcxVW1kanVxZDEzajJ1UT09IiwibWFjIjoiNmJlOTFiMDkxY2NkOTkyNGI2NzdjYmM0YmI3MWZmYmU1NDI0OWI2ZDcwZjc0NTdjNDU1NDQ1YjM0YzJhMTc0OSJ9&quot;,
	}

	req.AddCookie(cookie1)
	req.AddCookie(cookie2)

    response, err := http.DefaultClient.Do(req)
</code></pre>

<h2 id="go-中调试-http-的-request-和-response">Go 中调试 http 的 request 和 response</h2>

<blockquote>
<p>这个类似 curl -v 的参数.</p>
</blockquote>

<p>这个要导入包 <code>&quot;net/http/httputil&quot;</code></p>

<pre><code class="language-bash">
debug(httputil.DumpRequestOut(req, true))


debug(httputil.DumpResponse(response, true))

func debug(data []byte, err error) {
	if err == nil {
		fmt.Printf(&quot;%s\n\n&quot;, data)
	} else {
		log.Fatalf(&quot;%s\n\n&quot;, err)
	}
}
</code></pre>

<h2 id="go-中按行读取-string">Go 中按行读取 string</h2>

<pre><code class="language-bash">	scanner := bufio.NewScanner(strings.NewReader(bodyString))
	for scanner.Scan() {
		line := scanner.Text()
    }
</code></pre>

<h2 id="go-中按空格-split-字符串">Go 中按空格 split 字符串</h2>

<pre><code class="language-bash">fields := strings.Fields(str)
</code></pre>

<h2 id="读取-json-文件为-struct-结构体">读取 json 文件为 struct 结构体</h2>

<blockquote>
<p>这里的路径是从 二进制文件所在的根目录下开始读取 filePath</p>
</blockquote>

<pre><code class="language-bash">// readJSON: 从 filePath 里读取数据, 并转换为 jsonObject 对象
func readJSON(filePath string, jsonObject interface{}) {
	appPath, e := os.Executable()
	if e != nil {
		logrus.Errorf(&quot;File error: %v\n&quot;, e)
		os.Exit(1)
	}

	file, e := ioutil.ReadFile(path.Dir(appPath) + &quot;/&quot; + filePath)
	if e != nil {
		logrus.Errorf(&quot;File error: %v\n&quot;, e)
		os.Exit(1)
	}
	e = json.Unmarshal(file, jsonObject)
	if e != nil {
		logrus.Errorf(&quot;invalid json data error: %v\n&quot;, e)
		os.Exit(1)
	}
}
</code></pre>

<h2 id="string-与-int-互转">string 与 int 互转</h2>

<pre><code class="language-bash">int -&gt; string
strconv.Itoa(e.Port)

string -&gt; int
v, _ = strconv.Atoi(str)
</code></pre>

<h2 id="go-中-http-client-的-timeout-设置">Go 中 http client 的 timeout 设置</h2>

<pre><code class="language-bash">timeout := time.Duration(5 * time.Second)
client := http.Client{
    Timeout: timeout,
}
client.Get(url)
</code></pre>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">emacsist</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2016-10-18</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/wxpay.jpeg">
        <span>wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/img/alipay.jpeg">
        <span>alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/golang/">golang</a>
          
          <a href="/tags/go/">go</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://emacsist.github.io/2016/10/30/golang-%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89-json-%E8%BD%AC%E6%8D%A2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang 中自定义 JSON 转换</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://emacsist.github.io/2016/10/17/mysql%E4%B8%AD%E6%8C%89%E6%9D%A1%E4%BB%B6count/">
            <span class="next-text nav-default">MySQL中按条件count</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2016-10-18 19:35:00 \x2b0000 UTC',
    title: 'Go学习',
    link: decodeURI(location.href),
    desc: '安装多个版本的 go GVM Go依赖管理与 GOPATH 的关系. GOPATH环境变',
    owner: 'emacsist',
    repo: 'emacsist.github.io',
    oauth: {
      client_id: 'd1456501fba5329f3afa',
      client_secret: 'd1ecbb7929a49de947215701320c60b312a72d3a'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:emacsist@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/emacsist2016" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://plus.google.com/u/0/114200054463267049438" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/emacsist" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/emacist" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/emacsist/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://emacsist.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>


  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">emacsist</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-118327923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>










</body>
</html>
